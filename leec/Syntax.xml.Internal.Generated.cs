// <auto-generated />

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Threading;

namespace leec
{
	/// <summary>Provides the base class from which the classes that represent name syntax nodes are derived. This is an abstract class.</summary>
	public abstract partial class NameSyntax : TypeSyntax
	{
		public NameSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
		  : base(kind, diagnostics, annotations)
		{
		}
		public NameSyntax(SyntaxKind kind)
		  : base(kind)
		{
		}
	}

	/// <summary>Provides the base class from which the classes that represent simple name syntax nodes are derived. This is an abstract class.</summary>
	public abstract partial class SimpleNameSyntax : NameSyntax
	{
		public SimpleNameSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
		  : base(kind, diagnostics, annotations)
		{
		}
		public SimpleNameSyntax(SyntaxKind kind)
		  : base(kind)
		{
		}

		/// <summary>SyntaxToken representing the identifier of the simple name.</summary>
		public abstract SyntaxToken Identifier { get; }
	}

	/// <summary>Class which represents the syntax node for identifier name.</summary>
	public sealed partial class IdentifierNameSyntax : SimpleNameSyntax
	{
		public readonly SyntaxToken identifier;

		public IdentifierNameSyntax(SyntaxKind kind, SyntaxToken identifier, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
		}


		public IdentifierNameSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
		}


		public IdentifierNameSyntax(SyntaxKind kind, SyntaxToken identifier)
			: base(kind)
		{
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
		}

		/// <summary>SyntaxToken representing the keyword for the kind of the identifier name.</summary>
		public override SyntaxToken Identifier { get { return this.identifier; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.identifier;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitIdentifierName(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitIdentifierName(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new IdentifierNameSyntax(this.Kind, this.identifier, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new IdentifierNameSyntax(this.Kind, this.identifier, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents the syntax node for qualified name.</summary>
	public sealed partial class QualifiedNameSyntax : NameSyntax
	{
		public readonly NameSyntax left;
		public readonly SyntaxToken dotToken;
		public readonly SimpleNameSyntax right;

		public QualifiedNameSyntax(SyntaxKind kind, NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(left);
			this.left = left;
			this.AdjustFlagsAndWidth(dotToken);
			this.dotToken = dotToken;
			this.AdjustFlagsAndWidth(right);
			this.right = right;
		}


		public QualifiedNameSyntax(SyntaxKind kind, NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(left);
			this.left = left;
			this.AdjustFlagsAndWidth(dotToken);
			this.dotToken = dotToken;
			this.AdjustFlagsAndWidth(right);
			this.right = right;
		}


		public QualifiedNameSyntax(SyntaxKind kind, NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(left);
			this.left = left;
			this.AdjustFlagsAndWidth(dotToken);
			this.dotToken = dotToken;
			this.AdjustFlagsAndWidth(right);
			this.right = right;
		}

		/// <summary>NameSyntax node representing the name on the left side of the dot token of the qualified name.</summary>
		public NameSyntax Left { get { return this.left; } }
		/// <summary>SyntaxToken representing the dot.</summary>
		public SyntaxToken DotToken { get { return this.dotToken; } }
		/// <summary>SimpleNameSyntax node representing the name on the right side of the dot token of the qualified name.</summary>
		public SimpleNameSyntax Right { get { return this.right; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.left;
				case 1: return this.dotToken;
				case 2: return this.right;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitQualifiedName(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitQualifiedName(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new QualifiedNameSyntax(this.Kind, this.left, this.dotToken, this.right, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new QualifiedNameSyntax(this.Kind, this.left, this.dotToken, this.right, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents the syntax node for generic name.</summary>
	public sealed partial class GenericNameSyntax : SimpleNameSyntax
	{
		public readonly SyntaxToken identifier;
		public readonly TypeArgumentListSyntax typeArgumentList;

		public GenericNameSyntax(SyntaxKind kind, SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			this.AdjustFlagsAndWidth(typeArgumentList);
			this.typeArgumentList = typeArgumentList;
		}


		public GenericNameSyntax(SyntaxKind kind, SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			this.AdjustFlagsAndWidth(typeArgumentList);
			this.typeArgumentList = typeArgumentList;
		}


		public GenericNameSyntax(SyntaxKind kind, SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList)
			: base(kind)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			this.AdjustFlagsAndWidth(typeArgumentList);
			this.typeArgumentList = typeArgumentList;
		}

		/// <summary>SyntaxToken representing the name of the identifier of the generic name.</summary>
		public override SyntaxToken Identifier { get { return this.identifier; } }
		/// <summary>TypeArgumentListSyntax node representing the list of type arguments of the generic name.</summary>
		public TypeArgumentListSyntax TypeArgumentList { get { return this.typeArgumentList; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.identifier;
				case 1: return this.typeArgumentList;
				default: return null;
			}
		}
		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitGenericName(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitGenericName(this);
		}


		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new GenericNameSyntax(this.Kind, this.identifier, this.typeArgumentList, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new GenericNameSyntax(this.Kind, this.identifier, this.typeArgumentList, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents the syntax node for type argument list.</summary>
	public sealed partial class TypeArgumentListSyntax : LeeSyntaxNode
	{
		public readonly SyntaxToken lessThanToken;
		public readonly GreenNode arguments;
		public readonly SyntaxToken greaterThanToken;

		public TypeArgumentListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, GreenNode arguments, SyntaxToken greaterThanToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(lessThanToken);
			this.lessThanToken = lessThanToken;
			if (arguments != null)
			{
				this.AdjustFlagsAndWidth(arguments);
				this.arguments = arguments;
			}
			this.AdjustFlagsAndWidth(greaterThanToken);
			this.greaterThanToken = greaterThanToken;
		}


		public TypeArgumentListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, GreenNode arguments, SyntaxToken greaterThanToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(lessThanToken);
			this.lessThanToken = lessThanToken;
			if (arguments != null)
			{
				this.AdjustFlagsAndWidth(arguments);
				this.arguments = arguments;
			}
			this.AdjustFlagsAndWidth(greaterThanToken);
			this.greaterThanToken = greaterThanToken;
		}


		public TypeArgumentListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, GreenNode arguments, SyntaxToken greaterThanToken)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(lessThanToken);
			this.lessThanToken = lessThanToken;
			if (arguments != null)
			{
				this.AdjustFlagsAndWidth(arguments);
				this.arguments = arguments;
			}
			this.AdjustFlagsAndWidth(greaterThanToken);
			this.greaterThanToken = greaterThanToken;
		}

		/// <summary>SyntaxToken representing less than.</summary>
		public SyntaxToken LessThanToken { get { return this.lessThanToken; } }
		/// <summary>SeparatedSyntaxList of TypeSyntax node representing the type arguments.</summary>
		public SeparatedSyntaxList<TypeSyntax> Arguments { get { return new SeparatedSyntaxList<TypeSyntax>(new SyntaxList<LeeSyntaxNode>(this.arguments)); } }
		/// <summary>SyntaxToken representing greater than.</summary>
		public SyntaxToken GreaterThanToken { get { return this.greaterThanToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.lessThanToken;
				case 1: return this.arguments;
				case 2: return this.greaterThanToken;
				default: return null;
			}
		}
		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitTypeArgumentList(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitTypeArgumentList(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new TypeArgumentListSyntax(this.Kind, this.lessThanToken, this.arguments, this.greaterThanToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new TypeArgumentListSyntax(this.Kind, this.lessThanToken, this.arguments, this.greaterThanToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents the syntax node for alias qualified name.</summary>
	public sealed partial class AliasQualifiedNameSyntax : NameSyntax
	{
		public readonly IdentifierNameSyntax alias;
		public readonly SyntaxToken colonColonToken;
		public readonly SimpleNameSyntax name;

		public AliasQualifiedNameSyntax(SyntaxKind kind, IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(alias);
			this.alias = alias;
			this.AdjustFlagsAndWidth(colonColonToken);
			this.colonColonToken = colonColonToken;
			this.AdjustFlagsAndWidth(name);
			this.name = name;
		}


		public AliasQualifiedNameSyntax(SyntaxKind kind, IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(alias);
			this.alias = alias;
			this.AdjustFlagsAndWidth(colonColonToken);
			this.colonColonToken = colonColonToken;
			this.AdjustFlagsAndWidth(name);
			this.name = name;
		}


		public AliasQualifiedNameSyntax(SyntaxKind kind, IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(alias);
			this.alias = alias;
			this.AdjustFlagsAndWidth(colonColonToken);
			this.colonColonToken = colonColonToken;
			this.AdjustFlagsAndWidth(name);
			this.name = name;
		}

		/// <summary>IdentifierNameSyntax node representing the name of the alias</summary>
		public IdentifierNameSyntax Alias { get { return this.alias; } }
		/// <summary>SyntaxToken representing colon colon.</summary>
		public SyntaxToken ColonColonToken { get { return this.colonColonToken; } }
		/// <summary>SimpleNameSyntax node representing the name that is being alias qualified.</summary>
		public SimpleNameSyntax Name { get { return this.name; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.alias;
				case 1: return this.colonColonToken;
				case 2: return this.name;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitAliasQualifiedName(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitAliasQualifiedName(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new AliasQualifiedNameSyntax(this.Kind, this.alias, this.colonColonToken, this.name, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new AliasQualifiedNameSyntax(this.Kind, this.alias, this.colonColonToken, this.name, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Provides the base class from which the classes that represent type syntax nodes are derived. This is an abstract class.</summary>
	public abstract partial class TypeSyntax : ExpressionSyntax
	{
		public TypeSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
		  : base(kind, diagnostics, annotations)
		{
		}
		public TypeSyntax(SyntaxKind kind)
		  : base(kind)
		{
		}
	}

	/// <summary>Class which represents the syntax node for predefined types.</summary>
	public sealed partial class PredefinedTypeSyntax : TypeSyntax
	{
		public readonly SyntaxToken keyword;

		public PredefinedTypeSyntax(SyntaxKind kind, SyntaxToken keyword, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
		}


		public PredefinedTypeSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
		}


		public PredefinedTypeSyntax(SyntaxKind kind, SyntaxToken keyword)
			: base(kind)
		{
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
		}

		/// <summary>SyntaxToken which represents the keyword corresponding to the predefined type.</summary>
		public SyntaxToken Keyword { get { return this.keyword; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.keyword;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitPredefinedType(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitPredefinedType(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new PredefinedTypeSyntax(this.Kind, this.keyword, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new PredefinedTypeSyntax(this.Kind, this.keyword, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents the syntax node for the array type.</summary>
	public sealed partial class ArrayTypeSyntax : TypeSyntax
	{
		public readonly TypeSyntax elementType;
		public readonly GreenNode rankSpecifiers;

		public ArrayTypeSyntax(SyntaxKind kind, TypeSyntax elementType, GreenNode rankSpecifiers, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(elementType);
			this.elementType = elementType;
			if (rankSpecifiers != null)
			{
				this.AdjustFlagsAndWidth(rankSpecifiers);
				this.rankSpecifiers = rankSpecifiers;
			}
		}


		public ArrayTypeSyntax(SyntaxKind kind, TypeSyntax elementType, GreenNode rankSpecifiers, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(elementType);
			this.elementType = elementType;
			if (rankSpecifiers != null)
			{
				this.AdjustFlagsAndWidth(rankSpecifiers);
				this.rankSpecifiers = rankSpecifiers;
			}
		}


		public ArrayTypeSyntax(SyntaxKind kind, TypeSyntax elementType, GreenNode rankSpecifiers)
			: base(kind)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(elementType);
			this.elementType = elementType;
			if (rankSpecifiers != null)
			{
				this.AdjustFlagsAndWidth(rankSpecifiers);
				this.rankSpecifiers = rankSpecifiers;
			}
		}

		/// <summary>TypeSyntax node representing the type of the element of the array.</summary>
		public TypeSyntax ElementType { get { return this.elementType; } }
		/// <summary>SyntaxList of ArrayRankSpecifierSyntax nodes representing the list of rank specifiers for the array.</summary>
		public SyntaxList<ArrayRankSpecifierSyntax> RankSpecifiers { get { return new SyntaxList<ArrayRankSpecifierSyntax>(this.rankSpecifiers); } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.elementType;
				case 1: return this.rankSpecifiers;
				default: return null;
			}
		}
		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitArrayType(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitArrayType(this);
		}


		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new ArrayTypeSyntax(this.Kind, this.elementType, this.rankSpecifiers, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new ArrayTypeSyntax(this.Kind, this.elementType, this.rankSpecifiers, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class ArrayRankSpecifierSyntax : LeeSyntaxNode
	{
		public readonly SyntaxToken openBracketToken;
		public readonly GreenNode sizes;
		public readonly SyntaxToken closeBracketToken;

		public ArrayRankSpecifierSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode sizes, SyntaxToken closeBracketToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openBracketToken);
			this.openBracketToken = openBracketToken;
			if (sizes != null)
			{
				this.AdjustFlagsAndWidth(sizes);
				this.sizes = sizes;
			}
			this.AdjustFlagsAndWidth(closeBracketToken);
			this.closeBracketToken = closeBracketToken;
		}


		public ArrayRankSpecifierSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode sizes, SyntaxToken closeBracketToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openBracketToken);
			this.openBracketToken = openBracketToken;
			if (sizes != null)
			{
				this.AdjustFlagsAndWidth(sizes);
				this.sizes = sizes;
			}
			this.AdjustFlagsAndWidth(closeBracketToken);
			this.closeBracketToken = closeBracketToken;
		}


		public ArrayRankSpecifierSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode sizes, SyntaxToken closeBracketToken)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openBracketToken);
			this.openBracketToken = openBracketToken;
			if (sizes != null)
			{
				this.AdjustFlagsAndWidth(sizes);
				this.sizes = sizes;
			}
			this.AdjustFlagsAndWidth(closeBracketToken);
			this.closeBracketToken = closeBracketToken;
		}

		public SyntaxToken OpenBracketToken { get { return this.openBracketToken; } }
		public SeparatedSyntaxList<ExpressionSyntax> Sizes { get { return new SeparatedSyntaxList<ExpressionSyntax>(new SyntaxList<LeeSyntaxNode>(this.sizes)); } }
		public SyntaxToken CloseBracketToken { get { return this.closeBracketToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.openBracketToken;
				case 1: return this.sizes;
				case 2: return this.closeBracketToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitArrayRankSpecifier(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitArrayRankSpecifier(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new ArrayRankSpecifierSyntax(this.Kind, this.openBracketToken, this.sizes, this.closeBracketToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new ArrayRankSpecifierSyntax(this.Kind, this.openBracketToken, this.sizes, this.closeBracketToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents the syntax node for pointer type.</summary>
	public sealed partial class PointerTypeSyntax : TypeSyntax
	{
		public readonly TypeSyntax elementType;
		public readonly SyntaxToken asteriskToken;

		public PointerTypeSyntax(SyntaxKind kind, TypeSyntax elementType, SyntaxToken asteriskToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(elementType);
			this.elementType = elementType;
			this.AdjustFlagsAndWidth(asteriskToken);
			this.asteriskToken = asteriskToken;
		}


		public PointerTypeSyntax(SyntaxKind kind, TypeSyntax elementType, SyntaxToken asteriskToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(elementType);
			this.elementType = elementType;
			this.AdjustFlagsAndWidth(asteriskToken);
			this.asteriskToken = asteriskToken;
		}


		public PointerTypeSyntax(SyntaxKind kind, TypeSyntax elementType, SyntaxToken asteriskToken)
			: base(kind)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(elementType);
			this.elementType = elementType;
			this.AdjustFlagsAndWidth(asteriskToken);
			this.asteriskToken = asteriskToken;
		}

		/// <summary>TypeSyntax node that represents the element type of the pointer.</summary>
		public TypeSyntax ElementType { get { return this.elementType; } }
		/// <summary>SyntaxToken representing the asterisk.</summary>
		public SyntaxToken AsteriskToken { get { return this.asteriskToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.elementType;
				case 1: return this.asteriskToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitPointerType(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitPointerType(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new PointerTypeSyntax(this.Kind, this.elementType, this.asteriskToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new PointerTypeSyntax(this.Kind, this.elementType, this.asteriskToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents the syntax node for a nullable type.</summary>
	public sealed partial class NullableTypeSyntax : TypeSyntax
	{
		public readonly TypeSyntax elementType;
		public readonly SyntaxToken questionToken;

		public NullableTypeSyntax(SyntaxKind kind, TypeSyntax elementType, SyntaxToken questionToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(elementType);
			this.elementType = elementType;
			this.AdjustFlagsAndWidth(questionToken);
			this.questionToken = questionToken;
		}


		public NullableTypeSyntax(SyntaxKind kind, TypeSyntax elementType, SyntaxToken questionToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(elementType);
			this.elementType = elementType;
			this.AdjustFlagsAndWidth(questionToken);
			this.questionToken = questionToken;
		}


		public NullableTypeSyntax(SyntaxKind kind, TypeSyntax elementType, SyntaxToken questionToken)
			: base(kind)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(elementType);
			this.elementType = elementType;
			this.AdjustFlagsAndWidth(questionToken);
			this.questionToken = questionToken;
		}

		/// <summary>TypeSyntax node representing the type of the element.</summary>
		public TypeSyntax ElementType { get { return this.elementType; } }
		/// <summary>SyntaxToken representing the question mark.</summary>
		public SyntaxToken QuestionToken { get { return this.questionToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.elementType;
				case 1: return this.questionToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitNullableType(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitNullableType(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new NullableTypeSyntax(this.Kind, this.elementType, this.questionToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new NullableTypeSyntax(this.Kind, this.elementType, this.questionToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents the syntax node for tuple type.</summary>
	public sealed partial class TupleTypeSyntax : TypeSyntax
	{
		public readonly SyntaxToken openParenToken;
		public readonly GreenNode elements;
		public readonly SyntaxToken closeParenToken;

		public TupleTypeSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode elements, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			if (elements != null)
			{
				this.AdjustFlagsAndWidth(elements);
				this.elements = elements;
			}
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}


		public TupleTypeSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode elements, SyntaxToken closeParenToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			if (elements != null)
			{
				this.AdjustFlagsAndWidth(elements);
				this.elements = elements;
			}
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}


		public TupleTypeSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode elements, SyntaxToken closeParenToken)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			if (elements != null)
			{
				this.AdjustFlagsAndWidth(elements);
				this.elements = elements;
			}
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}

		/// <summary>SyntaxToken representing the open parenthesis.</summary>
		public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
		public SeparatedSyntaxList<TupleElementSyntax> Elements { get { return new SeparatedSyntaxList<TupleElementSyntax>(new SyntaxList<LeeSyntaxNode>(this.elements)); } }
		/// <summary>SyntaxToken representing the close parenthesis.</summary>
		public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.openParenToken;
				case 1: return this.elements;
				case 2: return this.closeParenToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitTupleType(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitTupleType(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new TupleTypeSyntax(this.Kind, this.openParenToken, this.elements, this.closeParenToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new TupleTypeSyntax(this.Kind, this.openParenToken, this.elements, this.closeParenToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Tuple type element.</summary>
	public sealed partial class TupleElementSyntax : LeeSyntaxNode
	{
		public readonly TypeSyntax type;
		public readonly SyntaxToken identifier;

		public TupleElementSyntax(SyntaxKind kind, TypeSyntax type, SyntaxToken identifier, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			if (identifier != null)
			{
				this.AdjustFlagsAndWidth(identifier);
				this.identifier = identifier;
			}
		}


		public TupleElementSyntax(SyntaxKind kind, TypeSyntax type, SyntaxToken identifier, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			if (identifier != null)
			{
				this.AdjustFlagsAndWidth(identifier);
				this.identifier = identifier;
			}
		}


		public TupleElementSyntax(SyntaxKind kind, TypeSyntax type, SyntaxToken identifier)
			: base(kind)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			if (identifier != null)
			{
				this.AdjustFlagsAndWidth(identifier);
				this.identifier = identifier;
			}
		}

		/// <summary>Gets the type of the tuple element.</summary>
		public TypeSyntax Type { get { return this.type; } }
		/// <summary>Gets the name of the tuple element.</summary>
		public SyntaxToken Identifier { get { return this.identifier; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.type;
				case 1: return this.identifier;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitTupleElement(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitTupleElement(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new TupleElementSyntax(this.Kind, this.type, this.identifier, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new TupleElementSyntax(this.Kind, this.type, this.identifier, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents a placeholder in the type argument list of an unbound generic type.</summary>
	public sealed partial class OmittedTypeArgumentSyntax : TypeSyntax
	{
		public readonly SyntaxToken omittedTypeArgumentToken;

		public OmittedTypeArgumentSyntax(SyntaxKind kind, SyntaxToken omittedTypeArgumentToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(omittedTypeArgumentToken);
			this.omittedTypeArgumentToken = omittedTypeArgumentToken;
		}


		public OmittedTypeArgumentSyntax(SyntaxKind kind, SyntaxToken omittedTypeArgumentToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(omittedTypeArgumentToken);
			this.omittedTypeArgumentToken = omittedTypeArgumentToken;
		}


		public OmittedTypeArgumentSyntax(SyntaxKind kind, SyntaxToken omittedTypeArgumentToken)
			: base(kind)
		{
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(omittedTypeArgumentToken);
			this.omittedTypeArgumentToken = omittedTypeArgumentToken;
		}

		/// <summary>SyntaxToken representing the omitted type argument.</summary>
		public SyntaxToken OmittedTypeArgumentToken { get { return this.omittedTypeArgumentToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.omittedTypeArgumentToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitOmittedTypeArgument(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitOmittedTypeArgument(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new OmittedTypeArgumentSyntax(this.Kind, this.omittedTypeArgumentToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new OmittedTypeArgumentSyntax(this.Kind, this.omittedTypeArgumentToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>The ref modifier of a method's return value or a local.</summary>
	public sealed partial class RefTypeSyntax : TypeSyntax
	{
		public readonly SyntaxToken refKeyword;
		public readonly SyntaxToken readOnlyKeyword;
		public readonly TypeSyntax type;

		public RefTypeSyntax(SyntaxKind kind, SyntaxToken refKeyword, SyntaxToken readOnlyKeyword, TypeSyntax type, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(refKeyword);
			this.refKeyword = refKeyword;
			if (readOnlyKeyword != null)
			{
				this.AdjustFlagsAndWidth(readOnlyKeyword);
				this.readOnlyKeyword = readOnlyKeyword;
			}
			this.AdjustFlagsAndWidth(type);
			this.type = type;
		}


		public RefTypeSyntax(SyntaxKind kind, SyntaxToken refKeyword, SyntaxToken readOnlyKeyword, TypeSyntax type, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(refKeyword);
			this.refKeyword = refKeyword;
			if (readOnlyKeyword != null)
			{
				this.AdjustFlagsAndWidth(readOnlyKeyword);
				this.readOnlyKeyword = readOnlyKeyword;
			}
			this.AdjustFlagsAndWidth(type);
			this.type = type;
		}


		public RefTypeSyntax(SyntaxKind kind, SyntaxToken refKeyword, SyntaxToken readOnlyKeyword, TypeSyntax type)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(refKeyword);
			this.refKeyword = refKeyword;
			if (readOnlyKeyword != null)
			{
				this.AdjustFlagsAndWidth(readOnlyKeyword);
				this.readOnlyKeyword = readOnlyKeyword;
			}
			this.AdjustFlagsAndWidth(type);
			this.type = type;
		}

		public SyntaxToken RefKeyword { get { return this.refKeyword; } }
		/// <summary>Gets the optional "readonly" keyword.</summary>
		public SyntaxToken ReadOnlyKeyword { get { return this.readOnlyKeyword; } }
		public TypeSyntax Type { get { return this.type; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.refKeyword;
				case 1: return this.readOnlyKeyword;
				case 2: return this.type;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitRefType(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitRefType(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new RefTypeSyntax(this.Kind, this.refKeyword, this.readOnlyKeyword, this.type, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new RefTypeSyntax(this.Kind, this.refKeyword, this.readOnlyKeyword, this.type, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Provides the base class from which the classes that represent expression syntax nodes are derived. This is an abstract class.</summary>
	public abstract partial class ExpressionSyntax : LeeSyntaxNode
	{
		public ExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
		  : base(kind, diagnostics, annotations)
		{
		}
		public ExpressionSyntax(SyntaxKind kind)
		  : base(kind)
		{
		}
	}

	/// <summary>Class which represents the syntax node for parenthesized expression.</summary>
	public sealed partial class ParenthesizedExpressionSyntax : ExpressionSyntax
	{
		public readonly SyntaxToken openParenToken;
		public readonly ExpressionSyntax expression;
		public readonly SyntaxToken closeParenToken;

		public ParenthesizedExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}


		public ParenthesizedExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}


		public ParenthesizedExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}

		/// <summary>SyntaxToken representing the open parenthesis.</summary>
		public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
		/// <summary>ExpressionSyntax node representing the expression enclosed within the parenthesis.</summary>
		public ExpressionSyntax Expression { get { return this.expression; } }
		/// <summary>SyntaxToken representing the close parenthesis.</summary>
		public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.openParenToken;
				case 1: return this.expression;
				case 2: return this.closeParenToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitParenthesizedExpression(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitParenthesizedExpression(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new ParenthesizedExpressionSyntax(this.Kind, this.openParenToken, this.expression, this.closeParenToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new ParenthesizedExpressionSyntax(this.Kind, this.openParenToken, this.expression, this.closeParenToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents the syntax node for tuple expression.</summary>
	public sealed partial class TupleExpressionSyntax : ExpressionSyntax
	{
		public readonly SyntaxToken openParenToken;
		public readonly GreenNode arguments;
		public readonly SyntaxToken closeParenToken;

		public TupleExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode arguments, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			if (arguments != null)
			{
				this.AdjustFlagsAndWidth(arguments);
				this.arguments = arguments;
			}
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}


		public TupleExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode arguments, SyntaxToken closeParenToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			if (arguments != null)
			{
				this.AdjustFlagsAndWidth(arguments);
				this.arguments = arguments;
			}
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}


		public TupleExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode arguments, SyntaxToken closeParenToken)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			if (arguments != null)
			{
				this.AdjustFlagsAndWidth(arguments);
				this.arguments = arguments;
			}
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}

		/// <summary>SyntaxToken representing the open parenthesis.</summary>
		public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
		/// <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
		public SeparatedSyntaxList<ArgumentSyntax> Arguments { get { return new SeparatedSyntaxList<ArgumentSyntax>(new SyntaxList<LeeSyntaxNode>(this.arguments)); } }
		/// <summary>SyntaxToken representing the close parenthesis.</summary>
		public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.openParenToken;
				case 1: return this.arguments;
				case 2: return this.closeParenToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitTupleExpression(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitTupleExpression(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new TupleExpressionSyntax(this.Kind, this.openParenToken, this.arguments, this.closeParenToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new TupleExpressionSyntax(this.Kind, this.openParenToken, this.arguments, this.closeParenToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents the syntax node for prefix unary expression.</summary>
	public sealed partial class PrefixUnaryExpressionSyntax : ExpressionSyntax
	{
		public readonly SyntaxToken operatorToken;
		public readonly ExpressionSyntax operand;

		public PrefixUnaryExpressionSyntax(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(operatorToken);
			this.operatorToken = operatorToken;
			this.AdjustFlagsAndWidth(operand);
			this.operand = operand;
		}


		public PrefixUnaryExpressionSyntax(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(operatorToken);
			this.operatorToken = operatorToken;
			this.AdjustFlagsAndWidth(operand);
			this.operand = operand;
		}


		public PrefixUnaryExpressionSyntax(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand)
			: base(kind)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(operatorToken);
			this.operatorToken = operatorToken;
			this.AdjustFlagsAndWidth(operand);
			this.operand = operand;
		}

		/// <summary>SyntaxToken representing the kind of the operator of the prefix unary expression.</summary>
		public SyntaxToken OperatorToken { get { return this.operatorToken; } }
		/// <summary>ExpressionSyntax representing the operand of the prefix unary expression.</summary>
		public ExpressionSyntax Operand { get { return this.operand; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.operatorToken;
				case 1: return this.operand;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitPrefixUnaryExpression(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitPrefixUnaryExpression(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new PrefixUnaryExpressionSyntax(this.Kind, this.operatorToken, this.operand, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new PrefixUnaryExpressionSyntax(this.Kind, this.operatorToken, this.operand, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents the syntax node for an "await" expression.</summary>
	public sealed partial class AwaitExpressionSyntax : ExpressionSyntax
	{
		public readonly SyntaxToken awaitKeyword;
		public readonly ExpressionSyntax expression;

		public AwaitExpressionSyntax(SyntaxKind kind, SyntaxToken awaitKeyword, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(awaitKeyword);
			this.awaitKeyword = awaitKeyword;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
		}


		public AwaitExpressionSyntax(SyntaxKind kind, SyntaxToken awaitKeyword, ExpressionSyntax expression, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(awaitKeyword);
			this.awaitKeyword = awaitKeyword;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
		}


		public AwaitExpressionSyntax(SyntaxKind kind, SyntaxToken awaitKeyword, ExpressionSyntax expression)
			: base(kind)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(awaitKeyword);
			this.awaitKeyword = awaitKeyword;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
		}

		/// <summary>SyntaxToken representing the kind "await" keyword.</summary>
		public SyntaxToken AwaitKeyword { get { return this.awaitKeyword; } }
		/// <summary>ExpressionSyntax representing the operand of the "await" operator.</summary>
		public ExpressionSyntax Expression { get { return this.expression; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.awaitKeyword;
				case 1: return this.expression;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitAwaitExpression(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitAwaitExpression(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new AwaitExpressionSyntax(this.Kind, this.awaitKeyword, this.expression, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new AwaitExpressionSyntax(this.Kind, this.awaitKeyword, this.expression, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents the syntax node for postfix unary expression.</summary>
	public sealed partial class PostfixUnaryExpressionSyntax : ExpressionSyntax
	{
		public readonly ExpressionSyntax operand;
		public readonly SyntaxToken operatorToken;

		public PostfixUnaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax operand, SyntaxToken operatorToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(operand);
			this.operand = operand;
			this.AdjustFlagsAndWidth(operatorToken);
			this.operatorToken = operatorToken;
		}


		public PostfixUnaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax operand, SyntaxToken operatorToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(operand);
			this.operand = operand;
			this.AdjustFlagsAndWidth(operatorToken);
			this.operatorToken = operatorToken;
		}


		public PostfixUnaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax operand, SyntaxToken operatorToken)
			: base(kind)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(operand);
			this.operand = operand;
			this.AdjustFlagsAndWidth(operatorToken);
			this.operatorToken = operatorToken;
		}

		/// <summary>ExpressionSyntax representing the operand of the postfix unary expression.</summary>
		public ExpressionSyntax Operand { get { return this.operand; } }
		/// <summary>SyntaxToken representing the kind of the operator of the postfix unary expression.</summary>
		public SyntaxToken OperatorToken { get { return this.operatorToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.operand;
				case 1: return this.operatorToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitPostfixUnaryExpression(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitPostfixUnaryExpression(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new PostfixUnaryExpressionSyntax(this.Kind, this.operand, this.operatorToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new PostfixUnaryExpressionSyntax(this.Kind, this.operand, this.operatorToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents the syntax node for member access expression.</summary>
	public sealed partial class MemberAccessExpressionSyntax : ExpressionSyntax
	{
		public readonly ExpressionSyntax expression;
		public readonly SyntaxToken operatorToken;
		public readonly SimpleNameSyntax name;

		public MemberAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			this.AdjustFlagsAndWidth(operatorToken);
			this.operatorToken = operatorToken;
			this.AdjustFlagsAndWidth(name);
			this.name = name;
		}


		public MemberAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			this.AdjustFlagsAndWidth(operatorToken);
			this.operatorToken = operatorToken;
			this.AdjustFlagsAndWidth(name);
			this.name = name;
		}


		public MemberAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			this.AdjustFlagsAndWidth(operatorToken);
			this.operatorToken = operatorToken;
			this.AdjustFlagsAndWidth(name);
			this.name = name;
		}

		/// <summary>ExpressionSyntax node representing the object that the member belongs to.</summary>
		public ExpressionSyntax Expression { get { return this.expression; } }
		/// <summary>SyntaxToken representing the kind of the operator in the member access expression.</summary>
		public SyntaxToken OperatorToken { get { return this.operatorToken; } }
		/// <summary>SimpleNameSyntax node representing the member being accessed.</summary>
		public SimpleNameSyntax Name { get { return this.name; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.expression;
				case 1: return this.operatorToken;
				case 2: return this.name;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitMemberAccessExpression(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitMemberAccessExpression(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new MemberAccessExpressionSyntax(this.Kind, this.expression, this.operatorToken, this.name, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new MemberAccessExpressionSyntax(this.Kind, this.expression, this.operatorToken, this.name, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents the syntax node for conditional access expression.</summary>
	public sealed partial class ConditionalAccessExpressionSyntax : ExpressionSyntax
	{
		public readonly ExpressionSyntax expression;
		public readonly SyntaxToken operatorToken;
		public readonly ExpressionSyntax whenNotNull;

		public ConditionalAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			this.AdjustFlagsAndWidth(operatorToken);
			this.operatorToken = operatorToken;
			this.AdjustFlagsAndWidth(whenNotNull);
			this.whenNotNull = whenNotNull;
		}


		public ConditionalAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			this.AdjustFlagsAndWidth(operatorToken);
			this.operatorToken = operatorToken;
			this.AdjustFlagsAndWidth(whenNotNull);
			this.whenNotNull = whenNotNull;
		}


		public ConditionalAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			this.AdjustFlagsAndWidth(operatorToken);
			this.operatorToken = operatorToken;
			this.AdjustFlagsAndWidth(whenNotNull);
			this.whenNotNull = whenNotNull;
		}

		/// <summary>ExpressionSyntax node representing the object conditionally accessed.</summary>
		public ExpressionSyntax Expression { get { return this.expression; } }
		/// <summary>SyntaxToken representing the question mark.</summary>
		public SyntaxToken OperatorToken { get { return this.operatorToken; } }
		/// <summary>ExpressionSyntax node representing the access expression to be executed when the object is not null.</summary>
		public ExpressionSyntax WhenNotNull { get { return this.whenNotNull; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.expression;
				case 1: return this.operatorToken;
				case 2: return this.whenNotNull;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitConditionalAccessExpression(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitConditionalAccessExpression(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new ConditionalAccessExpressionSyntax(this.Kind, this.expression, this.operatorToken, this.whenNotNull, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new ConditionalAccessExpressionSyntax(this.Kind, this.expression, this.operatorToken, this.whenNotNull, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents the syntax node for member binding expression.</summary>
	public sealed partial class MemberBindingExpressionSyntax : ExpressionSyntax
	{
		public readonly SyntaxToken operatorToken;
		public readonly SimpleNameSyntax name;

		public MemberBindingExpressionSyntax(SyntaxKind kind, SyntaxToken operatorToken, SimpleNameSyntax name, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(operatorToken);
			this.operatorToken = operatorToken;
			this.AdjustFlagsAndWidth(name);
			this.name = name;
		}


		public MemberBindingExpressionSyntax(SyntaxKind kind, SyntaxToken operatorToken, SimpleNameSyntax name, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(operatorToken);
			this.operatorToken = operatorToken;
			this.AdjustFlagsAndWidth(name);
			this.name = name;
		}


		public MemberBindingExpressionSyntax(SyntaxKind kind, SyntaxToken operatorToken, SimpleNameSyntax name)
			: base(kind)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(operatorToken);
			this.operatorToken = operatorToken;
			this.AdjustFlagsAndWidth(name);
			this.name = name;
		}

		/// <summary>SyntaxToken representing dot.</summary>
		public SyntaxToken OperatorToken { get { return this.operatorToken; } }
		/// <summary>SimpleNameSyntax node representing the member being bound to.</summary>
		public SimpleNameSyntax Name { get { return this.name; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.operatorToken;
				case 1: return this.name;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitMemberBindingExpression(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitMemberBindingExpression(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new MemberBindingExpressionSyntax(this.Kind, this.operatorToken, this.name, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new MemberBindingExpressionSyntax(this.Kind, this.operatorToken, this.name, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents the syntax node for element binding expression.</summary>
	public sealed partial class ElementBindingExpressionSyntax : ExpressionSyntax
	{
		public readonly BracketedArgumentListSyntax argumentList;

		public ElementBindingExpressionSyntax(SyntaxKind kind, BracketedArgumentListSyntax argumentList, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(argumentList);
			this.argumentList = argumentList;
		}


		public ElementBindingExpressionSyntax(SyntaxKind kind, BracketedArgumentListSyntax argumentList, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(argumentList);
			this.argumentList = argumentList;
		}


		public ElementBindingExpressionSyntax(SyntaxKind kind, BracketedArgumentListSyntax argumentList)
			: base(kind)
		{
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(argumentList);
			this.argumentList = argumentList;
		}

		/// <summary>BracketedArgumentListSyntax node representing the list of arguments of the element binding expression.</summary>
		public BracketedArgumentListSyntax ArgumentList { get { return this.argumentList; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.argumentList;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitElementBindingExpression(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitElementBindingExpression(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new ElementBindingExpressionSyntax(this.Kind, this.argumentList, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new ElementBindingExpressionSyntax(this.Kind, this.argumentList, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents the syntax node for a range expression.</summary>
	public sealed partial class RangeExpressionSyntax : ExpressionSyntax
	{
		public readonly ExpressionSyntax leftOperand;
		public readonly SyntaxToken operatorToken;
		public readonly ExpressionSyntax rightOperand;

		public RangeExpressionSyntax(SyntaxKind kind, ExpressionSyntax leftOperand, SyntaxToken operatorToken, ExpressionSyntax rightOperand, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			if (leftOperand != null)
			{
				this.AdjustFlagsAndWidth(leftOperand);
				this.leftOperand = leftOperand;
			}
			this.AdjustFlagsAndWidth(operatorToken);
			this.operatorToken = operatorToken;
			if (rightOperand != null)
			{
				this.AdjustFlagsAndWidth(rightOperand);
				this.rightOperand = rightOperand;
			}
		}


		public RangeExpressionSyntax(SyntaxKind kind, ExpressionSyntax leftOperand, SyntaxToken operatorToken, ExpressionSyntax rightOperand, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			if (leftOperand != null)
			{
				this.AdjustFlagsAndWidth(leftOperand);
				this.leftOperand = leftOperand;
			}
			this.AdjustFlagsAndWidth(operatorToken);
			this.operatorToken = operatorToken;
			if (rightOperand != null)
			{
				this.AdjustFlagsAndWidth(rightOperand);
				this.rightOperand = rightOperand;
			}
		}


		public RangeExpressionSyntax(SyntaxKind kind, ExpressionSyntax leftOperand, SyntaxToken operatorToken, ExpressionSyntax rightOperand)
			: base(kind)
		{
			this.SlotCount = 3;
			if (leftOperand != null)
			{
				this.AdjustFlagsAndWidth(leftOperand);
				this.leftOperand = leftOperand;
			}
			this.AdjustFlagsAndWidth(operatorToken);
			this.operatorToken = operatorToken;
			if (rightOperand != null)
			{
				this.AdjustFlagsAndWidth(rightOperand);
				this.rightOperand = rightOperand;
			}
		}

		/// <summary>ExpressionSyntax node representing the expression on the left of the range operator.</summary>
		public ExpressionSyntax LeftOperand { get { return this.leftOperand; } }
		/// <summary>SyntaxToken representing the operator of the range expression.</summary>
		public SyntaxToken OperatorToken { get { return this.operatorToken; } }
		/// <summary>ExpressionSyntax node representing the expression on the right of the range operator.</summary>
		public ExpressionSyntax RightOperand { get { return this.rightOperand; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.leftOperand;
				case 1: return this.operatorToken;
				case 2: return this.rightOperand;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitRangeExpression(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitRangeExpression(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new RangeExpressionSyntax(this.Kind, this.leftOperand, this.operatorToken, this.rightOperand, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new RangeExpressionSyntax(this.Kind, this.leftOperand, this.operatorToken, this.rightOperand, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents the syntax node for implicit element access expression.</summary>
	public sealed partial class ImplicitElementAccessSyntax : ExpressionSyntax
	{
		public readonly BracketedArgumentListSyntax argumentList;

		public ImplicitElementAccessSyntax(SyntaxKind kind, BracketedArgumentListSyntax argumentList, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(argumentList);
			this.argumentList = argumentList;
		}


		public ImplicitElementAccessSyntax(SyntaxKind kind, BracketedArgumentListSyntax argumentList, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(argumentList);
			this.argumentList = argumentList;
		}


		public ImplicitElementAccessSyntax(SyntaxKind kind, BracketedArgumentListSyntax argumentList)
			: base(kind)
		{
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(argumentList);
			this.argumentList = argumentList;
		}

		/// <summary>BracketedArgumentListSyntax node representing the list of arguments of the implicit element access expression.</summary>
		public BracketedArgumentListSyntax ArgumentList { get { return this.argumentList; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.argumentList;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitImplicitElementAccess(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitImplicitElementAccess(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new ImplicitElementAccessSyntax(this.Kind, this.argumentList, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new ImplicitElementAccessSyntax(this.Kind, this.argumentList, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents an expression that has a binary operator.</summary>
	public sealed partial class BinaryExpressionSyntax : ExpressionSyntax
	{
		public readonly ExpressionSyntax left;
		public readonly SyntaxToken operatorToken;
		public readonly ExpressionSyntax right;

		public BinaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(left);
			this.left = left;
			this.AdjustFlagsAndWidth(operatorToken);
			this.operatorToken = operatorToken;
			this.AdjustFlagsAndWidth(right);
			this.right = right;
		}


		public BinaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(left);
			this.left = left;
			this.AdjustFlagsAndWidth(operatorToken);
			this.operatorToken = operatorToken;
			this.AdjustFlagsAndWidth(right);
			this.right = right;
		}


		public BinaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(left);
			this.left = left;
			this.AdjustFlagsAndWidth(operatorToken);
			this.operatorToken = operatorToken;
			this.AdjustFlagsAndWidth(right);
			this.right = right;
		}

		/// <summary>ExpressionSyntax node representing the expression on the left of the binary operator.</summary>
		public ExpressionSyntax Left { get { return this.left; } }
		/// <summary>SyntaxToken representing the operator of the binary expression.</summary>
		public SyntaxToken OperatorToken { get { return this.operatorToken; } }
		/// <summary>ExpressionSyntax node representing the expression on the right of the binary operator.</summary>
		public ExpressionSyntax Right { get { return this.right; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.left;
				case 1: return this.operatorToken;
				case 2: return this.right;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitBinaryExpression(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitBinaryExpression(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new BinaryExpressionSyntax(this.Kind, this.left, this.operatorToken, this.right, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new BinaryExpressionSyntax(this.Kind, this.left, this.operatorToken, this.right, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents an expression that has an assignment operator.</summary>
	public sealed partial class AssignmentExpressionSyntax : ExpressionSyntax
	{
		public readonly ExpressionSyntax left;
		public readonly SyntaxToken operatorToken;
		public readonly ExpressionSyntax right;

		public AssignmentExpressionSyntax(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(left);
			this.left = left;
			this.AdjustFlagsAndWidth(operatorToken);
			this.operatorToken = operatorToken;
			this.AdjustFlagsAndWidth(right);
			this.right = right;
		}


		public AssignmentExpressionSyntax(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(left);
			this.left = left;
			this.AdjustFlagsAndWidth(operatorToken);
			this.operatorToken = operatorToken;
			this.AdjustFlagsAndWidth(right);
			this.right = right;
		}


		public AssignmentExpressionSyntax(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(left);
			this.left = left;
			this.AdjustFlagsAndWidth(operatorToken);
			this.operatorToken = operatorToken;
			this.AdjustFlagsAndWidth(right);
			this.right = right;
		}

		/// <summary>ExpressionSyntax node representing the expression on the left of the assignment operator.</summary>
		public ExpressionSyntax Left { get { return this.left; } }
		/// <summary>SyntaxToken representing the operator of the assignment expression.</summary>
		public SyntaxToken OperatorToken { get { return this.operatorToken; } }
		/// <summary>ExpressionSyntax node representing the expression on the right of the assignment operator.</summary>
		public ExpressionSyntax Right { get { return this.right; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.left;
				case 1: return this.operatorToken;
				case 2: return this.right;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitAssignmentExpression(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitAssignmentExpression(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new AssignmentExpressionSyntax(this.Kind, this.left, this.operatorToken, this.right, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new AssignmentExpressionSyntax(this.Kind, this.left, this.operatorToken, this.right, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents the syntax node for conditional expression.</summary>
	public sealed partial class ConditionalExpressionSyntax : ExpressionSyntax
	{
		public readonly ExpressionSyntax condition;
		public readonly SyntaxToken questionToken;
		public readonly ExpressionSyntax whenTrue;
		public readonly SyntaxToken colonToken;
		public readonly ExpressionSyntax whenFalse;

		public ConditionalExpressionSyntax(SyntaxKind kind, ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 5;
			this.AdjustFlagsAndWidth(condition);
			this.condition = condition;
			this.AdjustFlagsAndWidth(questionToken);
			this.questionToken = questionToken;
			this.AdjustFlagsAndWidth(whenTrue);
			this.whenTrue = whenTrue;
			this.AdjustFlagsAndWidth(colonToken);
			this.colonToken = colonToken;
			this.AdjustFlagsAndWidth(whenFalse);
			this.whenFalse = whenFalse;
		}


		public ConditionalExpressionSyntax(SyntaxKind kind, ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 5;
			this.AdjustFlagsAndWidth(condition);
			this.condition = condition;
			this.AdjustFlagsAndWidth(questionToken);
			this.questionToken = questionToken;
			this.AdjustFlagsAndWidth(whenTrue);
			this.whenTrue = whenTrue;
			this.AdjustFlagsAndWidth(colonToken);
			this.colonToken = colonToken;
			this.AdjustFlagsAndWidth(whenFalse);
			this.whenFalse = whenFalse;
		}


		public ConditionalExpressionSyntax(SyntaxKind kind, ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse)
			: base(kind)
		{
			this.SlotCount = 5;
			this.AdjustFlagsAndWidth(condition);
			this.condition = condition;
			this.AdjustFlagsAndWidth(questionToken);
			this.questionToken = questionToken;
			this.AdjustFlagsAndWidth(whenTrue);
			this.whenTrue = whenTrue;
			this.AdjustFlagsAndWidth(colonToken);
			this.colonToken = colonToken;
			this.AdjustFlagsAndWidth(whenFalse);
			this.whenFalse = whenFalse;
		}

		/// <summary>ExpressionSyntax node representing the condition of the conditional expression.</summary>
		public ExpressionSyntax Condition { get { return this.condition; } }
		/// <summary>SyntaxToken representing the question mark.</summary>
		public SyntaxToken QuestionToken { get { return this.questionToken; } }
		/// <summary>ExpressionSyntax node representing the expression to be executed when the condition is true.</summary>
		public ExpressionSyntax WhenTrue { get { return this.whenTrue; } }
		/// <summary>SyntaxToken representing the colon.</summary>
		public SyntaxToken ColonToken { get { return this.colonToken; } }
		/// <summary>ExpressionSyntax node representing the expression to be executed when the condition is false.</summary>
		public ExpressionSyntax WhenFalse { get { return this.whenFalse; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.condition;
				case 1: return this.questionToken;
				case 2: return this.whenTrue;
				case 3: return this.colonToken;
				case 4: return this.whenFalse;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitConditionalExpression(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitConditionalExpression(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new ConditionalExpressionSyntax(this.Kind, this.condition, this.questionToken, this.whenTrue, this.colonToken, this.whenFalse, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new ConditionalExpressionSyntax(this.Kind, this.condition, this.questionToken, this.whenTrue, this.colonToken, this.whenFalse, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Provides the base class from which the classes that represent instance expression syntax nodes are derived. This is an abstract class.</summary>
	public abstract partial class InstanceExpressionSyntax : ExpressionSyntax
	{
		public InstanceExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
		  : base(kind, diagnostics, annotations)
		{
		}
		public InstanceExpressionSyntax(SyntaxKind kind)
		  : base(kind)
		{
		}
	}

	/// <summary>Class which represents the syntax node for a this expression.</summary>
	public sealed partial class ThisExpressionSyntax : InstanceExpressionSyntax
	{
		public readonly SyntaxToken token;

		public ThisExpressionSyntax(SyntaxKind kind, SyntaxToken token, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(token);
			this.token = token;
		}


		public ThisExpressionSyntax(SyntaxKind kind, SyntaxToken token, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(token);
			this.token = token;
		}


		public ThisExpressionSyntax(SyntaxKind kind, SyntaxToken token)
			: base(kind)
		{
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(token);
			this.token = token;
		}

		/// <summary>SyntaxToken representing the this keyword.</summary>
		public SyntaxToken Token { get { return this.token; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.token;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitThisExpression(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitThisExpression(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new ThisExpressionSyntax(this.Kind, this.token, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new ThisExpressionSyntax(this.Kind, this.token, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents the syntax node for a base expression.</summary>
	public sealed partial class BaseExpressionSyntax : InstanceExpressionSyntax
	{
		public readonly SyntaxToken token;

		public BaseExpressionSyntax(SyntaxKind kind, SyntaxToken token, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(token);
			this.token = token;
		}


		public BaseExpressionSyntax(SyntaxKind kind, SyntaxToken token, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(token);
			this.token = token;
		}


		public BaseExpressionSyntax(SyntaxKind kind, SyntaxToken token)
			: base(kind)
		{
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(token);
			this.token = token;
		}

		/// <summary>SyntaxToken representing the base keyword.</summary>
		public SyntaxToken Token { get { return this.token; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.token;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitBaseExpression(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitBaseExpression(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new BaseExpressionSyntax(this.Kind, this.token, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new BaseExpressionSyntax(this.Kind, this.token, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents the syntax node for a literal expression.</summary>
	public sealed partial class LiteralExpressionSyntax : ExpressionSyntax
	{
		public readonly SyntaxToken token;

		public LiteralExpressionSyntax(SyntaxKind kind, SyntaxToken token, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(token);
			this.token = token;
		}


		public LiteralExpressionSyntax(SyntaxKind kind, SyntaxToken token, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(token);
			this.token = token;
		}


		public LiteralExpressionSyntax(SyntaxKind kind, SyntaxToken token)
			: base(kind)
		{
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(token);
			this.token = token;
		}

		/// <summary>SyntaxToken representing the keyword corresponding to the kind of the literal expression.</summary>
		public SyntaxToken Token { get { return this.token; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.token;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitLiteralExpression(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitLiteralExpression(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new LiteralExpressionSyntax(this.Kind, this.token, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new LiteralExpressionSyntax(this.Kind, this.token, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents the syntax node for MakeRef expression.</summary>
	public sealed partial class MakeRefExpressionSyntax : ExpressionSyntax
	{
		public readonly SyntaxToken keyword;
		public readonly SyntaxToken openParenToken;
		public readonly ExpressionSyntax expression;
		public readonly SyntaxToken closeParenToken;

		public MakeRefExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}


		public MakeRefExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}


		public MakeRefExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
			: base(kind)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}

		/// <summary>SyntaxToken representing the MakeRefKeyword.</summary>
		public SyntaxToken Keyword { get { return this.keyword; } }
		/// <summary>SyntaxToken representing open parenthesis.</summary>
		public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
		/// <summary>Argument of the primary function.</summary>
		public ExpressionSyntax Expression { get { return this.expression; } }
		/// <summary>SyntaxToken representing close parenthesis.</summary>
		public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.keyword;
				case 1: return this.openParenToken;
				case 2: return this.expression;
				case 3: return this.closeParenToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitMakeRefExpression(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitMakeRefExpression(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new MakeRefExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.closeParenToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new MakeRefExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.closeParenToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents the syntax node for RefType expression.</summary>
	public sealed partial class RefTypeExpressionSyntax : ExpressionSyntax
	{
		public readonly SyntaxToken keyword;
		public readonly SyntaxToken openParenToken;
		public readonly ExpressionSyntax expression;
		public readonly SyntaxToken closeParenToken;

		public RefTypeExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}


		public RefTypeExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}


		public RefTypeExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
			: base(kind)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}

		/// <summary>SyntaxToken representing the RefTypeKeyword.</summary>
		public SyntaxToken Keyword { get { return this.keyword; } }
		/// <summary>SyntaxToken representing open parenthesis.</summary>
		public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
		/// <summary>Argument of the primary function.</summary>
		public ExpressionSyntax Expression { get { return this.expression; } }
		/// <summary>SyntaxToken representing close parenthesis.</summary>
		public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.keyword;
				case 1: return this.openParenToken;
				case 2: return this.expression;
				case 3: return this.closeParenToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitRefTypeExpression(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitRefTypeExpression(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new RefTypeExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.closeParenToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new RefTypeExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.closeParenToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents the syntax node for RefValue expression.</summary>
	public sealed partial class RefValueExpressionSyntax : ExpressionSyntax
	{
		public readonly SyntaxToken keyword;
		public readonly SyntaxToken openParenToken;
		public readonly ExpressionSyntax expression;
		public readonly SyntaxToken comma;
		public readonly TypeSyntax type;
		public readonly SyntaxToken closeParenToken;

		public RefValueExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 6;
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			this.AdjustFlagsAndWidth(comma);
			this.comma = comma;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}


		public RefValueExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 6;
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			this.AdjustFlagsAndWidth(comma);
			this.comma = comma;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}


		public RefValueExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken)
			: base(kind)
		{
			this.SlotCount = 6;
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			this.AdjustFlagsAndWidth(comma);
			this.comma = comma;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}

		/// <summary>SyntaxToken representing the RefValueKeyword.</summary>
		public SyntaxToken Keyword { get { return this.keyword; } }
		/// <summary>SyntaxToken representing open parenthesis.</summary>
		public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
		/// <summary>Typed reference expression.</summary>
		public ExpressionSyntax Expression { get { return this.expression; } }
		/// <summary>Comma separating the arguments.</summary>
		public SyntaxToken Comma { get { return this.comma; } }
		/// <summary>The type of the value.</summary>
		public TypeSyntax Type { get { return this.type; } }
		/// <summary>SyntaxToken representing close parenthesis.</summary>
		public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.keyword;
				case 1: return this.openParenToken;
				case 2: return this.expression;
				case 3: return this.comma;
				case 4: return this.type;
				case 5: return this.closeParenToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitRefValueExpression(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitRefValueExpression(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new RefValueExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.comma, this.type, this.closeParenToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new RefValueExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.comma, this.type, this.closeParenToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents the syntax node for Checked or Unchecked expression.</summary>
	public sealed partial class CheckedExpressionSyntax : ExpressionSyntax
	{
		public readonly SyntaxToken keyword;
		public readonly SyntaxToken openParenToken;
		public readonly ExpressionSyntax expression;
		public readonly SyntaxToken closeParenToken;

		public CheckedExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}


		public CheckedExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}


		public CheckedExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
			: base(kind)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}

		/// <summary>SyntaxToken representing the checked or unchecked keyword.</summary>
		public SyntaxToken Keyword { get { return this.keyword; } }
		/// <summary>SyntaxToken representing open parenthesis.</summary>
		public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
		/// <summary>Argument of the primary function.</summary>
		public ExpressionSyntax Expression { get { return this.expression; } }
		/// <summary>SyntaxToken representing close parenthesis.</summary>
		public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.keyword;
				case 1: return this.openParenToken;
				case 2: return this.expression;
				case 3: return this.closeParenToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitCheckedExpression(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitCheckedExpression(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new CheckedExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.closeParenToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new CheckedExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.closeParenToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents the syntax node for Default expression.</summary>
	public sealed partial class DefaultExpressionSyntax : ExpressionSyntax
	{
		public readonly SyntaxToken keyword;
		public readonly SyntaxToken openParenToken;
		public readonly TypeSyntax type;
		public readonly SyntaxToken closeParenToken;

		public DefaultExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}


		public DefaultExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}


		public DefaultExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
			: base(kind)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}

		/// <summary>SyntaxToken representing the DefaultKeyword.</summary>
		public SyntaxToken Keyword { get { return this.keyword; } }
		/// <summary>SyntaxToken representing open parenthesis.</summary>
		public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
		/// <summary>Argument of the primary function.</summary>
		public TypeSyntax Type { get { return this.type; } }
		/// <summary>SyntaxToken representing close parenthesis.</summary>
		public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.keyword;
				case 1: return this.openParenToken;
				case 2: return this.type;
				case 3: return this.closeParenToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitDefaultExpression(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitDefaultExpression(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new DefaultExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.type, this.closeParenToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new DefaultExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.type, this.closeParenToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents the syntax node for TypeOf expression.</summary>
	public sealed partial class TypeOfExpressionSyntax : ExpressionSyntax
	{
		public readonly SyntaxToken keyword;
		public readonly SyntaxToken openParenToken;
		public readonly TypeSyntax type;
		public readonly SyntaxToken closeParenToken;

		public TypeOfExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}


		public TypeOfExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}


		public TypeOfExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
			: base(kind)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}

		/// <summary>SyntaxToken representing the TypeOfKeyword.</summary>
		public SyntaxToken Keyword { get { return this.keyword; } }
		/// <summary>SyntaxToken representing open parenthesis.</summary>
		public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
		/// <summary>The expression to return type of.</summary>
		public TypeSyntax Type { get { return this.type; } }
		/// <summary>SyntaxToken representing close parenthesis.</summary>
		public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.keyword;
				case 1: return this.openParenToken;
				case 2: return this.type;
				case 3: return this.closeParenToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitTypeOfExpression(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitTypeOfExpression(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new TypeOfExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.type, this.closeParenToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new TypeOfExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.type, this.closeParenToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents the syntax node for SizeOf expression.</summary>
	public sealed partial class SizeOfExpressionSyntax : ExpressionSyntax
	{
		public readonly SyntaxToken keyword;
		public readonly SyntaxToken openParenToken;
		public readonly TypeSyntax type;
		public readonly SyntaxToken closeParenToken;

		public SizeOfExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}


		public SizeOfExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}


		public SizeOfExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
			: base(kind)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}

		/// <summary>SyntaxToken representing the SizeOfKeyword.</summary>
		public SyntaxToken Keyword { get { return this.keyword; } }
		/// <summary>SyntaxToken representing open parenthesis.</summary>
		public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
		/// <summary>Argument of the primary function.</summary>
		public TypeSyntax Type { get { return this.type; } }
		/// <summary>SyntaxToken representing close parenthesis.</summary>
		public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.keyword;
				case 1: return this.openParenToken;
				case 2: return this.type;
				case 3: return this.closeParenToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitSizeOfExpression(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitSizeOfExpression(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new SizeOfExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.type, this.closeParenToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new SizeOfExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.type, this.closeParenToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents the syntax node for invocation expression.</summary>
	public sealed partial class InvocationExpressionSyntax : ExpressionSyntax
	{
		public readonly ExpressionSyntax expression;
		public readonly ArgumentListSyntax argumentList;

		public InvocationExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, ArgumentListSyntax argumentList, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			this.AdjustFlagsAndWidth(argumentList);
			this.argumentList = argumentList;
		}


		public InvocationExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, ArgumentListSyntax argumentList, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			this.AdjustFlagsAndWidth(argumentList);
			this.argumentList = argumentList;
		}


		public InvocationExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, ArgumentListSyntax argumentList)
			: base(kind)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			this.AdjustFlagsAndWidth(argumentList);
			this.argumentList = argumentList;
		}

		/// <summary>ExpressionSyntax node representing the expression part of the invocation.</summary>
		public ExpressionSyntax Expression { get { return this.expression; } }
		/// <summary>ArgumentListSyntax node representing the list of arguments of the invocation expression.</summary>
		public ArgumentListSyntax ArgumentList { get { return this.argumentList; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.expression;
				case 1: return this.argumentList;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitInvocationExpression(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitInvocationExpression(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new InvocationExpressionSyntax(this.Kind, this.expression, this.argumentList, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new InvocationExpressionSyntax(this.Kind, this.expression, this.argumentList, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents the syntax node for element access expression.</summary>
	public sealed partial class ElementAccessExpressionSyntax : ExpressionSyntax
	{
		public readonly ExpressionSyntax expression;
		public readonly BracketedArgumentListSyntax argumentList;

		public ElementAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, BracketedArgumentListSyntax argumentList, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			this.AdjustFlagsAndWidth(argumentList);
			this.argumentList = argumentList;
		}


		public ElementAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, BracketedArgumentListSyntax argumentList, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			this.AdjustFlagsAndWidth(argumentList);
			this.argumentList = argumentList;
		}


		public ElementAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, BracketedArgumentListSyntax argumentList)
			: base(kind)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			this.AdjustFlagsAndWidth(argumentList);
			this.argumentList = argumentList;
		}

		/// <summary>ExpressionSyntax node representing the expression which is accessing the element.</summary>
		public ExpressionSyntax Expression { get { return this.expression; } }
		/// <summary>BracketedArgumentListSyntax node representing the list of arguments of the element access expression.</summary>
		public BracketedArgumentListSyntax ArgumentList { get { return this.argumentList; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.expression;
				case 1: return this.argumentList;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitElementAccessExpression(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitElementAccessExpression(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new ElementAccessExpressionSyntax(this.Kind, this.expression, this.argumentList, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new ElementAccessExpressionSyntax(this.Kind, this.expression, this.argumentList, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Provides the base class from which the classes that represent argument list syntax nodes are derived. This is an abstract class.</summary>
	public abstract partial class BaseArgumentListSyntax : LeeSyntaxNode
	{
		public BaseArgumentListSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
		  : base(kind, diagnostics, annotations)
		{
		}
		public BaseArgumentListSyntax(SyntaxKind kind)
		  : base(kind)
		{
		}

		/// <summary>SeparatedSyntaxList of ArgumentSyntax nodes representing the list of arguments.</summary>
		public abstract SeparatedSyntaxList<ArgumentSyntax> Arguments { get; }
	}

	/// <summary>Class which represents the syntax node for the list of arguments.</summary>
	public sealed partial class ArgumentListSyntax : BaseArgumentListSyntax
	{
		public readonly SyntaxToken openParenToken;
		public readonly GreenNode arguments;
		public readonly SyntaxToken closeParenToken;

		public ArgumentListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode arguments, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			if (arguments != null)
			{
				this.AdjustFlagsAndWidth(arguments);
				this.arguments = arguments;
			}
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}


		public ArgumentListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode arguments, SyntaxToken closeParenToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			if (arguments != null)
			{
				this.AdjustFlagsAndWidth(arguments);
				this.arguments = arguments;
			}
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}


		public ArgumentListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode arguments, SyntaxToken closeParenToken)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			if (arguments != null)
			{
				this.AdjustFlagsAndWidth(arguments);
				this.arguments = arguments;
			}
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}

		/// <summary>SyntaxToken representing open parenthesis.</summary>
		public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
		/// <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
		public override SeparatedSyntaxList<ArgumentSyntax> Arguments { get { return new SeparatedSyntaxList<ArgumentSyntax>(new SyntaxList<LeeSyntaxNode>(this.arguments)); } }
		/// <summary>SyntaxToken representing close parenthesis.</summary>
		public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.openParenToken;
				case 1: return this.arguments;
				case 2: return this.closeParenToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitArgumentList(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitArgumentList(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new ArgumentListSyntax(this.Kind, this.openParenToken, this.arguments, this.closeParenToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new ArgumentListSyntax(this.Kind, this.openParenToken, this.arguments, this.closeParenToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents the syntax node for bracketed argument list.</summary>
	public sealed partial class BracketedArgumentListSyntax : BaseArgumentListSyntax
	{
		public readonly SyntaxToken openBracketToken;
		public readonly GreenNode arguments;
		public readonly SyntaxToken closeBracketToken;

		public BracketedArgumentListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode arguments, SyntaxToken closeBracketToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openBracketToken);
			this.openBracketToken = openBracketToken;
			if (arguments != null)
			{
				this.AdjustFlagsAndWidth(arguments);
				this.arguments = arguments;
			}
			this.AdjustFlagsAndWidth(closeBracketToken);
			this.closeBracketToken = closeBracketToken;
		}


		public BracketedArgumentListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode arguments, SyntaxToken closeBracketToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openBracketToken);
			this.openBracketToken = openBracketToken;
			if (arguments != null)
			{
				this.AdjustFlagsAndWidth(arguments);
				this.arguments = arguments;
			}
			this.AdjustFlagsAndWidth(closeBracketToken);
			this.closeBracketToken = closeBracketToken;
		}


		public BracketedArgumentListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode arguments, SyntaxToken closeBracketToken)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openBracketToken);
			this.openBracketToken = openBracketToken;
			if (arguments != null)
			{
				this.AdjustFlagsAndWidth(arguments);
				this.arguments = arguments;
			}
			this.AdjustFlagsAndWidth(closeBracketToken);
			this.closeBracketToken = closeBracketToken;
		}

		/// <summary>SyntaxToken representing open bracket.</summary>
		public SyntaxToken OpenBracketToken { get { return this.openBracketToken; } }
		/// <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
		public override SeparatedSyntaxList<ArgumentSyntax> Arguments { get { return new SeparatedSyntaxList<ArgumentSyntax>(new SyntaxList<LeeSyntaxNode>(this.arguments)); } }
		/// <summary>SyntaxToken representing close bracket.</summary>
		public SyntaxToken CloseBracketToken { get { return this.closeBracketToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.openBracketToken;
				case 1: return this.arguments;
				case 2: return this.closeBracketToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitBracketedArgumentList(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitBracketedArgumentList(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new BracketedArgumentListSyntax(this.Kind, this.openBracketToken, this.arguments, this.closeBracketToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new BracketedArgumentListSyntax(this.Kind, this.openBracketToken, this.arguments, this.closeBracketToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents the syntax node for argument.</summary>
	public sealed partial class ArgumentSyntax : LeeSyntaxNode
	{
		public readonly NameColonSyntax nameColon;
		public readonly SyntaxToken refKindKeyword;
		public readonly ExpressionSyntax expression;

		public ArgumentSyntax(SyntaxKind kind, NameColonSyntax nameColon, SyntaxToken refKindKeyword, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			if (nameColon != null)
			{
				this.AdjustFlagsAndWidth(nameColon);
				this.nameColon = nameColon;
			}
			if (refKindKeyword != null)
			{
				this.AdjustFlagsAndWidth(refKindKeyword);
				this.refKindKeyword = refKindKeyword;
			}
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
		}


		public ArgumentSyntax(SyntaxKind kind, NameColonSyntax nameColon, SyntaxToken refKindKeyword, ExpressionSyntax expression, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			if (nameColon != null)
			{
				this.AdjustFlagsAndWidth(nameColon);
				this.nameColon = nameColon;
			}
			if (refKindKeyword != null)
			{
				this.AdjustFlagsAndWidth(refKindKeyword);
				this.refKindKeyword = refKindKeyword;
			}
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
		}


		public ArgumentSyntax(SyntaxKind kind, NameColonSyntax nameColon, SyntaxToken refKindKeyword, ExpressionSyntax expression)
			: base(kind)
		{
			this.SlotCount = 3;
			if (nameColon != null)
			{
				this.AdjustFlagsAndWidth(nameColon);
				this.nameColon = nameColon;
			}
			if (refKindKeyword != null)
			{
				this.AdjustFlagsAndWidth(refKindKeyword);
				this.refKindKeyword = refKindKeyword;
			}
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
		}

		/// <summary>NameColonSyntax node representing the optional name arguments.</summary>
		public NameColonSyntax NameColon { get { return this.nameColon; } }
		/// <summary>SyntaxToken representing the optional ref or out keyword.</summary>
		public SyntaxToken RefKindKeyword { get { return this.refKindKeyword; } }
		/// <summary>ExpressionSyntax node representing the argument.</summary>
		public ExpressionSyntax Expression { get { return this.expression; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.nameColon;
				case 1: return this.refKindKeyword;
				case 2: return this.expression;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitArgument(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitArgument(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new ArgumentSyntax(this.Kind, this.nameColon, this.refKindKeyword, this.expression, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new ArgumentSyntax(this.Kind, this.nameColon, this.refKindKeyword, this.expression, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents the syntax node for name colon syntax.</summary>
	public sealed partial class NameColonSyntax : LeeSyntaxNode
	{
		public readonly IdentifierNameSyntax name;
		public readonly SyntaxToken colonToken;

		public NameColonSyntax(SyntaxKind kind, IdentifierNameSyntax name, SyntaxToken colonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(name);
			this.name = name;
			this.AdjustFlagsAndWidth(colonToken);
			this.colonToken = colonToken;
		}


		public NameColonSyntax(SyntaxKind kind, IdentifierNameSyntax name, SyntaxToken colonToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(name);
			this.name = name;
			this.AdjustFlagsAndWidth(colonToken);
			this.colonToken = colonToken;
		}


		public NameColonSyntax(SyntaxKind kind, IdentifierNameSyntax name, SyntaxToken colonToken)
			: base(kind)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(name);
			this.name = name;
			this.AdjustFlagsAndWidth(colonToken);
			this.colonToken = colonToken;
		}

		/// <summary>IdentifierNameSyntax representing the identifier name.</summary>
		public IdentifierNameSyntax Name { get { return this.name; } }
		/// <summary>SyntaxToken representing colon.</summary>
		public SyntaxToken ColonToken { get { return this.colonToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.name;
				case 1: return this.colonToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitNameColon(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitNameColon(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new NameColonSyntax(this.Kind, this.name, this.colonToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new NameColonSyntax(this.Kind, this.name, this.colonToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents the syntax node for the variable declaration in an out var declaration or a deconstruction declaration.</summary>
	public sealed partial class DeclarationExpressionSyntax : ExpressionSyntax
	{
		public readonly TypeSyntax type;
		public readonly VariableDesignationSyntax designation;

		public DeclarationExpressionSyntax(SyntaxKind kind, TypeSyntax type, VariableDesignationSyntax designation, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			this.AdjustFlagsAndWidth(designation);
			this.designation = designation;
		}


		public DeclarationExpressionSyntax(SyntaxKind kind, TypeSyntax type, VariableDesignationSyntax designation, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			this.AdjustFlagsAndWidth(designation);
			this.designation = designation;
		}


		public DeclarationExpressionSyntax(SyntaxKind kind, TypeSyntax type, VariableDesignationSyntax designation)
			: base(kind)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			this.AdjustFlagsAndWidth(designation);
			this.designation = designation;
		}

		public TypeSyntax Type { get { return this.type; } }
		/// <summary>Declaration representing the variable declared in an out parameter or deconstruction.</summary>
		public VariableDesignationSyntax Designation { get { return this.designation; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.type;
				case 1: return this.designation;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitDeclarationExpression(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitDeclarationExpression(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new DeclarationExpressionSyntax(this.Kind, this.type, this.designation, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new DeclarationExpressionSyntax(this.Kind, this.type, this.designation, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents the syntax node for cast expression.</summary>
	public sealed partial class CastExpressionSyntax : ExpressionSyntax
	{
		public readonly SyntaxToken openParenToken;
		public readonly TypeSyntax type;
		public readonly SyntaxToken closeParenToken;
		public readonly ExpressionSyntax expression;

		public CastExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
		}


		public CastExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
		}


		public CastExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression)
			: base(kind)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
		}

		/// <summary>SyntaxToken representing the open parenthesis.</summary>
		public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
		/// <summary>TypeSyntax node representing the type to which the expression is being cast.</summary>
		public TypeSyntax Type { get { return this.type; } }
		/// <summary>SyntaxToken representing the close parenthesis.</summary>
		public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }
		/// <summary>ExpressionSyntax node representing the expression that is being casted.</summary>
		public ExpressionSyntax Expression { get { return this.expression; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.openParenToken;
				case 1: return this.type;
				case 2: return this.closeParenToken;
				case 3: return this.expression;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitCastExpression(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitCastExpression(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new CastExpressionSyntax(this.Kind, this.openParenToken, this.type, this.closeParenToken, this.expression, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new CastExpressionSyntax(this.Kind, this.openParenToken, this.type, this.closeParenToken, this.expression, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Provides the base class from which the classes that represent anonymous function expressions are derived.</summary>
	public abstract partial class AnonymousFunctionExpressionSyntax : ExpressionSyntax
	{
		public AnonymousFunctionExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
		  : base(kind, diagnostics, annotations)
		{
		}
		public AnonymousFunctionExpressionSyntax(SyntaxKind kind)
		  : base(kind)
		{
		}

		/// <summary>Gets the "async" token.</summary>
		public abstract SyntaxToken AsyncKeyword { get; }

		/// <summary>ExpressionSyntax or BlockSyntax representing the body of the lambda expression.</summary>
		public abstract LeeSyntaxNode Body { get; }
	}

	/// <summary>Class which represents the syntax node for anonymous method expression.</summary>
	public sealed partial class AnonymousMethodExpressionSyntax : AnonymousFunctionExpressionSyntax
	{
		public readonly SyntaxToken asyncKeyword;
		public readonly SyntaxToken delegateKeyword;
		public readonly ParameterListSyntax parameterList;
		public readonly LeeSyntaxNode body;

		public AnonymousMethodExpressionSyntax(SyntaxKind kind, SyntaxToken asyncKeyword, SyntaxToken delegateKeyword, ParameterListSyntax parameterList, LeeSyntaxNode body, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 4;
			if (asyncKeyword != null)
			{
				this.AdjustFlagsAndWidth(asyncKeyword);
				this.asyncKeyword = asyncKeyword;
			}
			this.AdjustFlagsAndWidth(delegateKeyword);
			this.delegateKeyword = delegateKeyword;
			if (parameterList != null)
			{
				this.AdjustFlagsAndWidth(parameterList);
				this.parameterList = parameterList;
			}
			this.AdjustFlagsAndWidth(body);
			this.body = body;
		}


		public AnonymousMethodExpressionSyntax(SyntaxKind kind, SyntaxToken asyncKeyword, SyntaxToken delegateKeyword, ParameterListSyntax parameterList, LeeSyntaxNode body, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 4;
			if (asyncKeyword != null)
			{
				this.AdjustFlagsAndWidth(asyncKeyword);
				this.asyncKeyword = asyncKeyword;
			}
			this.AdjustFlagsAndWidth(delegateKeyword);
			this.delegateKeyword = delegateKeyword;
			if (parameterList != null)
			{
				this.AdjustFlagsAndWidth(parameterList);
				this.parameterList = parameterList;
			}
			this.AdjustFlagsAndWidth(body);
			this.body = body;
		}


		public AnonymousMethodExpressionSyntax(SyntaxKind kind, SyntaxToken asyncKeyword, SyntaxToken delegateKeyword, ParameterListSyntax parameterList, LeeSyntaxNode body)
			: base(kind)
		{
			this.SlotCount = 4;
			if (asyncKeyword != null)
			{
				this.AdjustFlagsAndWidth(asyncKeyword);
				this.asyncKeyword = asyncKeyword;
			}
			this.AdjustFlagsAndWidth(delegateKeyword);
			this.delegateKeyword = delegateKeyword;
			if (parameterList != null)
			{
				this.AdjustFlagsAndWidth(parameterList);
				this.parameterList = parameterList;
			}
			this.AdjustFlagsAndWidth(body);
			this.body = body;
		}

		/// <summary>Gets the "async" token.</summary>
		public override SyntaxToken AsyncKeyword { get { return this.asyncKeyword; } }
		/// <summary>SyntaxToken representing the delegate keyword.</summary>
		public SyntaxToken DelegateKeyword { get { return this.delegateKeyword; } }
		/// <summary>List of parameters of the anonymous method expression, or null if there no parameters are specified.</summary>
		public ParameterListSyntax ParameterList { get { return this.parameterList; } }
		/// <summary>BlockSyntax node representing the body of the anonymous method.</summary>
		public override LeeSyntaxNode Body { get { return this.body; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.asyncKeyword;
				case 1: return this.delegateKeyword;
				case 2: return this.parameterList;
				case 3: return this.body;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitAnonymousMethodExpression(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitAnonymousMethodExpression(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new AnonymousMethodExpressionSyntax(this.Kind, this.asyncKeyword, this.delegateKeyword, this.parameterList, this.body, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new AnonymousMethodExpressionSyntax(this.Kind, this.asyncKeyword, this.delegateKeyword, this.parameterList, this.body, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Provides the base class from which the classes that represent lambda expressions are derived.</summary>
	public abstract partial class LambdaExpressionSyntax : AnonymousFunctionExpressionSyntax
	{
		public LambdaExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
		  : base(kind, diagnostics, annotations)
		{
		}
		public LambdaExpressionSyntax(SyntaxKind kind)
		  : base(kind)
		{
		}

		/// <summary>SyntaxToken representing equals greater than.</summary>
		public abstract SyntaxToken ArrowToken { get; }
	}

	/// <summary>Class which represents the syntax node for a simple lambda expression.</summary>
	public sealed partial class SimpleLambdaExpressionSyntax : LambdaExpressionSyntax
	{
		public readonly SyntaxToken asyncKeyword;
		public readonly ParameterSyntax parameter;
		public readonly SyntaxToken arrowToken;
		public readonly LeeSyntaxNode body;

		public SimpleLambdaExpressionSyntax(SyntaxKind kind, SyntaxToken asyncKeyword, ParameterSyntax parameter, SyntaxToken arrowToken, LeeSyntaxNode body, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 4;
			if (asyncKeyword != null)
			{
				this.AdjustFlagsAndWidth(asyncKeyword);
				this.asyncKeyword = asyncKeyword;
			}
			this.AdjustFlagsAndWidth(parameter);
			this.parameter = parameter;
			this.AdjustFlagsAndWidth(arrowToken);
			this.arrowToken = arrowToken;
			this.AdjustFlagsAndWidth(body);
			this.body = body;
		}


		public SimpleLambdaExpressionSyntax(SyntaxKind kind, SyntaxToken asyncKeyword, ParameterSyntax parameter, SyntaxToken arrowToken, LeeSyntaxNode body, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 4;
			if (asyncKeyword != null)
			{
				this.AdjustFlagsAndWidth(asyncKeyword);
				this.asyncKeyword = asyncKeyword;
			}
			this.AdjustFlagsAndWidth(parameter);
			this.parameter = parameter;
			this.AdjustFlagsAndWidth(arrowToken);
			this.arrowToken = arrowToken;
			this.AdjustFlagsAndWidth(body);
			this.body = body;
		}


		public SimpleLambdaExpressionSyntax(SyntaxKind kind, SyntaxToken asyncKeyword, ParameterSyntax parameter, SyntaxToken arrowToken, LeeSyntaxNode body)
			: base(kind)
		{
			this.SlotCount = 4;
			if (asyncKeyword != null)
			{
				this.AdjustFlagsAndWidth(asyncKeyword);
				this.asyncKeyword = asyncKeyword;
			}
			this.AdjustFlagsAndWidth(parameter);
			this.parameter = parameter;
			this.AdjustFlagsAndWidth(arrowToken);
			this.arrowToken = arrowToken;
			this.AdjustFlagsAndWidth(body);
			this.body = body;
		}

		/// <summary>Gets the "async" token.</summary>
		public override SyntaxToken AsyncKeyword { get { return this.asyncKeyword; } }
		/// <summary>ParameterSyntax node representing the parameter of the lambda expression.</summary>
		public ParameterSyntax Parameter { get { return this.parameter; } }
		/// <summary>SyntaxToken representing equals greater than.</summary>
		public override SyntaxToken ArrowToken { get { return this.arrowToken; } }
		/// <summary>SyntaxNode representing the body of the lambda expression.</summary>
		public override LeeSyntaxNode Body { get { return this.body; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.asyncKeyword;
				case 1: return this.parameter;
				case 2: return this.arrowToken;
				case 3: return this.body;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitSimpleLambdaExpression(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitSimpleLambdaExpression(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new SimpleLambdaExpressionSyntax(this.Kind, this.asyncKeyword, this.parameter, this.arrowToken, this.body, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new SimpleLambdaExpressionSyntax(this.Kind, this.asyncKeyword, this.parameter, this.arrowToken, this.body, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class RefExpressionSyntax : ExpressionSyntax
	{
		public readonly SyntaxToken refKeyword;
		public readonly ExpressionSyntax expression;

		public RefExpressionSyntax(SyntaxKind kind, SyntaxToken refKeyword, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(refKeyword);
			this.refKeyword = refKeyword;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
		}


		public RefExpressionSyntax(SyntaxKind kind, SyntaxToken refKeyword, ExpressionSyntax expression, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(refKeyword);
			this.refKeyword = refKeyword;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
		}


		public RefExpressionSyntax(SyntaxKind kind, SyntaxToken refKeyword, ExpressionSyntax expression)
			: base(kind)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(refKeyword);
			this.refKeyword = refKeyword;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
		}

		public SyntaxToken RefKeyword { get { return this.refKeyword; } }
		public ExpressionSyntax Expression { get { return this.expression; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.refKeyword;
				case 1: return this.expression;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitRefExpression(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitRefExpression(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new RefExpressionSyntax(this.Kind, this.refKeyword, this.expression, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new RefExpressionSyntax(this.Kind, this.refKeyword, this.expression, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents the syntax node for parenthesized lambda expression.</summary>
	public sealed partial class ParenthesizedLambdaExpressionSyntax : LambdaExpressionSyntax
	{
		public readonly SyntaxToken asyncKeyword;
		public readonly ParameterListSyntax parameterList;
		public readonly SyntaxToken arrowToken;
		public readonly LeeSyntaxNode body;

		public ParenthesizedLambdaExpressionSyntax(SyntaxKind kind, SyntaxToken asyncKeyword, ParameterListSyntax parameterList, SyntaxToken arrowToken, LeeSyntaxNode body, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 4;
			if (asyncKeyword != null)
			{
				this.AdjustFlagsAndWidth(asyncKeyword);
				this.asyncKeyword = asyncKeyword;
			}
			this.AdjustFlagsAndWidth(parameterList);
			this.parameterList = parameterList;
			this.AdjustFlagsAndWidth(arrowToken);
			this.arrowToken = arrowToken;
			this.AdjustFlagsAndWidth(body);
			this.body = body;
		}


		public ParenthesizedLambdaExpressionSyntax(SyntaxKind kind, SyntaxToken asyncKeyword, ParameterListSyntax parameterList, SyntaxToken arrowToken, LeeSyntaxNode body, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 4;
			if (asyncKeyword != null)
			{
				this.AdjustFlagsAndWidth(asyncKeyword);
				this.asyncKeyword = asyncKeyword;
			}
			this.AdjustFlagsAndWidth(parameterList);
			this.parameterList = parameterList;
			this.AdjustFlagsAndWidth(arrowToken);
			this.arrowToken = arrowToken;
			this.AdjustFlagsAndWidth(body);
			this.body = body;
		}


		public ParenthesizedLambdaExpressionSyntax(SyntaxKind kind, SyntaxToken asyncKeyword, ParameterListSyntax parameterList, SyntaxToken arrowToken, LeeSyntaxNode body)
			: base(kind)
		{
			this.SlotCount = 4;
			if (asyncKeyword != null)
			{
				this.AdjustFlagsAndWidth(asyncKeyword);
				this.asyncKeyword = asyncKeyword;
			}
			this.AdjustFlagsAndWidth(parameterList);
			this.parameterList = parameterList;
			this.AdjustFlagsAndWidth(arrowToken);
			this.arrowToken = arrowToken;
			this.AdjustFlagsAndWidth(body);
			this.body = body;
		}

		/// <summary>Gets the "async" token.</summary>
		public override SyntaxToken AsyncKeyword { get { return this.asyncKeyword; } }
		/// <summary>ParameterListSyntax node representing the list of parameters for the lambda expression.</summary>
		public ParameterListSyntax ParameterList { get { return this.parameterList; } }
		/// <summary>SyntaxToken representing equals greater than.</summary>
		public override SyntaxToken ArrowToken { get { return this.arrowToken; } }
		/// <summary>SyntaxNode representing the body of the lambda expression.</summary>
		public override LeeSyntaxNode Body { get { return this.body; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.asyncKeyword;
				case 1: return this.parameterList;
				case 2: return this.arrowToken;
				case 3: return this.body;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitParenthesizedLambdaExpression(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitParenthesizedLambdaExpression(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new ParenthesizedLambdaExpressionSyntax(this.Kind, this.asyncKeyword, this.parameterList, this.arrowToken, this.body, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new ParenthesizedLambdaExpressionSyntax(this.Kind, this.asyncKeyword, this.parameterList, this.arrowToken, this.body, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents the syntax node for initializer expression.</summary>
	public sealed partial class InitializerExpressionSyntax : ExpressionSyntax
	{
		public readonly SyntaxToken openBraceToken;
		public readonly GreenNode expressions;
		public readonly SyntaxToken closeBraceToken;

		public InitializerExpressionSyntax(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode expressions, SyntaxToken closeBraceToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openBraceToken);
			this.openBraceToken = openBraceToken;
			if (expressions != null)
			{
				this.AdjustFlagsAndWidth(expressions);
				this.expressions = expressions;
			}
			this.AdjustFlagsAndWidth(closeBraceToken);
			this.closeBraceToken = closeBraceToken;
		}


		public InitializerExpressionSyntax(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode expressions, SyntaxToken closeBraceToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openBraceToken);
			this.openBraceToken = openBraceToken;
			if (expressions != null)
			{
				this.AdjustFlagsAndWidth(expressions);
				this.expressions = expressions;
			}
			this.AdjustFlagsAndWidth(closeBraceToken);
			this.closeBraceToken = closeBraceToken;
		}


		public InitializerExpressionSyntax(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode expressions, SyntaxToken closeBraceToken)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openBraceToken);
			this.openBraceToken = openBraceToken;
			if (expressions != null)
			{
				this.AdjustFlagsAndWidth(expressions);
				this.expressions = expressions;
			}
			this.AdjustFlagsAndWidth(closeBraceToken);
			this.closeBraceToken = closeBraceToken;
		}

		/// <summary>SyntaxToken representing the open brace.</summary>
		public SyntaxToken OpenBraceToken { get { return this.openBraceToken; } }
		/// <summary>SeparatedSyntaxList of ExpressionSyntax representing the list of expressions in the initializer expression.</summary>
		public SeparatedSyntaxList<ExpressionSyntax> Expressions { get { return new SeparatedSyntaxList<ExpressionSyntax>(new SyntaxList<LeeSyntaxNode>(this.expressions)); } }
		/// <summary>SyntaxToken representing the close brace.</summary>
		public SyntaxToken CloseBraceToken { get { return this.closeBraceToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.openBraceToken;
				case 1: return this.expressions;
				case 2: return this.closeBraceToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitInitializerExpression(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitInitializerExpression(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new InitializerExpressionSyntax(this.Kind, this.openBraceToken, this.expressions, this.closeBraceToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new InitializerExpressionSyntax(this.Kind, this.openBraceToken, this.expressions, this.closeBraceToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents the syntax node for object creation expression.</summary>
	public sealed partial class ObjectCreationExpressionSyntax : ExpressionSyntax
	{
		public readonly SyntaxToken newKeyword;
		public readonly TypeSyntax type;
		public readonly ArgumentListSyntax argumentList;
		public readonly InitializerExpressionSyntax initializer;

		public ObjectCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(newKeyword);
			this.newKeyword = newKeyword;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			if (argumentList != null)
			{
				this.AdjustFlagsAndWidth(argumentList);
				this.argumentList = argumentList;
			}
			if (initializer != null)
			{
				this.AdjustFlagsAndWidth(initializer);
				this.initializer = initializer;
			}
		}


		public ObjectCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(newKeyword);
			this.newKeyword = newKeyword;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			if (argumentList != null)
			{
				this.AdjustFlagsAndWidth(argumentList);
				this.argumentList = argumentList;
			}
			if (initializer != null)
			{
				this.AdjustFlagsAndWidth(initializer);
				this.initializer = initializer;
			}
		}


		public ObjectCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer)
			: base(kind)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(newKeyword);
			this.newKeyword = newKeyword;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			if (argumentList != null)
			{
				this.AdjustFlagsAndWidth(argumentList);
				this.argumentList = argumentList;
			}
			if (initializer != null)
			{
				this.AdjustFlagsAndWidth(initializer);
				this.initializer = initializer;
			}
		}

		/// <summary>SyntaxToken representing the new keyword.</summary>
		public SyntaxToken NewKeyword { get { return this.newKeyword; } }
		/// <summary>TypeSyntax representing the type of the object being created.</summary>
		public TypeSyntax Type { get { return this.type; } }
		/// <summary>ArgumentListSyntax representing the list of arguments passed as part of the object creation expression.</summary>
		public ArgumentListSyntax ArgumentList { get { return this.argumentList; } }
		/// <summary>InitializerExpressionSyntax representing the initializer expression for the object being created.</summary>
		public InitializerExpressionSyntax Initializer { get { return this.initializer; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.newKeyword;
				case 1: return this.type;
				case 2: return this.argumentList;
				case 3: return this.initializer;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitObjectCreationExpression(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitObjectCreationExpression(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new ObjectCreationExpressionSyntax(this.Kind, this.newKeyword, this.type, this.argumentList, this.initializer, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new ObjectCreationExpressionSyntax(this.Kind, this.newKeyword, this.type, this.argumentList, this.initializer, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class AnonymousObjectMemberDeclaratorSyntax : LeeSyntaxNode
	{
		public readonly NameEqualsSyntax nameEquals;
		public readonly ExpressionSyntax expression;

		public AnonymousObjectMemberDeclaratorSyntax(SyntaxKind kind, NameEqualsSyntax nameEquals, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			if (nameEquals != null)
			{
				this.AdjustFlagsAndWidth(nameEquals);
				this.nameEquals = nameEquals;
			}
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
		}


		public AnonymousObjectMemberDeclaratorSyntax(SyntaxKind kind, NameEqualsSyntax nameEquals, ExpressionSyntax expression, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			if (nameEquals != null)
			{
				this.AdjustFlagsAndWidth(nameEquals);
				this.nameEquals = nameEquals;
			}
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
		}


		public AnonymousObjectMemberDeclaratorSyntax(SyntaxKind kind, NameEqualsSyntax nameEquals, ExpressionSyntax expression)
			: base(kind)
		{
			this.SlotCount = 2;
			if (nameEquals != null)
			{
				this.AdjustFlagsAndWidth(nameEquals);
				this.nameEquals = nameEquals;
			}
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
		}

		/// <summary>NameEqualsSyntax representing the optional name of the member being initialized.</summary>
		public NameEqualsSyntax NameEquals { get { return this.nameEquals; } }
		/// <summary>ExpressionSyntax representing the value the member is initialized with.</summary>
		public ExpressionSyntax Expression { get { return this.expression; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.nameEquals;
				case 1: return this.expression;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitAnonymousObjectMemberDeclarator(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitAnonymousObjectMemberDeclarator(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new AnonymousObjectMemberDeclaratorSyntax(this.Kind, this.nameEquals, this.expression, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new AnonymousObjectMemberDeclaratorSyntax(this.Kind, this.nameEquals, this.expression, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents the syntax node for anonymous object creation expression.</summary>
	public sealed partial class AnonymousObjectCreationExpressionSyntax : ExpressionSyntax
	{
		public readonly SyntaxToken newKeyword;
		public readonly SyntaxToken openBraceToken;
		public readonly GreenNode initializers;
		public readonly SyntaxToken closeBraceToken;

		public AnonymousObjectCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openBraceToken, GreenNode initializers, SyntaxToken closeBraceToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(newKeyword);
			this.newKeyword = newKeyword;
			this.AdjustFlagsAndWidth(openBraceToken);
			this.openBraceToken = openBraceToken;
			if (initializers != null)
			{
				this.AdjustFlagsAndWidth(initializers);
				this.initializers = initializers;
			}
			this.AdjustFlagsAndWidth(closeBraceToken);
			this.closeBraceToken = closeBraceToken;
		}


		public AnonymousObjectCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openBraceToken, GreenNode initializers, SyntaxToken closeBraceToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(newKeyword);
			this.newKeyword = newKeyword;
			this.AdjustFlagsAndWidth(openBraceToken);
			this.openBraceToken = openBraceToken;
			if (initializers != null)
			{
				this.AdjustFlagsAndWidth(initializers);
				this.initializers = initializers;
			}
			this.AdjustFlagsAndWidth(closeBraceToken);
			this.closeBraceToken = closeBraceToken;
		}


		public AnonymousObjectCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openBraceToken, GreenNode initializers, SyntaxToken closeBraceToken)
			: base(kind)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(newKeyword);
			this.newKeyword = newKeyword;
			this.AdjustFlagsAndWidth(openBraceToken);
			this.openBraceToken = openBraceToken;
			if (initializers != null)
			{
				this.AdjustFlagsAndWidth(initializers);
				this.initializers = initializers;
			}
			this.AdjustFlagsAndWidth(closeBraceToken);
			this.closeBraceToken = closeBraceToken;
		}

		/// <summary>SyntaxToken representing the new keyword.</summary>
		public SyntaxToken NewKeyword { get { return this.newKeyword; } }
		/// <summary>SyntaxToken representing the open brace.</summary>
		public SyntaxToken OpenBraceToken { get { return this.openBraceToken; } }
		/// <summary>SeparatedSyntaxList of AnonymousObjectMemberDeclaratorSyntax representing the list of object member initializers.</summary>
		public SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> Initializers { get { return new SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax>(new SyntaxList<LeeSyntaxNode>(this.initializers)); } }
		/// <summary>SyntaxToken representing the close brace.</summary>
		public SyntaxToken CloseBraceToken { get { return this.closeBraceToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.newKeyword;
				case 1: return this.openBraceToken;
				case 2: return this.initializers;
				case 3: return this.closeBraceToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitAnonymousObjectCreationExpression(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitAnonymousObjectCreationExpression(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new AnonymousObjectCreationExpressionSyntax(this.Kind, this.newKeyword, this.openBraceToken, this.initializers, this.closeBraceToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new AnonymousObjectCreationExpressionSyntax(this.Kind, this.newKeyword, this.openBraceToken, this.initializers, this.closeBraceToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents the syntax node for array creation expression.</summary>
	public sealed partial class ArrayCreationExpressionSyntax : ExpressionSyntax
	{
		public readonly SyntaxToken newKeyword;
		public readonly ArrayTypeSyntax type;
		public readonly InitializerExpressionSyntax initializer;

		public ArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax initializer, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(newKeyword);
			this.newKeyword = newKeyword;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			if (initializer != null)
			{
				this.AdjustFlagsAndWidth(initializer);
				this.initializer = initializer;
			}
		}


		public ArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax initializer, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(newKeyword);
			this.newKeyword = newKeyword;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			if (initializer != null)
			{
				this.AdjustFlagsAndWidth(initializer);
				this.initializer = initializer;
			}
		}


		public ArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax initializer)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(newKeyword);
			this.newKeyword = newKeyword;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			if (initializer != null)
			{
				this.AdjustFlagsAndWidth(initializer);
				this.initializer = initializer;
			}
		}

		/// <summary>SyntaxToken representing the new keyword.</summary>
		public SyntaxToken NewKeyword { get { return this.newKeyword; } }
		/// <summary>ArrayTypeSyntax node representing the type of the array.</summary>
		public ArrayTypeSyntax Type { get { return this.type; } }
		/// <summary>InitializerExpressionSyntax node representing the initializer of the array creation expression.</summary>
		public InitializerExpressionSyntax Initializer { get { return this.initializer; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.newKeyword;
				case 1: return this.type;
				case 2: return this.initializer;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitArrayCreationExpression(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitArrayCreationExpression(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new ArrayCreationExpressionSyntax(this.Kind, this.newKeyword, this.type, this.initializer, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new ArrayCreationExpressionSyntax(this.Kind, this.newKeyword, this.type, this.initializer, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents the syntax node for implicit array creation expression.</summary>
	public sealed partial class ImplicitArrayCreationExpressionSyntax : ExpressionSyntax
	{
		public readonly SyntaxToken newKeyword;
		public readonly SyntaxToken openBracketToken;
		public readonly GreenNode commas;
		public readonly SyntaxToken closeBracketToken;
		public readonly InitializerExpressionSyntax initializer;

		public ImplicitArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openBracketToken, GreenNode commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 5;
			this.AdjustFlagsAndWidth(newKeyword);
			this.newKeyword = newKeyword;
			this.AdjustFlagsAndWidth(openBracketToken);
			this.openBracketToken = openBracketToken;
			if (commas != null)
			{
				this.AdjustFlagsAndWidth(commas);
				this.commas = commas;
			}
			this.AdjustFlagsAndWidth(closeBracketToken);
			this.closeBracketToken = closeBracketToken;
			this.AdjustFlagsAndWidth(initializer);
			this.initializer = initializer;
		}


		public ImplicitArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openBracketToken, GreenNode commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 5;
			this.AdjustFlagsAndWidth(newKeyword);
			this.newKeyword = newKeyword;
			this.AdjustFlagsAndWidth(openBracketToken);
			this.openBracketToken = openBracketToken;
			if (commas != null)
			{
				this.AdjustFlagsAndWidth(commas);
				this.commas = commas;
			}
			this.AdjustFlagsAndWidth(closeBracketToken);
			this.closeBracketToken = closeBracketToken;
			this.AdjustFlagsAndWidth(initializer);
			this.initializer = initializer;
		}


		public ImplicitArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openBracketToken, GreenNode commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer)
			: base(kind)
		{
			this.SlotCount = 5;
			this.AdjustFlagsAndWidth(newKeyword);
			this.newKeyword = newKeyword;
			this.AdjustFlagsAndWidth(openBracketToken);
			this.openBracketToken = openBracketToken;
			if (commas != null)
			{
				this.AdjustFlagsAndWidth(commas);
				this.commas = commas;
			}
			this.AdjustFlagsAndWidth(closeBracketToken);
			this.closeBracketToken = closeBracketToken;
			this.AdjustFlagsAndWidth(initializer);
			this.initializer = initializer;
		}

		/// <summary>SyntaxToken representing the new keyword.</summary>
		public SyntaxToken NewKeyword { get { return this.newKeyword; } }
		/// <summary>SyntaxToken representing the open bracket.</summary>
		public SyntaxToken OpenBracketToken { get { return this.openBracketToken; } }
		/// <summary>SyntaxList of SyntaxToken representing the commas in the implicit array creation expression.</summary>
		public SyntaxList<SyntaxToken> Commas { get { return new SyntaxList<SyntaxToken>(this.commas); } }
		/// <summary>SyntaxToken representing the close bracket.</summary>
		public SyntaxToken CloseBracketToken { get { return this.closeBracketToken; } }
		/// <summary>InitializerExpressionSyntax representing the initializer expression of the implicit array creation expression.</summary>
		public InitializerExpressionSyntax Initializer { get { return this.initializer; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.newKeyword;
				case 1: return this.openBracketToken;
				case 2: return this.commas;
				case 3: return this.closeBracketToken;
				case 4: return this.initializer;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitImplicitArrayCreationExpression(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitImplicitArrayCreationExpression(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new ImplicitArrayCreationExpressionSyntax(this.Kind, this.newKeyword, this.openBracketToken, this.commas, this.closeBracketToken, this.initializer, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new ImplicitArrayCreationExpressionSyntax(this.Kind, this.newKeyword, this.openBracketToken, this.commas, this.closeBracketToken, this.initializer, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents the syntax node for stackalloc array creation expression.</summary>
	public sealed partial class StackAllocArrayCreationExpressionSyntax : ExpressionSyntax
	{
		public readonly SyntaxToken stackAllocKeyword;
		public readonly TypeSyntax type;
		public readonly InitializerExpressionSyntax initializer;

		public StackAllocArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken stackAllocKeyword, TypeSyntax type, InitializerExpressionSyntax initializer, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(stackAllocKeyword);
			this.stackAllocKeyword = stackAllocKeyword;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			if (initializer != null)
			{
				this.AdjustFlagsAndWidth(initializer);
				this.initializer = initializer;
			}
		}


		public StackAllocArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken stackAllocKeyword, TypeSyntax type, InitializerExpressionSyntax initializer, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(stackAllocKeyword);
			this.stackAllocKeyword = stackAllocKeyword;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			if (initializer != null)
			{
				this.AdjustFlagsAndWidth(initializer);
				this.initializer = initializer;
			}
		}


		public StackAllocArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken stackAllocKeyword, TypeSyntax type, InitializerExpressionSyntax initializer)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(stackAllocKeyword);
			this.stackAllocKeyword = stackAllocKeyword;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			if (initializer != null)
			{
				this.AdjustFlagsAndWidth(initializer);
				this.initializer = initializer;
			}
		}

		/// <summary>SyntaxToken representing the stackalloc keyword.</summary>
		public SyntaxToken StackAllocKeyword { get { return this.stackAllocKeyword; } }
		/// <summary>TypeSyntax node representing the type of the stackalloc array.</summary>
		public TypeSyntax Type { get { return this.type; } }
		/// <summary>InitializerExpressionSyntax node representing the initializer of the stackalloc array creation expression.</summary>
		public InitializerExpressionSyntax Initializer { get { return this.initializer; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.stackAllocKeyword;
				case 1: return this.type;
				case 2: return this.initializer;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitStackAllocArrayCreationExpression(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitStackAllocArrayCreationExpression(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new StackAllocArrayCreationExpressionSyntax(this.Kind, this.stackAllocKeyword, this.type, this.initializer, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new StackAllocArrayCreationExpressionSyntax(this.Kind, this.stackAllocKeyword, this.type, this.initializer, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents the syntax node for implicit stackalloc array creation expression.</summary>
	public sealed partial class ImplicitStackAllocArrayCreationExpressionSyntax : ExpressionSyntax
	{
		public readonly SyntaxToken stackAllocKeyword;
		public readonly SyntaxToken openBracketToken;
		public readonly SyntaxToken closeBracketToken;
		public readonly InitializerExpressionSyntax initializer;

		public ImplicitStackAllocArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken stackAllocKeyword, SyntaxToken openBracketToken, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(stackAllocKeyword);
			this.stackAllocKeyword = stackAllocKeyword;
			this.AdjustFlagsAndWidth(openBracketToken);
			this.openBracketToken = openBracketToken;
			this.AdjustFlagsAndWidth(closeBracketToken);
			this.closeBracketToken = closeBracketToken;
			this.AdjustFlagsAndWidth(initializer);
			this.initializer = initializer;
		}


		public ImplicitStackAllocArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken stackAllocKeyword, SyntaxToken openBracketToken, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(stackAllocKeyword);
			this.stackAllocKeyword = stackAllocKeyword;
			this.AdjustFlagsAndWidth(openBracketToken);
			this.openBracketToken = openBracketToken;
			this.AdjustFlagsAndWidth(closeBracketToken);
			this.closeBracketToken = closeBracketToken;
			this.AdjustFlagsAndWidth(initializer);
			this.initializer = initializer;
		}


		public ImplicitStackAllocArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken stackAllocKeyword, SyntaxToken openBracketToken, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer)
			: base(kind)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(stackAllocKeyword);
			this.stackAllocKeyword = stackAllocKeyword;
			this.AdjustFlagsAndWidth(openBracketToken);
			this.openBracketToken = openBracketToken;
			this.AdjustFlagsAndWidth(closeBracketToken);
			this.closeBracketToken = closeBracketToken;
			this.AdjustFlagsAndWidth(initializer);
			this.initializer = initializer;
		}

		/// <summary>SyntaxToken representing the stackalloc keyword.</summary>
		public SyntaxToken StackAllocKeyword { get { return this.stackAllocKeyword; } }
		/// <summary>SyntaxToken representing the open bracket.</summary>
		public SyntaxToken OpenBracketToken { get { return this.openBracketToken; } }
		/// <summary>SyntaxToken representing the close bracket.</summary>
		public SyntaxToken CloseBracketToken { get { return this.closeBracketToken; } }
		/// <summary>InitializerExpressionSyntax representing the initializer expression of the implicit stackalloc array creation expression.</summary>
		public InitializerExpressionSyntax Initializer { get { return this.initializer; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.stackAllocKeyword;
				case 1: return this.openBracketToken;
				case 2: return this.closeBracketToken;
				case 3: return this.initializer;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitImplicitStackAllocArrayCreationExpression(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitImplicitStackAllocArrayCreationExpression(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new ImplicitStackAllocArrayCreationExpressionSyntax(this.Kind, this.stackAllocKeyword, this.openBracketToken, this.closeBracketToken, this.initializer, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new ImplicitStackAllocArrayCreationExpressionSyntax(this.Kind, this.stackAllocKeyword, this.openBracketToken, this.closeBracketToken, this.initializer, GetDiagnostics(), annotations);
		}
	}

	public abstract partial class QueryClauseSyntax : LeeSyntaxNode
	{
		public QueryClauseSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
		  : base(kind, diagnostics, annotations)
		{
		}
		public QueryClauseSyntax(SyntaxKind kind)
		  : base(kind)
		{
		}
	}

	public abstract partial class SelectOrGroupClauseSyntax : LeeSyntaxNode
	{
		public SelectOrGroupClauseSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
		  : base(kind, diagnostics, annotations)
		{
		}
		public SelectOrGroupClauseSyntax(SyntaxKind kind)
		  : base(kind)
		{
		}
	}

	public sealed partial class QueryExpressionSyntax : ExpressionSyntax
	{
		public readonly FromClauseSyntax fromClause;
		public readonly QueryBodySyntax body;

		public QueryExpressionSyntax(SyntaxKind kind, FromClauseSyntax fromClause, QueryBodySyntax body, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(fromClause);
			this.fromClause = fromClause;
			this.AdjustFlagsAndWidth(body);
			this.body = body;
		}


		public QueryExpressionSyntax(SyntaxKind kind, FromClauseSyntax fromClause, QueryBodySyntax body, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(fromClause);
			this.fromClause = fromClause;
			this.AdjustFlagsAndWidth(body);
			this.body = body;
		}


		public QueryExpressionSyntax(SyntaxKind kind, FromClauseSyntax fromClause, QueryBodySyntax body)
			: base(kind)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(fromClause);
			this.fromClause = fromClause;
			this.AdjustFlagsAndWidth(body);
			this.body = body;
		}

		public FromClauseSyntax FromClause { get { return this.fromClause; } }
		public QueryBodySyntax Body { get { return this.body; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.fromClause;
				case 1: return this.body;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitQueryExpression(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitQueryExpression(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new QueryExpressionSyntax(this.Kind, this.fromClause, this.body, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new QueryExpressionSyntax(this.Kind, this.fromClause, this.body, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class QueryBodySyntax : LeeSyntaxNode
	{
		public readonly GreenNode clauses;
		public readonly SelectOrGroupClauseSyntax selectOrGroup;
		public readonly QueryContinuationSyntax continuation;

		public QueryBodySyntax(SyntaxKind kind, GreenNode clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax continuation, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			if (clauses != null)
			{
				this.AdjustFlagsAndWidth(clauses);
				this.clauses = clauses;
			}
			this.AdjustFlagsAndWidth(selectOrGroup);
			this.selectOrGroup = selectOrGroup;
			if (continuation != null)
			{
				this.AdjustFlagsAndWidth(continuation);
				this.continuation = continuation;
			}
		}


		public QueryBodySyntax(SyntaxKind kind, GreenNode clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax continuation, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			if (clauses != null)
			{
				this.AdjustFlagsAndWidth(clauses);
				this.clauses = clauses;
			}
			this.AdjustFlagsAndWidth(selectOrGroup);
			this.selectOrGroup = selectOrGroup;
			if (continuation != null)
			{
				this.AdjustFlagsAndWidth(continuation);
				this.continuation = continuation;
			}
		}


		public QueryBodySyntax(SyntaxKind kind, GreenNode clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax continuation)
			: base(kind)
		{
			this.SlotCount = 3;
			if (clauses != null)
			{
				this.AdjustFlagsAndWidth(clauses);
				this.clauses = clauses;
			}
			this.AdjustFlagsAndWidth(selectOrGroup);
			this.selectOrGroup = selectOrGroup;
			if (continuation != null)
			{
				this.AdjustFlagsAndWidth(continuation);
				this.continuation = continuation;
			}
		}

		public SyntaxList<QueryClauseSyntax> Clauses { get { return new SyntaxList<QueryClauseSyntax>(this.clauses); } }
		public SelectOrGroupClauseSyntax SelectOrGroup { get { return this.selectOrGroup; } }
		public QueryContinuationSyntax Continuation { get { return this.continuation; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.clauses;
				case 1: return this.selectOrGroup;
				case 2: return this.continuation;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitQueryBody(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitQueryBody(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new QueryBodySyntax(this.Kind, this.clauses, this.selectOrGroup, this.continuation, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new QueryBodySyntax(this.Kind, this.clauses, this.selectOrGroup, this.continuation, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class FromClauseSyntax : QueryClauseSyntax
	{
		public readonly SyntaxToken fromKeyword;
		public readonly TypeSyntax type;
		public readonly SyntaxToken identifier;
		public readonly SyntaxToken inKeyword;
		public readonly ExpressionSyntax expression;

		public FromClauseSyntax(SyntaxKind kind, SyntaxToken fromKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 5;
			this.AdjustFlagsAndWidth(fromKeyword);
			this.fromKeyword = fromKeyword;
			if (type != null)
			{
				this.AdjustFlagsAndWidth(type);
				this.type = type;
			}
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			this.AdjustFlagsAndWidth(inKeyword);
			this.inKeyword = inKeyword;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
		}


		public FromClauseSyntax(SyntaxKind kind, SyntaxToken fromKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 5;
			this.AdjustFlagsAndWidth(fromKeyword);
			this.fromKeyword = fromKeyword;
			if (type != null)
			{
				this.AdjustFlagsAndWidth(type);
				this.type = type;
			}
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			this.AdjustFlagsAndWidth(inKeyword);
			this.inKeyword = inKeyword;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
		}


		public FromClauseSyntax(SyntaxKind kind, SyntaxToken fromKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression)
			: base(kind)
		{
			this.SlotCount = 5;
			this.AdjustFlagsAndWidth(fromKeyword);
			this.fromKeyword = fromKeyword;
			if (type != null)
			{
				this.AdjustFlagsAndWidth(type);
				this.type = type;
			}
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			this.AdjustFlagsAndWidth(inKeyword);
			this.inKeyword = inKeyword;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
		}

		public SyntaxToken FromKeyword { get { return this.fromKeyword; } }
		public TypeSyntax Type { get { return this.type; } }
		/// <summary>Gets the identifier.</summary>
		public SyntaxToken Identifier { get { return this.identifier; } }
		public SyntaxToken InKeyword { get { return this.inKeyword; } }
		public ExpressionSyntax Expression { get { return this.expression; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.fromKeyword;
				case 1: return this.type;
				case 2: return this.identifier;
				case 3: return this.inKeyword;
				case 4: return this.expression;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitFromClause(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitFromClause(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new FromClauseSyntax(this.Kind, this.fromKeyword, this.type, this.identifier, this.inKeyword, this.expression, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new FromClauseSyntax(this.Kind, this.fromKeyword, this.type, this.identifier, this.inKeyword, this.expression, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class LetClauseSyntax : QueryClauseSyntax
	{
		public readonly SyntaxToken letKeyword;
		public readonly SyntaxToken identifier;
		public readonly SyntaxToken equalsToken;
		public readonly ExpressionSyntax expression;

		public LetClauseSyntax(SyntaxKind kind, SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(letKeyword);
			this.letKeyword = letKeyword;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			this.AdjustFlagsAndWidth(equalsToken);
			this.equalsToken = equalsToken;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
		}


		public LetClauseSyntax(SyntaxKind kind, SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(letKeyword);
			this.letKeyword = letKeyword;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			this.AdjustFlagsAndWidth(equalsToken);
			this.equalsToken = equalsToken;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
		}


		public LetClauseSyntax(SyntaxKind kind, SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression)
			: base(kind)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(letKeyword);
			this.letKeyword = letKeyword;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			this.AdjustFlagsAndWidth(equalsToken);
			this.equalsToken = equalsToken;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
		}

		public SyntaxToken LetKeyword { get { return this.letKeyword; } }
		/// <summary>Gets the identifier.</summary>
		public SyntaxToken Identifier { get { return this.identifier; } }
		public SyntaxToken EqualsToken { get { return this.equalsToken; } }
		public ExpressionSyntax Expression { get { return this.expression; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.letKeyword;
				case 1: return this.identifier;
				case 2: return this.equalsToken;
				case 3: return this.expression;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitLetClause(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitLetClause(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new LetClauseSyntax(this.Kind, this.letKeyword, this.identifier, this.equalsToken, this.expression, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new LetClauseSyntax(this.Kind, this.letKeyword, this.identifier, this.equalsToken, this.expression, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class JoinClauseSyntax : QueryClauseSyntax
	{
		public readonly SyntaxToken joinKeyword;
		public readonly TypeSyntax type;
		public readonly SyntaxToken identifier;
		public readonly SyntaxToken inKeyword;
		public readonly ExpressionSyntax inExpression;
		public readonly SyntaxToken onKeyword;
		public readonly ExpressionSyntax leftExpression;
		public readonly SyntaxToken equalsKeyword;
		public readonly ExpressionSyntax rightExpression;
		public readonly JoinIntoClauseSyntax into;

		public JoinClauseSyntax(SyntaxKind kind, SyntaxToken joinKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 10;
			this.AdjustFlagsAndWidth(joinKeyword);
			this.joinKeyword = joinKeyword;
			if (type != null)
			{
				this.AdjustFlagsAndWidth(type);
				this.type = type;
			}
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			this.AdjustFlagsAndWidth(inKeyword);
			this.inKeyword = inKeyword;
			this.AdjustFlagsAndWidth(inExpression);
			this.inExpression = inExpression;
			this.AdjustFlagsAndWidth(onKeyword);
			this.onKeyword = onKeyword;
			this.AdjustFlagsAndWidth(leftExpression);
			this.leftExpression = leftExpression;
			this.AdjustFlagsAndWidth(equalsKeyword);
			this.equalsKeyword = equalsKeyword;
			this.AdjustFlagsAndWidth(rightExpression);
			this.rightExpression = rightExpression;
			if (into != null)
			{
				this.AdjustFlagsAndWidth(into);
				this.into = into;
			}
		}


		public JoinClauseSyntax(SyntaxKind kind, SyntaxToken joinKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 10;
			this.AdjustFlagsAndWidth(joinKeyword);
			this.joinKeyword = joinKeyword;
			if (type != null)
			{
				this.AdjustFlagsAndWidth(type);
				this.type = type;
			}
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			this.AdjustFlagsAndWidth(inKeyword);
			this.inKeyword = inKeyword;
			this.AdjustFlagsAndWidth(inExpression);
			this.inExpression = inExpression;
			this.AdjustFlagsAndWidth(onKeyword);
			this.onKeyword = onKeyword;
			this.AdjustFlagsAndWidth(leftExpression);
			this.leftExpression = leftExpression;
			this.AdjustFlagsAndWidth(equalsKeyword);
			this.equalsKeyword = equalsKeyword;
			this.AdjustFlagsAndWidth(rightExpression);
			this.rightExpression = rightExpression;
			if (into != null)
			{
				this.AdjustFlagsAndWidth(into);
				this.into = into;
			}
		}


		public JoinClauseSyntax(SyntaxKind kind, SyntaxToken joinKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into)
			: base(kind)
		{
			this.SlotCount = 10;
			this.AdjustFlagsAndWidth(joinKeyword);
			this.joinKeyword = joinKeyword;
			if (type != null)
			{
				this.AdjustFlagsAndWidth(type);
				this.type = type;
			}
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			this.AdjustFlagsAndWidth(inKeyword);
			this.inKeyword = inKeyword;
			this.AdjustFlagsAndWidth(inExpression);
			this.inExpression = inExpression;
			this.AdjustFlagsAndWidth(onKeyword);
			this.onKeyword = onKeyword;
			this.AdjustFlagsAndWidth(leftExpression);
			this.leftExpression = leftExpression;
			this.AdjustFlagsAndWidth(equalsKeyword);
			this.equalsKeyword = equalsKeyword;
			this.AdjustFlagsAndWidth(rightExpression);
			this.rightExpression = rightExpression;
			if (into != null)
			{
				this.AdjustFlagsAndWidth(into);
				this.into = into;
			}
		}

		public SyntaxToken JoinKeyword { get { return this.joinKeyword; } }
		public TypeSyntax Type { get { return this.type; } }
		/// <summary>Gets the identifier.</summary>
		public SyntaxToken Identifier { get { return this.identifier; } }
		public SyntaxToken InKeyword { get { return this.inKeyword; } }
		public ExpressionSyntax InExpression { get { return this.inExpression; } }
		public SyntaxToken OnKeyword { get { return this.onKeyword; } }
		public ExpressionSyntax LeftExpression { get { return this.leftExpression; } }
		public SyntaxToken EqualsKeyword { get { return this.equalsKeyword; } }
		public ExpressionSyntax RightExpression { get { return this.rightExpression; } }
		public JoinIntoClauseSyntax Into { get { return this.into; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.joinKeyword;
				case 1: return this.type;
				case 2: return this.identifier;
				case 3: return this.inKeyword;
				case 4: return this.inExpression;
				case 5: return this.onKeyword;
				case 6: return this.leftExpression;
				case 7: return this.equalsKeyword;
				case 8: return this.rightExpression;
				case 9: return this.into;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitJoinClause(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitJoinClause(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new JoinClauseSyntax(this.Kind, this.joinKeyword, this.type, this.identifier, this.inKeyword, this.inExpression, this.onKeyword, this.leftExpression, this.equalsKeyword, this.rightExpression, this.into, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new JoinClauseSyntax(this.Kind, this.joinKeyword, this.type, this.identifier, this.inKeyword, this.inExpression, this.onKeyword, this.leftExpression, this.equalsKeyword, this.rightExpression, this.into, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class JoinIntoClauseSyntax : LeeSyntaxNode
	{
		public readonly SyntaxToken intoKeyword;
		public readonly SyntaxToken identifier;

		public JoinIntoClauseSyntax(SyntaxKind kind, SyntaxToken intoKeyword, SyntaxToken identifier, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(intoKeyword);
			this.intoKeyword = intoKeyword;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
		}


		public JoinIntoClauseSyntax(SyntaxKind kind, SyntaxToken intoKeyword, SyntaxToken identifier, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(intoKeyword);
			this.intoKeyword = intoKeyword;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
		}


		public JoinIntoClauseSyntax(SyntaxKind kind, SyntaxToken intoKeyword, SyntaxToken identifier)
			: base(kind)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(intoKeyword);
			this.intoKeyword = intoKeyword;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
		}

		public SyntaxToken IntoKeyword { get { return this.intoKeyword; } }
		/// <summary>Gets the identifier.</summary>
		public SyntaxToken Identifier { get { return this.identifier; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.intoKeyword;
				case 1: return this.identifier;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitJoinIntoClause(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitJoinIntoClause(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new JoinIntoClauseSyntax(this.Kind, this.intoKeyword, this.identifier, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new JoinIntoClauseSyntax(this.Kind, this.intoKeyword, this.identifier, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class WhereClauseSyntax : QueryClauseSyntax
	{
		public readonly SyntaxToken whereKeyword;
		public readonly ExpressionSyntax condition;

		public WhereClauseSyntax(SyntaxKind kind, SyntaxToken whereKeyword, ExpressionSyntax condition, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(whereKeyword);
			this.whereKeyword = whereKeyword;
			this.AdjustFlagsAndWidth(condition);
			this.condition = condition;
		}


		public WhereClauseSyntax(SyntaxKind kind, SyntaxToken whereKeyword, ExpressionSyntax condition, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(whereKeyword);
			this.whereKeyword = whereKeyword;
			this.AdjustFlagsAndWidth(condition);
			this.condition = condition;
		}


		public WhereClauseSyntax(SyntaxKind kind, SyntaxToken whereKeyword, ExpressionSyntax condition)
			: base(kind)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(whereKeyword);
			this.whereKeyword = whereKeyword;
			this.AdjustFlagsAndWidth(condition);
			this.condition = condition;
		}

		public SyntaxToken WhereKeyword { get { return this.whereKeyword; } }
		public ExpressionSyntax Condition { get { return this.condition; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.whereKeyword;
				case 1: return this.condition;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitWhereClause(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitWhereClause(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new WhereClauseSyntax(this.Kind, this.whereKeyword, this.condition, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new WhereClauseSyntax(this.Kind, this.whereKeyword, this.condition, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class OrderByClauseSyntax : QueryClauseSyntax
	{
		public readonly SyntaxToken orderByKeyword;
		public readonly GreenNode orderings;

		public OrderByClauseSyntax(SyntaxKind kind, SyntaxToken orderByKeyword, GreenNode orderings, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(orderByKeyword);
			this.orderByKeyword = orderByKeyword;
			if (orderings != null)
			{
				this.AdjustFlagsAndWidth(orderings);
				this.orderings = orderings;
			}
		}


		public OrderByClauseSyntax(SyntaxKind kind, SyntaxToken orderByKeyword, GreenNode orderings, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(orderByKeyword);
			this.orderByKeyword = orderByKeyword;
			if (orderings != null)
			{
				this.AdjustFlagsAndWidth(orderings);
				this.orderings = orderings;
			}
		}


		public OrderByClauseSyntax(SyntaxKind kind, SyntaxToken orderByKeyword, GreenNode orderings)
			: base(kind)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(orderByKeyword);
			this.orderByKeyword = orderByKeyword;
			if (orderings != null)
			{
				this.AdjustFlagsAndWidth(orderings);
				this.orderings = orderings;
			}
		}

		public SyntaxToken OrderByKeyword { get { return this.orderByKeyword; } }
		public SeparatedSyntaxList<OrderingSyntax> Orderings { get { return new SeparatedSyntaxList<OrderingSyntax>(new SyntaxList<LeeSyntaxNode>(this.orderings)); } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.orderByKeyword;
				case 1: return this.orderings;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitOrderByClause(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitOrderByClause(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new OrderByClauseSyntax(this.Kind, this.orderByKeyword, this.orderings, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new OrderByClauseSyntax(this.Kind, this.orderByKeyword, this.orderings, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class OrderingSyntax : LeeSyntaxNode
	{
		public readonly ExpressionSyntax expression;
		public readonly SyntaxToken ascendingOrDescendingKeyword;

		public OrderingSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			if (ascendingOrDescendingKeyword != null)
			{
				this.AdjustFlagsAndWidth(ascendingOrDescendingKeyword);
				this.ascendingOrDescendingKeyword = ascendingOrDescendingKeyword;
			}
		}


		public OrderingSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			if (ascendingOrDescendingKeyword != null)
			{
				this.AdjustFlagsAndWidth(ascendingOrDescendingKeyword);
				this.ascendingOrDescendingKeyword = ascendingOrDescendingKeyword;
			}
		}


		public OrderingSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword)
			: base(kind)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			if (ascendingOrDescendingKeyword != null)
			{
				this.AdjustFlagsAndWidth(ascendingOrDescendingKeyword);
				this.ascendingOrDescendingKeyword = ascendingOrDescendingKeyword;
			}
		}

		public ExpressionSyntax Expression { get { return this.expression; } }
		public SyntaxToken AscendingOrDescendingKeyword { get { return this.ascendingOrDescendingKeyword; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.expression;
				case 1: return this.ascendingOrDescendingKeyword;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitOrdering(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitOrdering(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new OrderingSyntax(this.Kind, this.expression, this.ascendingOrDescendingKeyword, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new OrderingSyntax(this.Kind, this.expression, this.ascendingOrDescendingKeyword, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class SelectClauseSyntax : SelectOrGroupClauseSyntax
	{
		public readonly SyntaxToken selectKeyword;
		public readonly ExpressionSyntax expression;

		public SelectClauseSyntax(SyntaxKind kind, SyntaxToken selectKeyword, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(selectKeyword);
			this.selectKeyword = selectKeyword;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
		}


		public SelectClauseSyntax(SyntaxKind kind, SyntaxToken selectKeyword, ExpressionSyntax expression, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(selectKeyword);
			this.selectKeyword = selectKeyword;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
		}


		public SelectClauseSyntax(SyntaxKind kind, SyntaxToken selectKeyword, ExpressionSyntax expression)
			: base(kind)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(selectKeyword);
			this.selectKeyword = selectKeyword;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
		}

		public SyntaxToken SelectKeyword { get { return this.selectKeyword; } }
		public ExpressionSyntax Expression { get { return this.expression; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.selectKeyword;
				case 1: return this.expression;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitSelectClause(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitSelectClause(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new SelectClauseSyntax(this.Kind, this.selectKeyword, this.expression, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new SelectClauseSyntax(this.Kind, this.selectKeyword, this.expression, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class GroupClauseSyntax : SelectOrGroupClauseSyntax
	{
		public readonly SyntaxToken groupKeyword;
		public readonly ExpressionSyntax groupExpression;
		public readonly SyntaxToken byKeyword;
		public readonly ExpressionSyntax byExpression;

		public GroupClauseSyntax(SyntaxKind kind, SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(groupKeyword);
			this.groupKeyword = groupKeyword;
			this.AdjustFlagsAndWidth(groupExpression);
			this.groupExpression = groupExpression;
			this.AdjustFlagsAndWidth(byKeyword);
			this.byKeyword = byKeyword;
			this.AdjustFlagsAndWidth(byExpression);
			this.byExpression = byExpression;
		}


		public GroupClauseSyntax(SyntaxKind kind, SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(groupKeyword);
			this.groupKeyword = groupKeyword;
			this.AdjustFlagsAndWidth(groupExpression);
			this.groupExpression = groupExpression;
			this.AdjustFlagsAndWidth(byKeyword);
			this.byKeyword = byKeyword;
			this.AdjustFlagsAndWidth(byExpression);
			this.byExpression = byExpression;
		}


		public GroupClauseSyntax(SyntaxKind kind, SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression)
			: base(kind)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(groupKeyword);
			this.groupKeyword = groupKeyword;
			this.AdjustFlagsAndWidth(groupExpression);
			this.groupExpression = groupExpression;
			this.AdjustFlagsAndWidth(byKeyword);
			this.byKeyword = byKeyword;
			this.AdjustFlagsAndWidth(byExpression);
			this.byExpression = byExpression;
		}

		public SyntaxToken GroupKeyword { get { return this.groupKeyword; } }
		public ExpressionSyntax GroupExpression { get { return this.groupExpression; } }
		public SyntaxToken ByKeyword { get { return this.byKeyword; } }
		public ExpressionSyntax ByExpression { get { return this.byExpression; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.groupKeyword;
				case 1: return this.groupExpression;
				case 2: return this.byKeyword;
				case 3: return this.byExpression;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitGroupClause(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitGroupClause(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new GroupClauseSyntax(this.Kind, this.groupKeyword, this.groupExpression, this.byKeyword, this.byExpression, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new GroupClauseSyntax(this.Kind, this.groupKeyword, this.groupExpression, this.byKeyword, this.byExpression, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class QueryContinuationSyntax : LeeSyntaxNode
	{
		public readonly SyntaxToken intoKeyword;
		public readonly SyntaxToken identifier;
		public readonly QueryBodySyntax body;

		public QueryContinuationSyntax(SyntaxKind kind, SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(intoKeyword);
			this.intoKeyword = intoKeyword;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			this.AdjustFlagsAndWidth(body);
			this.body = body;
		}


		public QueryContinuationSyntax(SyntaxKind kind, SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(intoKeyword);
			this.intoKeyword = intoKeyword;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			this.AdjustFlagsAndWidth(body);
			this.body = body;
		}


		public QueryContinuationSyntax(SyntaxKind kind, SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(intoKeyword);
			this.intoKeyword = intoKeyword;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			this.AdjustFlagsAndWidth(body);
			this.body = body;
		}

		public SyntaxToken IntoKeyword { get { return this.intoKeyword; } }
		/// <summary>Gets the identifier.</summary>
		public SyntaxToken Identifier { get { return this.identifier; } }
		public QueryBodySyntax Body { get { return this.body; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.intoKeyword;
				case 1: return this.identifier;
				case 2: return this.body;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitQueryContinuation(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitQueryContinuation(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new QueryContinuationSyntax(this.Kind, this.intoKeyword, this.identifier, this.body, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new QueryContinuationSyntax(this.Kind, this.intoKeyword, this.identifier, this.body, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents a placeholder in an array size list.</summary>
	public sealed partial class OmittedArraySizeExpressionSyntax : ExpressionSyntax
	{
		public readonly SyntaxToken omittedArraySizeExpressionToken;

		public OmittedArraySizeExpressionSyntax(SyntaxKind kind, SyntaxToken omittedArraySizeExpressionToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(omittedArraySizeExpressionToken);
			this.omittedArraySizeExpressionToken = omittedArraySizeExpressionToken;
		}


		public OmittedArraySizeExpressionSyntax(SyntaxKind kind, SyntaxToken omittedArraySizeExpressionToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(omittedArraySizeExpressionToken);
			this.omittedArraySizeExpressionToken = omittedArraySizeExpressionToken;
		}


		public OmittedArraySizeExpressionSyntax(SyntaxKind kind, SyntaxToken omittedArraySizeExpressionToken)
			: base(kind)
		{
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(omittedArraySizeExpressionToken);
			this.omittedArraySizeExpressionToken = omittedArraySizeExpressionToken;
		}

		/// <summary>SyntaxToken representing the omitted array size expression.</summary>
		public SyntaxToken OmittedArraySizeExpressionToken { get { return this.omittedArraySizeExpressionToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.omittedArraySizeExpressionToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitOmittedArraySizeExpression(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitOmittedArraySizeExpression(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new OmittedArraySizeExpressionSyntax(this.Kind, this.omittedArraySizeExpressionToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new OmittedArraySizeExpressionSyntax(this.Kind, this.omittedArraySizeExpressionToken, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class InterpolatedStringExpressionSyntax : ExpressionSyntax
	{
		public readonly SyntaxToken stringStartToken;
		public readonly GreenNode contents;
		public readonly SyntaxToken stringEndToken;

		public InterpolatedStringExpressionSyntax(SyntaxKind kind, SyntaxToken stringStartToken, GreenNode contents, SyntaxToken stringEndToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(stringStartToken);
			this.stringStartToken = stringStartToken;
			if (contents != null)
			{
				this.AdjustFlagsAndWidth(contents);
				this.contents = contents;
			}
			this.AdjustFlagsAndWidth(stringEndToken);
			this.stringEndToken = stringEndToken;
		}


		public InterpolatedStringExpressionSyntax(SyntaxKind kind, SyntaxToken stringStartToken, GreenNode contents, SyntaxToken stringEndToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(stringStartToken);
			this.stringStartToken = stringStartToken;
			if (contents != null)
			{
				this.AdjustFlagsAndWidth(contents);
				this.contents = contents;
			}
			this.AdjustFlagsAndWidth(stringEndToken);
			this.stringEndToken = stringEndToken;
		}


		public InterpolatedStringExpressionSyntax(SyntaxKind kind, SyntaxToken stringStartToken, GreenNode contents, SyntaxToken stringEndToken)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(stringStartToken);
			this.stringStartToken = stringStartToken;
			if (contents != null)
			{
				this.AdjustFlagsAndWidth(contents);
				this.contents = contents;
			}
			this.AdjustFlagsAndWidth(stringEndToken);
			this.stringEndToken = stringEndToken;
		}

		/// <summary>The first part of an interpolated string, $" or $@"</summary>
		public SyntaxToken StringStartToken { get { return this.stringStartToken; } }
		/// <summary>List of parts of the interpolated string, each one is either a literal part or an interpolation.</summary>
		public SyntaxList<InterpolatedStringContentSyntax> Contents { get { return new SyntaxList<InterpolatedStringContentSyntax>(this.contents); } }
		/// <summary>The closing quote of the interpolated string.</summary>
		public SyntaxToken StringEndToken { get { return this.stringEndToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.stringStartToken;
				case 1: return this.contents;
				case 2: return this.stringEndToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitInterpolatedStringExpression(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitInterpolatedStringExpression(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new InterpolatedStringExpressionSyntax(this.Kind, this.stringStartToken, this.contents, this.stringEndToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new InterpolatedStringExpressionSyntax(this.Kind, this.stringStartToken, this.contents, this.stringEndToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class which represents a simple pattern-matching expression using the "is" keyword.</summary>
	public sealed partial class IsPatternExpressionSyntax : ExpressionSyntax
	{
		public readonly ExpressionSyntax expression;
		public readonly SyntaxToken isKeyword;
		public readonly PatternSyntax pattern;

		public IsPatternExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken isKeyword, PatternSyntax pattern, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			this.AdjustFlagsAndWidth(isKeyword);
			this.isKeyword = isKeyword;
			this.AdjustFlagsAndWidth(pattern);
			this.pattern = pattern;
		}


		public IsPatternExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken isKeyword, PatternSyntax pattern, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			this.AdjustFlagsAndWidth(isKeyword);
			this.isKeyword = isKeyword;
			this.AdjustFlagsAndWidth(pattern);
			this.pattern = pattern;
		}


		public IsPatternExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken isKeyword, PatternSyntax pattern)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			this.AdjustFlagsAndWidth(isKeyword);
			this.isKeyword = isKeyword;
			this.AdjustFlagsAndWidth(pattern);
			this.pattern = pattern;
		}

		/// <summary>ExpressionSyntax node representing the expression on the left of the "is" operator.</summary>
		public ExpressionSyntax Expression { get { return this.expression; } }
		public SyntaxToken IsKeyword { get { return this.isKeyword; } }
		/// <summary>PatternSyntax node representing the pattern on the right of the "is" operator.</summary>
		public PatternSyntax Pattern { get { return this.pattern; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.expression;
				case 1: return this.isKeyword;
				case 2: return this.pattern;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitIsPatternExpression(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitIsPatternExpression(this);
		}
		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new IsPatternExpressionSyntax(this.Kind, this.expression, this.isKeyword, this.pattern, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new IsPatternExpressionSyntax(this.Kind, this.expression, this.isKeyword, this.pattern, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class ThrowExpressionSyntax : ExpressionSyntax
	{
		public readonly SyntaxToken throwKeyword;
		public readonly ExpressionSyntax expression;

		public ThrowExpressionSyntax(SyntaxKind kind, SyntaxToken throwKeyword, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(throwKeyword);
			this.throwKeyword = throwKeyword;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
		}


		public ThrowExpressionSyntax(SyntaxKind kind, SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(throwKeyword);
			this.throwKeyword = throwKeyword;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
		}


		public ThrowExpressionSyntax(SyntaxKind kind, SyntaxToken throwKeyword, ExpressionSyntax expression)
			: base(kind)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(throwKeyword);
			this.throwKeyword = throwKeyword;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
		}

		public SyntaxToken ThrowKeyword { get { return this.throwKeyword; } }
		public ExpressionSyntax Expression { get { return this.expression; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.throwKeyword;
				case 1: return this.expression;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitThrowExpression(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitThrowExpression(this);
		}


		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new ThrowExpressionSyntax(this.Kind, this.throwKeyword, this.expression, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new ThrowExpressionSyntax(this.Kind, this.throwKeyword, this.expression, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class WhenClauseSyntax : LeeSyntaxNode
	{
		public readonly SyntaxToken whenKeyword;
		public readonly ExpressionSyntax condition;

		public WhenClauseSyntax(SyntaxKind kind, SyntaxToken whenKeyword, ExpressionSyntax condition, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(whenKeyword);
			this.whenKeyword = whenKeyword;
			this.AdjustFlagsAndWidth(condition);
			this.condition = condition;
		}


		public WhenClauseSyntax(SyntaxKind kind, SyntaxToken whenKeyword, ExpressionSyntax condition, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(whenKeyword);
			this.whenKeyword = whenKeyword;
			this.AdjustFlagsAndWidth(condition);
			this.condition = condition;
		}


		public WhenClauseSyntax(SyntaxKind kind, SyntaxToken whenKeyword, ExpressionSyntax condition)
			: base(kind)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(whenKeyword);
			this.whenKeyword = whenKeyword;
			this.AdjustFlagsAndWidth(condition);
			this.condition = condition;
		}

		public SyntaxToken WhenKeyword { get { return this.whenKeyword; } }
		public ExpressionSyntax Condition { get { return this.condition; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.whenKeyword;
				case 1: return this.condition;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitWhenClause(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitWhenClause(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new WhenClauseSyntax(this.Kind, this.whenKeyword, this.condition, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new WhenClauseSyntax(this.Kind, this.whenKeyword, this.condition, GetDiagnostics(), annotations);
		}
	}

	public abstract partial class PatternSyntax : LeeSyntaxNode
	{
		public PatternSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
		  : base(kind, diagnostics, annotations)
		{
		}
		public PatternSyntax(SyntaxKind kind)
		  : base(kind)
		{
		}
	}

	public sealed partial class DiscardPatternSyntax : PatternSyntax
	{
		public readonly SyntaxToken underscoreToken;

		public DiscardPatternSyntax(SyntaxKind kind, SyntaxToken underscoreToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(underscoreToken);
			this.underscoreToken = underscoreToken;
		}


		public DiscardPatternSyntax(SyntaxKind kind, SyntaxToken underscoreToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(underscoreToken);
			this.underscoreToken = underscoreToken;
		}


		public DiscardPatternSyntax(SyntaxKind kind, SyntaxToken underscoreToken)
			: base(kind)
		{
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(underscoreToken);
			this.underscoreToken = underscoreToken;
		}

		public SyntaxToken UnderscoreToken { get { return this.underscoreToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.underscoreToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitDiscardPattern(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitDiscardPattern(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new DiscardPatternSyntax(this.Kind, this.underscoreToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new DiscardPatternSyntax(this.Kind, this.underscoreToken, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class DeclarationPatternSyntax : PatternSyntax
	{
		public readonly TypeSyntax type;
		public readonly VariableDesignationSyntax designation;

		public DeclarationPatternSyntax(SyntaxKind kind, TypeSyntax type, VariableDesignationSyntax designation, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			this.AdjustFlagsAndWidth(designation);
			this.designation = designation;
		}


		public DeclarationPatternSyntax(SyntaxKind kind, TypeSyntax type, VariableDesignationSyntax designation, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			this.AdjustFlagsAndWidth(designation);
			this.designation = designation;
		}


		public DeclarationPatternSyntax(SyntaxKind kind, TypeSyntax type, VariableDesignationSyntax designation)
			: base(kind)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			this.AdjustFlagsAndWidth(designation);
			this.designation = designation;
		}

		public TypeSyntax Type { get { return this.type; } }
		public VariableDesignationSyntax Designation { get { return this.designation; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.type;
				case 1: return this.designation;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitDeclarationPattern(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitDeclarationPattern(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new DeclarationPatternSyntax(this.Kind, this.type, this.designation, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new DeclarationPatternSyntax(this.Kind, this.type, this.designation, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class VarPatternSyntax : PatternSyntax
	{
		public readonly SyntaxToken varKeyword;
		public readonly VariableDesignationSyntax designation;

		public VarPatternSyntax(SyntaxKind kind, SyntaxToken varKeyword, VariableDesignationSyntax designation, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(varKeyword);
			this.varKeyword = varKeyword;
			this.AdjustFlagsAndWidth(designation);
			this.designation = designation;
		}


		public VarPatternSyntax(SyntaxKind kind, SyntaxToken varKeyword, VariableDesignationSyntax designation, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(varKeyword);
			this.varKeyword = varKeyword;
			this.AdjustFlagsAndWidth(designation);
			this.designation = designation;
		}


		public VarPatternSyntax(SyntaxKind kind, SyntaxToken varKeyword, VariableDesignationSyntax designation)
			: base(kind)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(varKeyword);
			this.varKeyword = varKeyword;
			this.AdjustFlagsAndWidth(designation);
			this.designation = designation;
		}

		public SyntaxToken VarKeyword { get { return this.varKeyword; } }
		public VariableDesignationSyntax Designation { get { return this.designation; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.varKeyword;
				case 1: return this.designation;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitVarPattern(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitVarPattern(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new VarPatternSyntax(this.Kind, this.varKeyword, this.designation, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new VarPatternSyntax(this.Kind, this.varKeyword, this.designation, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class RecursivePatternSyntax : PatternSyntax
	{
		public readonly TypeSyntax type;
		public readonly PositionalPatternClauseSyntax positionalPatternClause;
		public readonly PropertyPatternClauseSyntax propertyPatternClause;
		public readonly VariableDesignationSyntax designation;

		public RecursivePatternSyntax(SyntaxKind kind, TypeSyntax type, PositionalPatternClauseSyntax positionalPatternClause, PropertyPatternClauseSyntax propertyPatternClause, VariableDesignationSyntax designation, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 4;
			if (type != null)
			{
				this.AdjustFlagsAndWidth(type);
				this.type = type;
			}
			if (positionalPatternClause != null)
			{
				this.AdjustFlagsAndWidth(positionalPatternClause);
				this.positionalPatternClause = positionalPatternClause;
			}
			if (propertyPatternClause != null)
			{
				this.AdjustFlagsAndWidth(propertyPatternClause);
				this.propertyPatternClause = propertyPatternClause;
			}
			if (designation != null)
			{
				this.AdjustFlagsAndWidth(designation);
				this.designation = designation;
			}
		}


		public RecursivePatternSyntax(SyntaxKind kind, TypeSyntax type, PositionalPatternClauseSyntax positionalPatternClause, PropertyPatternClauseSyntax propertyPatternClause, VariableDesignationSyntax designation, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 4;
			if (type != null)
			{
				this.AdjustFlagsAndWidth(type);
				this.type = type;
			}
			if (positionalPatternClause != null)
			{
				this.AdjustFlagsAndWidth(positionalPatternClause);
				this.positionalPatternClause = positionalPatternClause;
			}
			if (propertyPatternClause != null)
			{
				this.AdjustFlagsAndWidth(propertyPatternClause);
				this.propertyPatternClause = propertyPatternClause;
			}
			if (designation != null)
			{
				this.AdjustFlagsAndWidth(designation);
				this.designation = designation;
			}
		}


		public RecursivePatternSyntax(SyntaxKind kind, TypeSyntax type, PositionalPatternClauseSyntax positionalPatternClause, PropertyPatternClauseSyntax propertyPatternClause, VariableDesignationSyntax designation)
			: base(kind)
		{
			this.SlotCount = 4;
			if (type != null)
			{
				this.AdjustFlagsAndWidth(type);
				this.type = type;
			}
			if (positionalPatternClause != null)
			{
				this.AdjustFlagsAndWidth(positionalPatternClause);
				this.positionalPatternClause = positionalPatternClause;
			}
			if (propertyPatternClause != null)
			{
				this.AdjustFlagsAndWidth(propertyPatternClause);
				this.propertyPatternClause = propertyPatternClause;
			}
			if (designation != null)
			{
				this.AdjustFlagsAndWidth(designation);
				this.designation = designation;
			}
		}

		public TypeSyntax Type { get { return this.type; } }
		public PositionalPatternClauseSyntax PositionalPatternClause { get { return this.positionalPatternClause; } }
		public PropertyPatternClauseSyntax PropertyPatternClause { get { return this.propertyPatternClause; } }
		public VariableDesignationSyntax Designation { get { return this.designation; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.type;
				case 1: return this.positionalPatternClause;
				case 2: return this.propertyPatternClause;
				case 3: return this.designation;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitRecursivePattern(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitRecursivePattern(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new RecursivePatternSyntax(this.Kind, this.type, this.positionalPatternClause, this.propertyPatternClause, this.designation, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new RecursivePatternSyntax(this.Kind, this.type, this.positionalPatternClause, this.propertyPatternClause, this.designation, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class PositionalPatternClauseSyntax : LeeSyntaxNode
	{
		public readonly SyntaxToken openParenToken;
		public readonly GreenNode subpatterns;
		public readonly SyntaxToken closeParenToken;

		public PositionalPatternClauseSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode subpatterns, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			if (subpatterns != null)
			{
				this.AdjustFlagsAndWidth(subpatterns);
				this.subpatterns = subpatterns;
			}
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}


		public PositionalPatternClauseSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode subpatterns, SyntaxToken closeParenToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			if (subpatterns != null)
			{
				this.AdjustFlagsAndWidth(subpatterns);
				this.subpatterns = subpatterns;
			}
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}


		public PositionalPatternClauseSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode subpatterns, SyntaxToken closeParenToken)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			if (subpatterns != null)
			{
				this.AdjustFlagsAndWidth(subpatterns);
				this.subpatterns = subpatterns;
			}
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}

		public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
		public SeparatedSyntaxList<SubpatternSyntax> Subpatterns { get { return new SeparatedSyntaxList<SubpatternSyntax>(new SyntaxList<LeeSyntaxNode>(this.subpatterns)); } }
		public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.openParenToken;
				case 1: return this.subpatterns;
				case 2: return this.closeParenToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitPositionalPatternClause(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitPositionalPatternClause(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new PositionalPatternClauseSyntax(this.Kind, this.openParenToken, this.subpatterns, this.closeParenToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new PositionalPatternClauseSyntax(this.Kind, this.openParenToken, this.subpatterns, this.closeParenToken, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class PropertyPatternClauseSyntax : LeeSyntaxNode
	{
		public readonly SyntaxToken openBraceToken;
		public readonly GreenNode subpatterns;
		public readonly SyntaxToken closeBraceToken;

		public PropertyPatternClauseSyntax(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode subpatterns, SyntaxToken closeBraceToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openBraceToken);
			this.openBraceToken = openBraceToken;
			if (subpatterns != null)
			{
				this.AdjustFlagsAndWidth(subpatterns);
				this.subpatterns = subpatterns;
			}
			this.AdjustFlagsAndWidth(closeBraceToken);
			this.closeBraceToken = closeBraceToken;
		}


		public PropertyPatternClauseSyntax(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode subpatterns, SyntaxToken closeBraceToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openBraceToken);
			this.openBraceToken = openBraceToken;
			if (subpatterns != null)
			{
				this.AdjustFlagsAndWidth(subpatterns);
				this.subpatterns = subpatterns;
			}
			this.AdjustFlagsAndWidth(closeBraceToken);
			this.closeBraceToken = closeBraceToken;
		}


		public PropertyPatternClauseSyntax(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode subpatterns, SyntaxToken closeBraceToken)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openBraceToken);
			this.openBraceToken = openBraceToken;
			if (subpatterns != null)
			{
				this.AdjustFlagsAndWidth(subpatterns);
				this.subpatterns = subpatterns;
			}
			this.AdjustFlagsAndWidth(closeBraceToken);
			this.closeBraceToken = closeBraceToken;
		}

		public SyntaxToken OpenBraceToken { get { return this.openBraceToken; } }
		public SeparatedSyntaxList<SubpatternSyntax> Subpatterns { get { return new SeparatedSyntaxList<SubpatternSyntax>(new SyntaxList<LeeSyntaxNode>(this.subpatterns)); } }
		public SyntaxToken CloseBraceToken { get { return this.closeBraceToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.openBraceToken;
				case 1: return this.subpatterns;
				case 2: return this.closeBraceToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitPropertyPatternClause(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitPropertyPatternClause(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new PropertyPatternClauseSyntax(this.Kind, this.openBraceToken, this.subpatterns, this.closeBraceToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new PropertyPatternClauseSyntax(this.Kind, this.openBraceToken, this.subpatterns, this.closeBraceToken, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class SubpatternSyntax : LeeSyntaxNode
	{
		public readonly NameColonSyntax nameColon;
		public readonly PatternSyntax pattern;

		public SubpatternSyntax(SyntaxKind kind, NameColonSyntax nameColon, PatternSyntax pattern, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			if (nameColon != null)
			{
				this.AdjustFlagsAndWidth(nameColon);
				this.nameColon = nameColon;
			}
			this.AdjustFlagsAndWidth(pattern);
			this.pattern = pattern;
		}


		public SubpatternSyntax(SyntaxKind kind, NameColonSyntax nameColon, PatternSyntax pattern, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			if (nameColon != null)
			{
				this.AdjustFlagsAndWidth(nameColon);
				this.nameColon = nameColon;
			}
			this.AdjustFlagsAndWidth(pattern);
			this.pattern = pattern;
		}


		public SubpatternSyntax(SyntaxKind kind, NameColonSyntax nameColon, PatternSyntax pattern)
			: base(kind)
		{
			this.SlotCount = 2;
			if (nameColon != null)
			{
				this.AdjustFlagsAndWidth(nameColon);
				this.nameColon = nameColon;
			}
			this.AdjustFlagsAndWidth(pattern);
			this.pattern = pattern;
		}

		public NameColonSyntax NameColon { get { return this.nameColon; } }
		public PatternSyntax Pattern { get { return this.pattern; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.nameColon;
				case 1: return this.pattern;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitSubpattern(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitSubpattern(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new SubpatternSyntax(this.Kind, this.nameColon, this.pattern, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new SubpatternSyntax(this.Kind, this.nameColon, this.pattern, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class ConstantPatternSyntax : PatternSyntax
	{
		public readonly ExpressionSyntax expression;

		public ConstantPatternSyntax(SyntaxKind kind, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
		}


		public ConstantPatternSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
		}


		public ConstantPatternSyntax(SyntaxKind kind, ExpressionSyntax expression)
			: base(kind)
		{
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
		}

		/// <summary>ExpressionSyntax node representing the constant expression.</summary>
		public ExpressionSyntax Expression { get { return this.expression; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.expression;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitConstantPattern(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitConstantPattern(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new ConstantPatternSyntax(this.Kind, this.expression, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new ConstantPatternSyntax(this.Kind, this.expression, GetDiagnostics(), annotations);
		}
	}

	public abstract partial class InterpolatedStringContentSyntax : LeeSyntaxNode
	{
		public InterpolatedStringContentSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
		  : base(kind, diagnostics, annotations)
		{
		}
		public InterpolatedStringContentSyntax(SyntaxKind kind)
		  : base(kind)
		{
		}
	}

	public sealed partial class InterpolatedStringTextSyntax : InterpolatedStringContentSyntax
	{
		public readonly SyntaxToken textToken;

		public InterpolatedStringTextSyntax(SyntaxKind kind, SyntaxToken textToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(textToken);
			this.textToken = textToken;
		}


		public InterpolatedStringTextSyntax(SyntaxKind kind, SyntaxToken textToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(textToken);
			this.textToken = textToken;
		}


		public InterpolatedStringTextSyntax(SyntaxKind kind, SyntaxToken textToken)
			: base(kind)
		{
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(textToken);
			this.textToken = textToken;
		}

		/// <summary>The text contents of a part of the interpolated string.</summary>
		public SyntaxToken TextToken { get { return this.textToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.textToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitInterpolatedStringText(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitInterpolatedStringText(this);
		}
		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new InterpolatedStringTextSyntax(this.Kind, this.textToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new InterpolatedStringTextSyntax(this.Kind, this.textToken, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class InterpolationSyntax : InterpolatedStringContentSyntax
	{
		public readonly SyntaxToken openBraceToken;
		public readonly ExpressionSyntax expression;
		public readonly InterpolationAlignmentClauseSyntax alignmentClause;
		public readonly InterpolationFormatClauseSyntax formatClause;
		public readonly SyntaxToken closeBraceToken;

		public InterpolationSyntax(SyntaxKind kind, SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, SyntaxToken closeBraceToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 5;
			this.AdjustFlagsAndWidth(openBraceToken);
			this.openBraceToken = openBraceToken;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			if (alignmentClause != null)
			{
				this.AdjustFlagsAndWidth(alignmentClause);
				this.alignmentClause = alignmentClause;
			}
			if (formatClause != null)
			{
				this.AdjustFlagsAndWidth(formatClause);
				this.formatClause = formatClause;
			}
			this.AdjustFlagsAndWidth(closeBraceToken);
			this.closeBraceToken = closeBraceToken;
		}


		public InterpolationSyntax(SyntaxKind kind, SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, SyntaxToken closeBraceToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 5;
			this.AdjustFlagsAndWidth(openBraceToken);
			this.openBraceToken = openBraceToken;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			if (alignmentClause != null)
			{
				this.AdjustFlagsAndWidth(alignmentClause);
				this.alignmentClause = alignmentClause;
			}
			if (formatClause != null)
			{
				this.AdjustFlagsAndWidth(formatClause);
				this.formatClause = formatClause;
			}
			this.AdjustFlagsAndWidth(closeBraceToken);
			this.closeBraceToken = closeBraceToken;
		}


		public InterpolationSyntax(SyntaxKind kind, SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, SyntaxToken closeBraceToken)
			: base(kind)
		{
			this.SlotCount = 5;
			this.AdjustFlagsAndWidth(openBraceToken);
			this.openBraceToken = openBraceToken;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			if (alignmentClause != null)
			{
				this.AdjustFlagsAndWidth(alignmentClause);
				this.alignmentClause = alignmentClause;
			}
			if (formatClause != null)
			{
				this.AdjustFlagsAndWidth(formatClause);
				this.formatClause = formatClause;
			}
			this.AdjustFlagsAndWidth(closeBraceToken);
			this.closeBraceToken = closeBraceToken;
		}

		public SyntaxToken OpenBraceToken { get { return this.openBraceToken; } }
		public ExpressionSyntax Expression { get { return this.expression; } }
		public InterpolationAlignmentClauseSyntax AlignmentClause { get { return this.alignmentClause; } }
		public InterpolationFormatClauseSyntax FormatClause { get { return this.formatClause; } }
		public SyntaxToken CloseBraceToken { get { return this.closeBraceToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.openBraceToken;
				case 1: return this.expression;
				case 2: return this.alignmentClause;
				case 3: return this.formatClause;
				case 4: return this.closeBraceToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitInterpolation(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitInterpolation(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new InterpolationSyntax(this.Kind, this.openBraceToken, this.expression, this.alignmentClause, this.formatClause, this.closeBraceToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new InterpolationSyntax(this.Kind, this.openBraceToken, this.expression, this.alignmentClause, this.formatClause, this.closeBraceToken, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class InterpolationAlignmentClauseSyntax : LeeSyntaxNode
	{
		public readonly SyntaxToken commaToken;
		public readonly ExpressionSyntax value;

		public InterpolationAlignmentClauseSyntax(SyntaxKind kind, SyntaxToken commaToken, ExpressionSyntax value, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(commaToken);
			this.commaToken = commaToken;
			this.AdjustFlagsAndWidth(value);
			this.value = value;
		}


		public InterpolationAlignmentClauseSyntax(SyntaxKind kind, SyntaxToken commaToken, ExpressionSyntax value, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(commaToken);
			this.commaToken = commaToken;
			this.AdjustFlagsAndWidth(value);
			this.value = value;
		}


		public InterpolationAlignmentClauseSyntax(SyntaxKind kind, SyntaxToken commaToken, ExpressionSyntax value)
			: base(kind)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(commaToken);
			this.commaToken = commaToken;
			this.AdjustFlagsAndWidth(value);
			this.value = value;
		}

		public SyntaxToken CommaToken { get { return this.commaToken; } }
		public ExpressionSyntax Value { get { return this.value; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.commaToken;
				case 1: return this.value;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitInterpolationAlignmentClause(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitInterpolationAlignmentClause(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new InterpolationAlignmentClauseSyntax(this.Kind, this.commaToken, this.value, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new InterpolationAlignmentClauseSyntax(this.Kind, this.commaToken, this.value, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class InterpolationFormatClauseSyntax : LeeSyntaxNode
	{
		public readonly SyntaxToken colonToken;
		public readonly SyntaxToken formatStringToken;

		public InterpolationFormatClauseSyntax(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken formatStringToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(colonToken);
			this.colonToken = colonToken;
			this.AdjustFlagsAndWidth(formatStringToken);
			this.formatStringToken = formatStringToken;
		}


		public InterpolationFormatClauseSyntax(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken formatStringToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(colonToken);
			this.colonToken = colonToken;
			this.AdjustFlagsAndWidth(formatStringToken);
			this.formatStringToken = formatStringToken;
		}


		public InterpolationFormatClauseSyntax(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken formatStringToken)
			: base(kind)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(colonToken);
			this.colonToken = colonToken;
			this.AdjustFlagsAndWidth(formatStringToken);
			this.formatStringToken = formatStringToken;
		}

		public SyntaxToken ColonToken { get { return this.colonToken; } }
		/// <summary>The text contents of the format specifier for an interpolation.</summary>
		public SyntaxToken FormatStringToken { get { return this.formatStringToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.colonToken;
				case 1: return this.formatStringToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitInterpolationFormatClause(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitInterpolationFormatClause(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new InterpolationFormatClauseSyntax(this.Kind, this.colonToken, this.formatStringToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new InterpolationFormatClauseSyntax(this.Kind, this.colonToken, this.formatStringToken, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class GlobalStatementSyntax : MemberDeclarationSyntax
	{
		public readonly StatementSyntax statement;

		public GlobalStatementSyntax(SyntaxKind kind, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(statement);
			this.statement = statement;
		}


		public GlobalStatementSyntax(SyntaxKind kind, StatementSyntax statement, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(statement);
			this.statement = statement;
		}


		public GlobalStatementSyntax(SyntaxKind kind, StatementSyntax statement)
			: base(kind)
		{
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(statement);
			this.statement = statement;
		}

		public StatementSyntax Statement { get { return this.statement; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.statement;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitGlobalStatement(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitGlobalStatement(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new GlobalStatementSyntax(this.Kind, this.statement, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new GlobalStatementSyntax(this.Kind, this.statement, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Represents the base class for all statements syntax classes.</summary>
	public abstract partial class StatementSyntax : LeeSyntaxNode
	{
		public StatementSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
		  : base(kind, diagnostics, annotations)
		{
		}
		public StatementSyntax(SyntaxKind kind)
		  : base(kind)
		{
		}
	}

	public sealed partial class BlockSyntax : StatementSyntax
	{
		public readonly SyntaxToken openBraceToken;
		public readonly GreenNode statements;
		public readonly SyntaxToken closeBraceToken;

		public BlockSyntax(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode statements, SyntaxToken closeBraceToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openBraceToken);
			this.openBraceToken = openBraceToken;
			if (statements != null)
			{
				this.AdjustFlagsAndWidth(statements);
				this.statements = statements;
			}
			this.AdjustFlagsAndWidth(closeBraceToken);
			this.closeBraceToken = closeBraceToken;
		}


		public BlockSyntax(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode statements, SyntaxToken closeBraceToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openBraceToken);
			this.openBraceToken = openBraceToken;
			if (statements != null)
			{
				this.AdjustFlagsAndWidth(statements);
				this.statements = statements;
			}
			this.AdjustFlagsAndWidth(closeBraceToken);
			this.closeBraceToken = closeBraceToken;
		}


		public BlockSyntax(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode statements, SyntaxToken closeBraceToken)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openBraceToken);
			this.openBraceToken = openBraceToken;
			if (statements != null)
			{
				this.AdjustFlagsAndWidth(statements);
				this.statements = statements;
			}
			this.AdjustFlagsAndWidth(closeBraceToken);
			this.closeBraceToken = closeBraceToken;
		}

		public SyntaxToken OpenBraceToken { get { return this.openBraceToken; } }
		public SyntaxList<StatementSyntax> Statements { get { return new SyntaxList<StatementSyntax>(this.statements); } }
		public SyntaxToken CloseBraceToken { get { return this.closeBraceToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.openBraceToken;
				case 1: return this.statements;
				case 2: return this.closeBraceToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitBlock(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitBlock(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new BlockSyntax(this.Kind, this.openBraceToken, this.statements, this.closeBraceToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new BlockSyntax(this.Kind, this.openBraceToken, this.statements, this.closeBraceToken, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class LocalFunctionStatementSyntax : StatementSyntax
	{
		public readonly GreenNode modifiers;
		public readonly TypeSyntax returnType;
		public readonly SyntaxToken identifier;
		public readonly TypeParameterListSyntax typeParameterList;
		public readonly ParameterListSyntax parameterList;
		public readonly GreenNode constraintClauses;
		public readonly BlockSyntax body;
		public readonly ArrowExpressionClauseSyntax expressionBody;
		public readonly SyntaxToken semicolonToken;

		public LocalFunctionStatementSyntax(SyntaxKind kind, GreenNode modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, GreenNode constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 9;
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(returnType);
			this.returnType = returnType;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			if (typeParameterList != null)
			{
				this.AdjustFlagsAndWidth(typeParameterList);
				this.typeParameterList = typeParameterList;
			}
			this.AdjustFlagsAndWidth(parameterList);
			this.parameterList = parameterList;
			if (constraintClauses != null)
			{
				this.AdjustFlagsAndWidth(constraintClauses);
				this.constraintClauses = constraintClauses;
			}
			if (body != null)
			{
				this.AdjustFlagsAndWidth(body);
				this.body = body;
			}
			if (expressionBody != null)
			{
				this.AdjustFlagsAndWidth(expressionBody);
				this.expressionBody = expressionBody;
			}
			if (semicolonToken != null)
			{
				this.AdjustFlagsAndWidth(semicolonToken);
				this.semicolonToken = semicolonToken;
			}
		}


		public LocalFunctionStatementSyntax(SyntaxKind kind, GreenNode modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, GreenNode constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 9;
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(returnType);
			this.returnType = returnType;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			if (typeParameterList != null)
			{
				this.AdjustFlagsAndWidth(typeParameterList);
				this.typeParameterList = typeParameterList;
			}
			this.AdjustFlagsAndWidth(parameterList);
			this.parameterList = parameterList;
			if (constraintClauses != null)
			{
				this.AdjustFlagsAndWidth(constraintClauses);
				this.constraintClauses = constraintClauses;
			}
			if (body != null)
			{
				this.AdjustFlagsAndWidth(body);
				this.body = body;
			}
			if (expressionBody != null)
			{
				this.AdjustFlagsAndWidth(expressionBody);
				this.expressionBody = expressionBody;
			}
			if (semicolonToken != null)
			{
				this.AdjustFlagsAndWidth(semicolonToken);
				this.semicolonToken = semicolonToken;
			}
		}


		public LocalFunctionStatementSyntax(SyntaxKind kind, GreenNode modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, GreenNode constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
			: base(kind)
		{
			this.SlotCount = 9;
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(returnType);
			this.returnType = returnType;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			if (typeParameterList != null)
			{
				this.AdjustFlagsAndWidth(typeParameterList);
				this.typeParameterList = typeParameterList;
			}
			this.AdjustFlagsAndWidth(parameterList);
			this.parameterList = parameterList;
			if (constraintClauses != null)
			{
				this.AdjustFlagsAndWidth(constraintClauses);
				this.constraintClauses = constraintClauses;
			}
			if (body != null)
			{
				this.AdjustFlagsAndWidth(body);
				this.body = body;
			}
			if (expressionBody != null)
			{
				this.AdjustFlagsAndWidth(expressionBody);
				this.expressionBody = expressionBody;
			}
			if (semicolonToken != null)
			{
				this.AdjustFlagsAndWidth(semicolonToken);
				this.semicolonToken = semicolonToken;
			}
		}

		public SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
		public TypeSyntax ReturnType { get { return this.returnType; } }
		/// <summary>Gets the identifier.</summary>
		public SyntaxToken Identifier { get { return this.identifier; } }
		public TypeParameterListSyntax TypeParameterList { get { return this.typeParameterList; } }
		public ParameterListSyntax ParameterList { get { return this.parameterList; } }
		public SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get { return new SyntaxList<TypeParameterConstraintClauseSyntax>(this.constraintClauses); } }
		public BlockSyntax Body { get { return this.body; } }
		public ArrowExpressionClauseSyntax ExpressionBody { get { return this.expressionBody; } }
		/// <summary>Gets the optional semicolon token.</summary>
		public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.modifiers;
				case 1: return this.returnType;
				case 2: return this.identifier;
				case 3: return this.typeParameterList;
				case 4: return this.parameterList;
				case 5: return this.constraintClauses;
				case 6: return this.body;
				case 7: return this.expressionBody;
				case 8: return this.semicolonToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitLocalFunctionStatement(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitLocalFunctionStatement(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new LocalFunctionStatementSyntax(this.Kind, this.modifiers, this.returnType, this.identifier, this.typeParameterList, this.parameterList, this.constraintClauses, this.body, this.expressionBody, this.semicolonToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new LocalFunctionStatementSyntax(this.Kind, this.modifiers, this.returnType, this.identifier, this.typeParameterList, this.parameterList, this.constraintClauses, this.body, this.expressionBody, this.semicolonToken, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class LocalDeclarationStatementSyntax : StatementSyntax
	{
		public readonly SyntaxToken awaitKeyword;
		public readonly SyntaxToken usingKeyword;
		public readonly GreenNode modifiers;
		public readonly VariableDeclarationSyntax declaration;
		public readonly SyntaxToken semicolonToken;

		public LocalDeclarationStatementSyntax(SyntaxKind kind, SyntaxToken awaitKeyword, SyntaxToken usingKeyword, GreenNode modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 5;
			if (awaitKeyword != null)
			{
				this.AdjustFlagsAndWidth(awaitKeyword);
				this.awaitKeyword = awaitKeyword;
			}
			if (usingKeyword != null)
			{
				this.AdjustFlagsAndWidth(usingKeyword);
				this.usingKeyword = usingKeyword;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(declaration);
			this.declaration = declaration;
			this.AdjustFlagsAndWidth(semicolonToken);
			this.semicolonToken = semicolonToken;
		}


		public LocalDeclarationStatementSyntax(SyntaxKind kind, SyntaxToken awaitKeyword, SyntaxToken usingKeyword, GreenNode modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 5;
			if (awaitKeyword != null)
			{
				this.AdjustFlagsAndWidth(awaitKeyword);
				this.awaitKeyword = awaitKeyword;
			}
			if (usingKeyword != null)
			{
				this.AdjustFlagsAndWidth(usingKeyword);
				this.usingKeyword = usingKeyword;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(declaration);
			this.declaration = declaration;
			this.AdjustFlagsAndWidth(semicolonToken);
			this.semicolonToken = semicolonToken;
		}


		public LocalDeclarationStatementSyntax(SyntaxKind kind, SyntaxToken awaitKeyword, SyntaxToken usingKeyword, GreenNode modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
			: base(kind)
		{
			this.SlotCount = 5;
			if (awaitKeyword != null)
			{
				this.AdjustFlagsAndWidth(awaitKeyword);
				this.awaitKeyword = awaitKeyword;
			}
			if (usingKeyword != null)
			{
				this.AdjustFlagsAndWidth(usingKeyword);
				this.usingKeyword = usingKeyword;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(declaration);
			this.declaration = declaration;
			this.AdjustFlagsAndWidth(semicolonToken);
			this.semicolonToken = semicolonToken;
		}

		public SyntaxToken AwaitKeyword { get { return this.awaitKeyword; } }
		public SyntaxToken UsingKeyword { get { return this.usingKeyword; } }
		/// <summary>Gets the modifier list.</summary>
		public SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
		public VariableDeclarationSyntax Declaration { get { return this.declaration; } }
		public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.awaitKeyword;
				case 1: return this.usingKeyword;
				case 2: return this.modifiers;
				case 3: return this.declaration;
				case 4: return this.semicolonToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitLocalDeclarationStatement(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitLocalDeclarationStatement(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new LocalDeclarationStatementSyntax(this.Kind, this.awaitKeyword, this.usingKeyword, this.modifiers, this.declaration, this.semicolonToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new LocalDeclarationStatementSyntax(this.Kind, this.awaitKeyword, this.usingKeyword, this.modifiers, this.declaration, this.semicolonToken, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class VariableDeclarationSyntax : LeeSyntaxNode
	{
		public readonly TypeSyntax type;
		public readonly GreenNode variables;

		public VariableDeclarationSyntax(SyntaxKind kind, TypeSyntax type, GreenNode variables, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			if (variables != null)
			{
				this.AdjustFlagsAndWidth(variables);
				this.variables = variables;
			}
		}


		public VariableDeclarationSyntax(SyntaxKind kind, TypeSyntax type, GreenNode variables, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			if (variables != null)
			{
				this.AdjustFlagsAndWidth(variables);
				this.variables = variables;
			}
		}


		public VariableDeclarationSyntax(SyntaxKind kind, TypeSyntax type, GreenNode variables)
			: base(kind)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			if (variables != null)
			{
				this.AdjustFlagsAndWidth(variables);
				this.variables = variables;
			}
		}

		public TypeSyntax Type { get { return this.type; } }
		public SeparatedSyntaxList<VariableDeclaratorSyntax> Variables { get { return new SeparatedSyntaxList<VariableDeclaratorSyntax>(new SyntaxList<LeeSyntaxNode>(this.variables)); } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.type;
				case 1: return this.variables;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitVariableDeclaration(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitVariableDeclaration(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new VariableDeclarationSyntax(this.Kind, this.type, this.variables, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new VariableDeclarationSyntax(this.Kind, this.type, this.variables, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class VariableDeclaratorSyntax : LeeSyntaxNode
	{
		public readonly SyntaxToken identifier;
		public readonly BracketedArgumentListSyntax argumentList;
		public readonly EqualsValueClauseSyntax initializer;

		public VariableDeclaratorSyntax(SyntaxKind kind, SyntaxToken identifier, BracketedArgumentListSyntax argumentList, EqualsValueClauseSyntax initializer, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			if (argumentList != null)
			{
				this.AdjustFlagsAndWidth(argumentList);
				this.argumentList = argumentList;
			}
			if (initializer != null)
			{
				this.AdjustFlagsAndWidth(initializer);
				this.initializer = initializer;
			}
		}


		public VariableDeclaratorSyntax(SyntaxKind kind, SyntaxToken identifier, BracketedArgumentListSyntax argumentList, EqualsValueClauseSyntax initializer, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			if (argumentList != null)
			{
				this.AdjustFlagsAndWidth(argumentList);
				this.argumentList = argumentList;
			}
			if (initializer != null)
			{
				this.AdjustFlagsAndWidth(initializer);
				this.initializer = initializer;
			}
		}


		public VariableDeclaratorSyntax(SyntaxKind kind, SyntaxToken identifier, BracketedArgumentListSyntax argumentList, EqualsValueClauseSyntax initializer)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			if (argumentList != null)
			{
				this.AdjustFlagsAndWidth(argumentList);
				this.argumentList = argumentList;
			}
			if (initializer != null)
			{
				this.AdjustFlagsAndWidth(initializer);
				this.initializer = initializer;
			}
		}

		/// <summary>Gets the identifier.</summary>
		public SyntaxToken Identifier { get { return this.identifier; } }
		public BracketedArgumentListSyntax ArgumentList { get { return this.argumentList; } }
		public EqualsValueClauseSyntax Initializer { get { return this.initializer; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.identifier;
				case 1: return this.argumentList;
				case 2: return this.initializer;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitVariableDeclarator(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitVariableDeclarator(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new VariableDeclaratorSyntax(this.Kind, this.identifier, this.argumentList, this.initializer, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new VariableDeclaratorSyntax(this.Kind, this.identifier, this.argumentList, this.initializer, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class EqualsValueClauseSyntax : LeeSyntaxNode
	{
		public readonly SyntaxToken equalsToken;
		public readonly ExpressionSyntax value;

		public EqualsValueClauseSyntax(SyntaxKind kind, SyntaxToken equalsToken, ExpressionSyntax value, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(equalsToken);
			this.equalsToken = equalsToken;
			this.AdjustFlagsAndWidth(value);
			this.value = value;
		}


		public EqualsValueClauseSyntax(SyntaxKind kind, SyntaxToken equalsToken, ExpressionSyntax value, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(equalsToken);
			this.equalsToken = equalsToken;
			this.AdjustFlagsAndWidth(value);
			this.value = value;
		}


		public EqualsValueClauseSyntax(SyntaxKind kind, SyntaxToken equalsToken, ExpressionSyntax value)
			: base(kind)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(equalsToken);
			this.equalsToken = equalsToken;
			this.AdjustFlagsAndWidth(value);
			this.value = value;
		}

		public SyntaxToken EqualsToken { get { return this.equalsToken; } }
		public ExpressionSyntax Value { get { return this.value; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.equalsToken;
				case 1: return this.value;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitEqualsValueClause(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitEqualsValueClause(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new EqualsValueClauseSyntax(this.Kind, this.equalsToken, this.value, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new EqualsValueClauseSyntax(this.Kind, this.equalsToken, this.value, GetDiagnostics(), annotations);
		}
	}

	public abstract partial class VariableDesignationSyntax : LeeSyntaxNode
	{
		public VariableDesignationSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
		  : base(kind, diagnostics, annotations)
		{
		}
		public VariableDesignationSyntax(SyntaxKind kind)
		  : base(kind)
		{
		}
	}

	public sealed partial class SingleVariableDesignationSyntax : VariableDesignationSyntax
	{
		public readonly SyntaxToken identifier;

		public SingleVariableDesignationSyntax(SyntaxKind kind, SyntaxToken identifier, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
		}


		public SingleVariableDesignationSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
		}


		public SingleVariableDesignationSyntax(SyntaxKind kind, SyntaxToken identifier)
			: base(kind)
		{
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
		}

		public SyntaxToken Identifier { get { return this.identifier; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.identifier;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitSingleVariableDesignation(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitSingleVariableDesignation(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new SingleVariableDesignationSyntax(this.Kind, this.identifier, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new SingleVariableDesignationSyntax(this.Kind, this.identifier, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class DiscardDesignationSyntax : VariableDesignationSyntax
	{
		public readonly SyntaxToken underscoreToken;

		public DiscardDesignationSyntax(SyntaxKind kind, SyntaxToken underscoreToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(underscoreToken);
			this.underscoreToken = underscoreToken;
		}


		public DiscardDesignationSyntax(SyntaxKind kind, SyntaxToken underscoreToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(underscoreToken);
			this.underscoreToken = underscoreToken;
		}


		public DiscardDesignationSyntax(SyntaxKind kind, SyntaxToken underscoreToken)
			: base(kind)
		{
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(underscoreToken);
			this.underscoreToken = underscoreToken;
		}

		public SyntaxToken UnderscoreToken { get { return this.underscoreToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.underscoreToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitDiscardDesignation(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitDiscardDesignation(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new DiscardDesignationSyntax(this.Kind, this.underscoreToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new DiscardDesignationSyntax(this.Kind, this.underscoreToken, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class ParenthesizedVariableDesignationSyntax : VariableDesignationSyntax
	{
		public readonly SyntaxToken openParenToken;
		public readonly GreenNode variables;
		public readonly SyntaxToken closeParenToken;

		public ParenthesizedVariableDesignationSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode variables, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			if (variables != null)
			{
				this.AdjustFlagsAndWidth(variables);
				this.variables = variables;
			}
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}


		public ParenthesizedVariableDesignationSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode variables, SyntaxToken closeParenToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			if (variables != null)
			{
				this.AdjustFlagsAndWidth(variables);
				this.variables = variables;
			}
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}


		public ParenthesizedVariableDesignationSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode variables, SyntaxToken closeParenToken)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			if (variables != null)
			{
				this.AdjustFlagsAndWidth(variables);
				this.variables = variables;
			}
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}

		public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
		public SeparatedSyntaxList<VariableDesignationSyntax> Variables { get { return new SeparatedSyntaxList<VariableDesignationSyntax>(new SyntaxList<LeeSyntaxNode>(this.variables)); } }
		public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.openParenToken;
				case 1: return this.variables;
				case 2: return this.closeParenToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitParenthesizedVariableDesignation(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitParenthesizedVariableDesignation(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new ParenthesizedVariableDesignationSyntax(this.Kind, this.openParenToken, this.variables, this.closeParenToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new ParenthesizedVariableDesignationSyntax(this.Kind, this.openParenToken, this.variables, this.closeParenToken, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class ExpressionStatementSyntax : StatementSyntax
	{
		public readonly ExpressionSyntax expression;
		public readonly SyntaxToken semicolonToken;

		public ExpressionStatementSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			this.AdjustFlagsAndWidth(semicolonToken);
			this.semicolonToken = semicolonToken;
		}


		public ExpressionStatementSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken semicolonToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			this.AdjustFlagsAndWidth(semicolonToken);
			this.semicolonToken = semicolonToken;
		}


		public ExpressionStatementSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken semicolonToken)
			: base(kind)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			this.AdjustFlagsAndWidth(semicolonToken);
			this.semicolonToken = semicolonToken;
		}

		public ExpressionSyntax Expression { get { return this.expression; } }
		public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.expression;
				case 1: return this.semicolonToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitExpressionStatement(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitExpressionStatement(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new ExpressionStatementSyntax(this.Kind, this.expression, this.semicolonToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new ExpressionStatementSyntax(this.Kind, this.expression, this.semicolonToken, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class EmptyStatementSyntax : StatementSyntax
	{
		public readonly SyntaxToken semicolonToken;

		public EmptyStatementSyntax(SyntaxKind kind, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(semicolonToken);
			this.semicolonToken = semicolonToken;
		}


		public EmptyStatementSyntax(SyntaxKind kind, SyntaxToken semicolonToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(semicolonToken);
			this.semicolonToken = semicolonToken;
		}


		public EmptyStatementSyntax(SyntaxKind kind, SyntaxToken semicolonToken)
			: base(kind)
		{
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(semicolonToken);
			this.semicolonToken = semicolonToken;
		}

		public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.semicolonToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitEmptyStatement(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitEmptyStatement(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new EmptyStatementSyntax(this.Kind, this.semicolonToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new EmptyStatementSyntax(this.Kind, this.semicolonToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Represents a labeled statement syntax.</summary>
	public sealed partial class LabeledStatementSyntax : StatementSyntax
	{
		public readonly SyntaxToken identifier;
		public readonly SyntaxToken colonToken;
		public readonly StatementSyntax statement;

		public LabeledStatementSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			this.AdjustFlagsAndWidth(colonToken);
			this.colonToken = colonToken;
			this.AdjustFlagsAndWidth(statement);
			this.statement = statement;
		}


		public LabeledStatementSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			this.AdjustFlagsAndWidth(colonToken);
			this.colonToken = colonToken;
			this.AdjustFlagsAndWidth(statement);
			this.statement = statement;
		}


		public LabeledStatementSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			this.AdjustFlagsAndWidth(colonToken);
			this.colonToken = colonToken;
			this.AdjustFlagsAndWidth(statement);
			this.statement = statement;
		}

		/// <summary>Gets the identifier.</summary>
		public SyntaxToken Identifier { get { return this.identifier; } }
		/// <summary>Gets a SyntaxToken that represents the colon following the statement's label.</summary>
		public SyntaxToken ColonToken { get { return this.colonToken; } }
		public StatementSyntax Statement { get { return this.statement; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.identifier;
				case 1: return this.colonToken;
				case 2: return this.statement;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitLabeledStatement(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitLabeledStatement(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new LabeledStatementSyntax(this.Kind, this.identifier, this.colonToken, this.statement, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new LabeledStatementSyntax(this.Kind, this.identifier, this.colonToken, this.statement, GetDiagnostics(), annotations);
		}
	}

	/// <summary>
	/// Represents a goto statement syntax
	/// </summary>
	public sealed partial class GotoStatementSyntax : StatementSyntax
	{
		public readonly SyntaxToken gotoKeyword;
		public readonly SyntaxToken caseOrDefaultKeyword;
		public readonly ExpressionSyntax expression;
		public readonly SyntaxToken semicolonToken;

		public GotoStatementSyntax(SyntaxKind kind, SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(gotoKeyword);
			this.gotoKeyword = gotoKeyword;
			if (caseOrDefaultKeyword != null)
			{
				this.AdjustFlagsAndWidth(caseOrDefaultKeyword);
				this.caseOrDefaultKeyword = caseOrDefaultKeyword;
			}
			if (expression != null)
			{
				this.AdjustFlagsAndWidth(expression);
				this.expression = expression;
			}
			this.AdjustFlagsAndWidth(semicolonToken);
			this.semicolonToken = semicolonToken;
		}


		public GotoStatementSyntax(SyntaxKind kind, SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(gotoKeyword);
			this.gotoKeyword = gotoKeyword;
			if (caseOrDefaultKeyword != null)
			{
				this.AdjustFlagsAndWidth(caseOrDefaultKeyword);
				this.caseOrDefaultKeyword = caseOrDefaultKeyword;
			}
			if (expression != null)
			{
				this.AdjustFlagsAndWidth(expression);
				this.expression = expression;
			}
			this.AdjustFlagsAndWidth(semicolonToken);
			this.semicolonToken = semicolonToken;
		}


		public GotoStatementSyntax(SyntaxKind kind, SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
			: base(kind)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(gotoKeyword);
			this.gotoKeyword = gotoKeyword;
			if (caseOrDefaultKeyword != null)
			{
				this.AdjustFlagsAndWidth(caseOrDefaultKeyword);
				this.caseOrDefaultKeyword = caseOrDefaultKeyword;
			}
			if (expression != null)
			{
				this.AdjustFlagsAndWidth(expression);
				this.expression = expression;
			}
			this.AdjustFlagsAndWidth(semicolonToken);
			this.semicolonToken = semicolonToken;
		}

		/// <summary>
		/// Gets a SyntaxToken that represents the goto keyword.
		/// </summary>
		public SyntaxToken GotoKeyword { get { return this.gotoKeyword; } }
		/// <summary>
		/// Gets a SyntaxToken that represents the case or default keywords if any exists.
		/// </summary>
		public SyntaxToken CaseOrDefaultKeyword { get { return this.caseOrDefaultKeyword; } }
		/// <summary>
		/// Gets a constant expression for a goto case statement.
		/// </summary>
		public ExpressionSyntax Expression { get { return this.expression; } }
		/// <summary>
		/// Gets a SyntaxToken that represents the semi-colon at the end of the statement.
		/// </summary>
		public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.gotoKeyword;
				case 1: return this.caseOrDefaultKeyword;
				case 2: return this.expression;
				case 3: return this.semicolonToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitGotoStatement(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitGotoStatement(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new GotoStatementSyntax(this.Kind, this.gotoKeyword, this.caseOrDefaultKeyword, this.expression, this.semicolonToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new GotoStatementSyntax(this.Kind, this.gotoKeyword, this.caseOrDefaultKeyword, this.expression, this.semicolonToken, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class BreakStatementSyntax : StatementSyntax
	{
		public readonly SyntaxToken breakKeyword;
		public readonly SyntaxToken semicolonToken;

		public BreakStatementSyntax(SyntaxKind kind, SyntaxToken breakKeyword, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(breakKeyword);
			this.breakKeyword = breakKeyword;
			this.AdjustFlagsAndWidth(semicolonToken);
			this.semicolonToken = semicolonToken;
		}


		public BreakStatementSyntax(SyntaxKind kind, SyntaxToken breakKeyword, SyntaxToken semicolonToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(breakKeyword);
			this.breakKeyword = breakKeyword;
			this.AdjustFlagsAndWidth(semicolonToken);
			this.semicolonToken = semicolonToken;
		}


		public BreakStatementSyntax(SyntaxKind kind, SyntaxToken breakKeyword, SyntaxToken semicolonToken)
			: base(kind)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(breakKeyword);
			this.breakKeyword = breakKeyword;
			this.AdjustFlagsAndWidth(semicolonToken);
			this.semicolonToken = semicolonToken;
		}

		public SyntaxToken BreakKeyword { get { return this.breakKeyword; } }
		public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.breakKeyword;
				case 1: return this.semicolonToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitBreakStatement(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitBreakStatement(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new BreakStatementSyntax(this.Kind, this.breakKeyword, this.semicolonToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new BreakStatementSyntax(this.Kind, this.breakKeyword, this.semicolonToken, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class ContinueStatementSyntax : StatementSyntax
	{
		public readonly SyntaxToken continueKeyword;
		public readonly SyntaxToken semicolonToken;

		public ContinueStatementSyntax(SyntaxKind kind, SyntaxToken continueKeyword, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(continueKeyword);
			this.continueKeyword = continueKeyword;
			this.AdjustFlagsAndWidth(semicolonToken);
			this.semicolonToken = semicolonToken;
		}


		public ContinueStatementSyntax(SyntaxKind kind, SyntaxToken continueKeyword, SyntaxToken semicolonToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(continueKeyword);
			this.continueKeyword = continueKeyword;
			this.AdjustFlagsAndWidth(semicolonToken);
			this.semicolonToken = semicolonToken;
		}


		public ContinueStatementSyntax(SyntaxKind kind, SyntaxToken continueKeyword, SyntaxToken semicolonToken)
			: base(kind)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(continueKeyword);
			this.continueKeyword = continueKeyword;
			this.AdjustFlagsAndWidth(semicolonToken);
			this.semicolonToken = semicolonToken;
		}

		public SyntaxToken ContinueKeyword { get { return this.continueKeyword; } }
		public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.continueKeyword;
				case 1: return this.semicolonToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitContinueStatement(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitContinueStatement(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new ContinueStatementSyntax(this.Kind, this.continueKeyword, this.semicolonToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new ContinueStatementSyntax(this.Kind, this.continueKeyword, this.semicolonToken, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class ReturnStatementSyntax : StatementSyntax
	{
		public readonly SyntaxToken returnKeyword;
		public readonly ExpressionSyntax expression;
		public readonly SyntaxToken semicolonToken;

		public ReturnStatementSyntax(SyntaxKind kind, SyntaxToken returnKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(returnKeyword);
			this.returnKeyword = returnKeyword;
			if (expression != null)
			{
				this.AdjustFlagsAndWidth(expression);
				this.expression = expression;
			}
			this.AdjustFlagsAndWidth(semicolonToken);
			this.semicolonToken = semicolonToken;
		}


		public ReturnStatementSyntax(SyntaxKind kind, SyntaxToken returnKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(returnKeyword);
			this.returnKeyword = returnKeyword;
			if (expression != null)
			{
				this.AdjustFlagsAndWidth(expression);
				this.expression = expression;
			}
			this.AdjustFlagsAndWidth(semicolonToken);
			this.semicolonToken = semicolonToken;
		}


		public ReturnStatementSyntax(SyntaxKind kind, SyntaxToken returnKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(returnKeyword);
			this.returnKeyword = returnKeyword;
			if (expression != null)
			{
				this.AdjustFlagsAndWidth(expression);
				this.expression = expression;
			}
			this.AdjustFlagsAndWidth(semicolonToken);
			this.semicolonToken = semicolonToken;
		}

		public SyntaxToken ReturnKeyword { get { return this.returnKeyword; } }
		public ExpressionSyntax Expression { get { return this.expression; } }
		public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.returnKeyword;
				case 1: return this.expression;
				case 2: return this.semicolonToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitReturnStatement(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitReturnStatement(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new ReturnStatementSyntax(this.Kind, this.returnKeyword, this.expression, this.semicolonToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new ReturnStatementSyntax(this.Kind, this.returnKeyword, this.expression, this.semicolonToken, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class ThrowStatementSyntax : StatementSyntax
	{
		public readonly SyntaxToken throwKeyword;
		public readonly ExpressionSyntax expression;
		public readonly SyntaxToken semicolonToken;

		public ThrowStatementSyntax(SyntaxKind kind, SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(throwKeyword);
			this.throwKeyword = throwKeyword;
			if (expression != null)
			{
				this.AdjustFlagsAndWidth(expression);
				this.expression = expression;
			}
			this.AdjustFlagsAndWidth(semicolonToken);
			this.semicolonToken = semicolonToken;
		}


		public ThrowStatementSyntax(SyntaxKind kind, SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(throwKeyword);
			this.throwKeyword = throwKeyword;
			if (expression != null)
			{
				this.AdjustFlagsAndWidth(expression);
				this.expression = expression;
			}
			this.AdjustFlagsAndWidth(semicolonToken);
			this.semicolonToken = semicolonToken;
		}


		public ThrowStatementSyntax(SyntaxKind kind, SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(throwKeyword);
			this.throwKeyword = throwKeyword;
			if (expression != null)
			{
				this.AdjustFlagsAndWidth(expression);
				this.expression = expression;
			}
			this.AdjustFlagsAndWidth(semicolonToken);
			this.semicolonToken = semicolonToken;
		}

		public SyntaxToken ThrowKeyword { get { return this.throwKeyword; } }
		public ExpressionSyntax Expression { get { return this.expression; } }
		public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.throwKeyword;
				case 1: return this.expression;
				case 2: return this.semicolonToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitThrowStatement(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitThrowStatement(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new ThrowStatementSyntax(this.Kind, this.throwKeyword, this.expression, this.semicolonToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new ThrowStatementSyntax(this.Kind, this.throwKeyword, this.expression, this.semicolonToken, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class YieldStatementSyntax : StatementSyntax
	{
		public readonly SyntaxToken yieldKeyword;
		public readonly SyntaxToken returnOrBreakKeyword;
		public readonly ExpressionSyntax expression;
		public readonly SyntaxToken semicolonToken;

		public YieldStatementSyntax(SyntaxKind kind, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(yieldKeyword);
			this.yieldKeyword = yieldKeyword;
			this.AdjustFlagsAndWidth(returnOrBreakKeyword);
			this.returnOrBreakKeyword = returnOrBreakKeyword;
			if (expression != null)
			{
				this.AdjustFlagsAndWidth(expression);
				this.expression = expression;
			}
			this.AdjustFlagsAndWidth(semicolonToken);
			this.semicolonToken = semicolonToken;
		}


		public YieldStatementSyntax(SyntaxKind kind, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(yieldKeyword);
			this.yieldKeyword = yieldKeyword;
			this.AdjustFlagsAndWidth(returnOrBreakKeyword);
			this.returnOrBreakKeyword = returnOrBreakKeyword;
			if (expression != null)
			{
				this.AdjustFlagsAndWidth(expression);
				this.expression = expression;
			}
			this.AdjustFlagsAndWidth(semicolonToken);
			this.semicolonToken = semicolonToken;
		}


		public YieldStatementSyntax(SyntaxKind kind, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
			: base(kind)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(yieldKeyword);
			this.yieldKeyword = yieldKeyword;
			this.AdjustFlagsAndWidth(returnOrBreakKeyword);
			this.returnOrBreakKeyword = returnOrBreakKeyword;
			if (expression != null)
			{
				this.AdjustFlagsAndWidth(expression);
				this.expression = expression;
			}
			this.AdjustFlagsAndWidth(semicolonToken);
			this.semicolonToken = semicolonToken;
		}

		public SyntaxToken YieldKeyword { get { return this.yieldKeyword; } }
		public SyntaxToken ReturnOrBreakKeyword { get { return this.returnOrBreakKeyword; } }
		public ExpressionSyntax Expression { get { return this.expression; } }
		public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.yieldKeyword;
				case 1: return this.returnOrBreakKeyword;
				case 2: return this.expression;
				case 3: return this.semicolonToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitYieldStatement(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitYieldStatement(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new YieldStatementSyntax(this.Kind, this.yieldKeyword, this.returnOrBreakKeyword, this.expression, this.semicolonToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new YieldStatementSyntax(this.Kind, this.yieldKeyword, this.returnOrBreakKeyword, this.expression, this.semicolonToken, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class WhileStatementSyntax : StatementSyntax
	{
		public readonly SyntaxToken whileKeyword;
		public readonly SyntaxToken openParenToken;
		public readonly ExpressionSyntax condition;
		public readonly SyntaxToken closeParenToken;
		public readonly StatementSyntax statement;

		public WhileStatementSyntax(SyntaxKind kind, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 5;
			this.AdjustFlagsAndWidth(whileKeyword);
			this.whileKeyword = whileKeyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(condition);
			this.condition = condition;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
			this.AdjustFlagsAndWidth(statement);
			this.statement = statement;
		}


		public WhileStatementSyntax(SyntaxKind kind, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 5;
			this.AdjustFlagsAndWidth(whileKeyword);
			this.whileKeyword = whileKeyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(condition);
			this.condition = condition;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
			this.AdjustFlagsAndWidth(statement);
			this.statement = statement;
		}


		public WhileStatementSyntax(SyntaxKind kind, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement)
			: base(kind)
		{
			this.SlotCount = 5;
			this.AdjustFlagsAndWidth(whileKeyword);
			this.whileKeyword = whileKeyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(condition);
			this.condition = condition;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
			this.AdjustFlagsAndWidth(statement);
			this.statement = statement;
		}

		public SyntaxToken WhileKeyword { get { return this.whileKeyword; } }
		public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
		public ExpressionSyntax Condition { get { return this.condition; } }
		public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }
		public StatementSyntax Statement { get { return this.statement; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.whileKeyword;
				case 1: return this.openParenToken;
				case 2: return this.condition;
				case 3: return this.closeParenToken;
				case 4: return this.statement;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitWhileStatement(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitWhileStatement(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new WhileStatementSyntax(this.Kind, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new WhileStatementSyntax(this.Kind, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class DoStatementSyntax : StatementSyntax
	{
		public readonly SyntaxToken doKeyword;
		public readonly StatementSyntax statement;
		public readonly SyntaxToken whileKeyword;
		public readonly SyntaxToken openParenToken;
		public readonly ExpressionSyntax condition;
		public readonly SyntaxToken closeParenToken;
		public readonly SyntaxToken semicolonToken;

		public DoStatementSyntax(SyntaxKind kind, SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 7;
			this.AdjustFlagsAndWidth(doKeyword);
			this.doKeyword = doKeyword;
			this.AdjustFlagsAndWidth(statement);
			this.statement = statement;
			this.AdjustFlagsAndWidth(whileKeyword);
			this.whileKeyword = whileKeyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(condition);
			this.condition = condition;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
			this.AdjustFlagsAndWidth(semicolonToken);
			this.semicolonToken = semicolonToken;
		}


		public DoStatementSyntax(SyntaxKind kind, SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 7;
			this.AdjustFlagsAndWidth(doKeyword);
			this.doKeyword = doKeyword;
			this.AdjustFlagsAndWidth(statement);
			this.statement = statement;
			this.AdjustFlagsAndWidth(whileKeyword);
			this.whileKeyword = whileKeyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(condition);
			this.condition = condition;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
			this.AdjustFlagsAndWidth(semicolonToken);
			this.semicolonToken = semicolonToken;
		}


		public DoStatementSyntax(SyntaxKind kind, SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken)
			: base(kind)
		{
			this.SlotCount = 7;
			this.AdjustFlagsAndWidth(doKeyword);
			this.doKeyword = doKeyword;
			this.AdjustFlagsAndWidth(statement);
			this.statement = statement;
			this.AdjustFlagsAndWidth(whileKeyword);
			this.whileKeyword = whileKeyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(condition);
			this.condition = condition;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
			this.AdjustFlagsAndWidth(semicolonToken);
			this.semicolonToken = semicolonToken;
		}

		public SyntaxToken DoKeyword { get { return this.doKeyword; } }
		public StatementSyntax Statement { get { return this.statement; } }
		public SyntaxToken WhileKeyword { get { return this.whileKeyword; } }
		public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
		public ExpressionSyntax Condition { get { return this.condition; } }
		public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }
		public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.doKeyword;
				case 1: return this.statement;
				case 2: return this.whileKeyword;
				case 3: return this.openParenToken;
				case 4: return this.condition;
				case 5: return this.closeParenToken;
				case 6: return this.semicolonToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitDoStatement(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitDoStatement(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new DoStatementSyntax(this.Kind, this.doKeyword, this.statement, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.semicolonToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new DoStatementSyntax(this.Kind, this.doKeyword, this.statement, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.semicolonToken, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class ForStatementSyntax : StatementSyntax
	{
		public readonly SyntaxToken forKeyword;
		public readonly SyntaxToken openParenToken;
		public readonly VariableDeclarationSyntax declaration;
		public readonly GreenNode initializers;
		public readonly SyntaxToken firstSemicolonToken;
		public readonly ExpressionSyntax condition;
		public readonly SyntaxToken secondSemicolonToken;
		public readonly GreenNode incrementors;
		public readonly SyntaxToken closeParenToken;
		public readonly StatementSyntax statement;

		public ForStatementSyntax(SyntaxKind kind, SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, GreenNode initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax condition, SyntaxToken secondSemicolonToken, GreenNode incrementors, SyntaxToken closeParenToken, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 10;
			this.AdjustFlagsAndWidth(forKeyword);
			this.forKeyword = forKeyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			if (declaration != null)
			{
				this.AdjustFlagsAndWidth(declaration);
				this.declaration = declaration;
			}
			if (initializers != null)
			{
				this.AdjustFlagsAndWidth(initializers);
				this.initializers = initializers;
			}
			this.AdjustFlagsAndWidth(firstSemicolonToken);
			this.firstSemicolonToken = firstSemicolonToken;
			if (condition != null)
			{
				this.AdjustFlagsAndWidth(condition);
				this.condition = condition;
			}
			this.AdjustFlagsAndWidth(secondSemicolonToken);
			this.secondSemicolonToken = secondSemicolonToken;
			if (incrementors != null)
			{
				this.AdjustFlagsAndWidth(incrementors);
				this.incrementors = incrementors;
			}
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
			this.AdjustFlagsAndWidth(statement);
			this.statement = statement;
		}


		public ForStatementSyntax(SyntaxKind kind, SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, GreenNode initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax condition, SyntaxToken secondSemicolonToken, GreenNode incrementors, SyntaxToken closeParenToken, StatementSyntax statement, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 10;
			this.AdjustFlagsAndWidth(forKeyword);
			this.forKeyword = forKeyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			if (declaration != null)
			{
				this.AdjustFlagsAndWidth(declaration);
				this.declaration = declaration;
			}
			if (initializers != null)
			{
				this.AdjustFlagsAndWidth(initializers);
				this.initializers = initializers;
			}
			this.AdjustFlagsAndWidth(firstSemicolonToken);
			this.firstSemicolonToken = firstSemicolonToken;
			if (condition != null)
			{
				this.AdjustFlagsAndWidth(condition);
				this.condition = condition;
			}
			this.AdjustFlagsAndWidth(secondSemicolonToken);
			this.secondSemicolonToken = secondSemicolonToken;
			if (incrementors != null)
			{
				this.AdjustFlagsAndWidth(incrementors);
				this.incrementors = incrementors;
			}
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
			this.AdjustFlagsAndWidth(statement);
			this.statement = statement;
		}


		public ForStatementSyntax(SyntaxKind kind, SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, GreenNode initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax condition, SyntaxToken secondSemicolonToken, GreenNode incrementors, SyntaxToken closeParenToken, StatementSyntax statement)
			: base(kind)
		{
			this.SlotCount = 10;
			this.AdjustFlagsAndWidth(forKeyword);
			this.forKeyword = forKeyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			if (declaration != null)
			{
				this.AdjustFlagsAndWidth(declaration);
				this.declaration = declaration;
			}
			if (initializers != null)
			{
				this.AdjustFlagsAndWidth(initializers);
				this.initializers = initializers;
			}
			this.AdjustFlagsAndWidth(firstSemicolonToken);
			this.firstSemicolonToken = firstSemicolonToken;
			if (condition != null)
			{
				this.AdjustFlagsAndWidth(condition);
				this.condition = condition;
			}
			this.AdjustFlagsAndWidth(secondSemicolonToken);
			this.secondSemicolonToken = secondSemicolonToken;
			if (incrementors != null)
			{
				this.AdjustFlagsAndWidth(incrementors);
				this.incrementors = incrementors;
			}
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
			this.AdjustFlagsAndWidth(statement);
			this.statement = statement;
		}

		public SyntaxToken ForKeyword { get { return this.forKeyword; } }
		public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
		public VariableDeclarationSyntax Declaration { get { return this.declaration; } }
		public SeparatedSyntaxList<ExpressionSyntax> Initializers { get { return new SeparatedSyntaxList<ExpressionSyntax>(new SyntaxList<LeeSyntaxNode>(this.initializers)); } }
		public SyntaxToken FirstSemicolonToken { get { return this.firstSemicolonToken; } }
		public ExpressionSyntax Condition { get { return this.condition; } }
		public SyntaxToken SecondSemicolonToken { get { return this.secondSemicolonToken; } }
		public SeparatedSyntaxList<ExpressionSyntax> Incrementors { get { return new SeparatedSyntaxList<ExpressionSyntax>(new SyntaxList<LeeSyntaxNode>(this.incrementors)); } }
		public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }
		public StatementSyntax Statement { get { return this.statement; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.forKeyword;
				case 1: return this.openParenToken;
				case 2: return this.declaration;
				case 3: return this.initializers;
				case 4: return this.firstSemicolonToken;
				case 5: return this.condition;
				case 6: return this.secondSemicolonToken;
				case 7: return this.incrementors;
				case 8: return this.closeParenToken;
				case 9: return this.statement;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitForStatement(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitForStatement(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new ForStatementSyntax(this.Kind, this.forKeyword, this.openParenToken, this.declaration, this.initializers, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementors, this.closeParenToken, this.statement, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new ForStatementSyntax(this.Kind, this.forKeyword, this.openParenToken, this.declaration, this.initializers, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementors, this.closeParenToken, this.statement, GetDiagnostics(), annotations);
		}
	}

	public abstract partial class CommonForEachStatementSyntax : StatementSyntax
	{
		public CommonForEachStatementSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
		  : base(kind, diagnostics, annotations)
		{
		}
		public CommonForEachStatementSyntax(SyntaxKind kind)
		  : base(kind)
		{
		}

		public abstract SyntaxToken AwaitKeyword { get; }

		public abstract SyntaxToken ForEachKeyword { get; }

		public abstract SyntaxToken OpenParenToken { get; }

		public abstract SyntaxToken InKeyword { get; }

		public abstract ExpressionSyntax Expression { get; }

		public abstract SyntaxToken CloseParenToken { get; }

		public abstract StatementSyntax Statement { get; }
	}

	public sealed partial class ForEachStatementSyntax : CommonForEachStatementSyntax
	{
		public readonly SyntaxToken awaitKeyword;
		public readonly SyntaxToken forEachKeyword;
		public readonly SyntaxToken openParenToken;
		public readonly TypeSyntax type;
		public readonly SyntaxToken identifier;
		public readonly SyntaxToken inKeyword;
		public readonly ExpressionSyntax expression;
		public readonly SyntaxToken closeParenToken;
		public readonly StatementSyntax statement;

		public ForEachStatementSyntax(SyntaxKind kind, SyntaxToken awaitKeyword, SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 9;
			if (awaitKeyword != null)
			{
				this.AdjustFlagsAndWidth(awaitKeyword);
				this.awaitKeyword = awaitKeyword;
			}
			this.AdjustFlagsAndWidth(forEachKeyword);
			this.forEachKeyword = forEachKeyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			this.AdjustFlagsAndWidth(inKeyword);
			this.inKeyword = inKeyword;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
			this.AdjustFlagsAndWidth(statement);
			this.statement = statement;
		}


		public ForEachStatementSyntax(SyntaxKind kind, SyntaxToken awaitKeyword, SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 9;
			if (awaitKeyword != null)
			{
				this.AdjustFlagsAndWidth(awaitKeyword);
				this.awaitKeyword = awaitKeyword;
			}
			this.AdjustFlagsAndWidth(forEachKeyword);
			this.forEachKeyword = forEachKeyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			this.AdjustFlagsAndWidth(inKeyword);
			this.inKeyword = inKeyword;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
			this.AdjustFlagsAndWidth(statement);
			this.statement = statement;
		}


		public ForEachStatementSyntax(SyntaxKind kind, SyntaxToken awaitKeyword, SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
			: base(kind)
		{
			this.SlotCount = 9;
			if (awaitKeyword != null)
			{
				this.AdjustFlagsAndWidth(awaitKeyword);
				this.awaitKeyword = awaitKeyword;
			}
			this.AdjustFlagsAndWidth(forEachKeyword);
			this.forEachKeyword = forEachKeyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			this.AdjustFlagsAndWidth(inKeyword);
			this.inKeyword = inKeyword;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
			this.AdjustFlagsAndWidth(statement);
			this.statement = statement;
		}

		public override SyntaxToken AwaitKeyword { get { return this.awaitKeyword; } }
		public override SyntaxToken ForEachKeyword { get { return this.forEachKeyword; } }
		public override SyntaxToken OpenParenToken { get { return this.openParenToken; } }
		public TypeSyntax Type { get { return this.type; } }
		/// <summary>Gets the identifier.</summary>
		public SyntaxToken Identifier { get { return this.identifier; } }
		public override SyntaxToken InKeyword { get { return this.inKeyword; } }
		public override ExpressionSyntax Expression { get { return this.expression; } }
		public override SyntaxToken CloseParenToken { get { return this.closeParenToken; } }
		public override StatementSyntax Statement { get { return this.statement; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.awaitKeyword;
				case 1: return this.forEachKeyword;
				case 2: return this.openParenToken;
				case 3: return this.type;
				case 4: return this.identifier;
				case 5: return this.inKeyword;
				case 6: return this.expression;
				case 7: return this.closeParenToken;
				case 8: return this.statement;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitForEachStatement(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitForEachStatement(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new ForEachStatementSyntax(this.Kind, this.awaitKeyword, this.forEachKeyword, this.openParenToken, this.type, this.identifier, this.inKeyword, this.expression, this.closeParenToken, this.statement, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new ForEachStatementSyntax(this.Kind, this.awaitKeyword, this.forEachKeyword, this.openParenToken, this.type, this.identifier, this.inKeyword, this.expression, this.closeParenToken, this.statement, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class ForEachVariableStatementSyntax : CommonForEachStatementSyntax
	{
		public readonly SyntaxToken awaitKeyword;
		public readonly SyntaxToken forEachKeyword;
		public readonly SyntaxToken openParenToken;
		public readonly ExpressionSyntax variable;
		public readonly SyntaxToken inKeyword;
		public readonly ExpressionSyntax expression;
		public readonly SyntaxToken closeParenToken;
		public readonly StatementSyntax statement;

		public ForEachVariableStatementSyntax(SyntaxKind kind, SyntaxToken awaitKeyword, SyntaxToken forEachKeyword, SyntaxToken openParenToken, ExpressionSyntax variable, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 8;
			if (awaitKeyword != null)
			{
				this.AdjustFlagsAndWidth(awaitKeyword);
				this.awaitKeyword = awaitKeyword;
			}
			this.AdjustFlagsAndWidth(forEachKeyword);
			this.forEachKeyword = forEachKeyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(variable);
			this.variable = variable;
			this.AdjustFlagsAndWidth(inKeyword);
			this.inKeyword = inKeyword;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
			this.AdjustFlagsAndWidth(statement);
			this.statement = statement;
		}


		public ForEachVariableStatementSyntax(SyntaxKind kind, SyntaxToken awaitKeyword, SyntaxToken forEachKeyword, SyntaxToken openParenToken, ExpressionSyntax variable, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 8;
			if (awaitKeyword != null)
			{
				this.AdjustFlagsAndWidth(awaitKeyword);
				this.awaitKeyword = awaitKeyword;
			}
			this.AdjustFlagsAndWidth(forEachKeyword);
			this.forEachKeyword = forEachKeyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(variable);
			this.variable = variable;
			this.AdjustFlagsAndWidth(inKeyword);
			this.inKeyword = inKeyword;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
			this.AdjustFlagsAndWidth(statement);
			this.statement = statement;
		}


		public ForEachVariableStatementSyntax(SyntaxKind kind, SyntaxToken awaitKeyword, SyntaxToken forEachKeyword, SyntaxToken openParenToken, ExpressionSyntax variable, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
			: base(kind)
		{
			this.SlotCount = 8;
			if (awaitKeyword != null)
			{
				this.AdjustFlagsAndWidth(awaitKeyword);
				this.awaitKeyword = awaitKeyword;
			}
			this.AdjustFlagsAndWidth(forEachKeyword);
			this.forEachKeyword = forEachKeyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(variable);
			this.variable = variable;
			this.AdjustFlagsAndWidth(inKeyword);
			this.inKeyword = inKeyword;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
			this.AdjustFlagsAndWidth(statement);
			this.statement = statement;
		}

		public override SyntaxToken AwaitKeyword { get { return this.awaitKeyword; } }
		public override SyntaxToken ForEachKeyword { get { return this.forEachKeyword; } }
		public override SyntaxToken OpenParenToken { get { return this.openParenToken; } }
		/// <summary>
		/// The variable(s) of the loop. In correct code this is a tuple
		/// literal, declaration expression with a tuple designator, or
		/// a discard syntax in the form of a simple identifier. In broken
		/// code it could be something else.
		/// </summary>
		public ExpressionSyntax Variable { get { return this.variable; } }
		public override SyntaxToken InKeyword { get { return this.inKeyword; } }
		public override ExpressionSyntax Expression { get { return this.expression; } }
		public override SyntaxToken CloseParenToken { get { return this.closeParenToken; } }
		public override StatementSyntax Statement { get { return this.statement; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.awaitKeyword;
				case 1: return this.forEachKeyword;
				case 2: return this.openParenToken;
				case 3: return this.variable;
				case 4: return this.inKeyword;
				case 5: return this.expression;
				case 6: return this.closeParenToken;
				case 7: return this.statement;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitForEachVariableStatement(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitForEachVariableStatement(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new ForEachVariableStatementSyntax(this.Kind, this.awaitKeyword, this.forEachKeyword, this.openParenToken, this.variable, this.inKeyword, this.expression, this.closeParenToken, this.statement, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new ForEachVariableStatementSyntax(this.Kind, this.awaitKeyword, this.forEachKeyword, this.openParenToken, this.variable, this.inKeyword, this.expression, this.closeParenToken, this.statement, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class UsingStatementSyntax : StatementSyntax
	{
		public readonly SyntaxToken awaitKeyword;
		public readonly SyntaxToken usingKeyword;
		public readonly SyntaxToken openParenToken;
		public readonly VariableDeclarationSyntax declaration;
		public readonly ExpressionSyntax expression;
		public readonly SyntaxToken closeParenToken;
		public readonly StatementSyntax statement;

		public UsingStatementSyntax(SyntaxKind kind, SyntaxToken awaitKeyword, SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 7;
			if (awaitKeyword != null)
			{
				this.AdjustFlagsAndWidth(awaitKeyword);
				this.awaitKeyword = awaitKeyword;
			}
			this.AdjustFlagsAndWidth(usingKeyword);
			this.usingKeyword = usingKeyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			if (declaration != null)
			{
				this.AdjustFlagsAndWidth(declaration);
				this.declaration = declaration;
			}
			if (expression != null)
			{
				this.AdjustFlagsAndWidth(expression);
				this.expression = expression;
			}
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
			this.AdjustFlagsAndWidth(statement);
			this.statement = statement;
		}


		public UsingStatementSyntax(SyntaxKind kind, SyntaxToken awaitKeyword, SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 7;
			if (awaitKeyword != null)
			{
				this.AdjustFlagsAndWidth(awaitKeyword);
				this.awaitKeyword = awaitKeyword;
			}
			this.AdjustFlagsAndWidth(usingKeyword);
			this.usingKeyword = usingKeyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			if (declaration != null)
			{
				this.AdjustFlagsAndWidth(declaration);
				this.declaration = declaration;
			}
			if (expression != null)
			{
				this.AdjustFlagsAndWidth(expression);
				this.expression = expression;
			}
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
			this.AdjustFlagsAndWidth(statement);
			this.statement = statement;
		}


		public UsingStatementSyntax(SyntaxKind kind, SyntaxToken awaitKeyword, SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
			: base(kind)
		{
			this.SlotCount = 7;
			if (awaitKeyword != null)
			{
				this.AdjustFlagsAndWidth(awaitKeyword);
				this.awaitKeyword = awaitKeyword;
			}
			this.AdjustFlagsAndWidth(usingKeyword);
			this.usingKeyword = usingKeyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			if (declaration != null)
			{
				this.AdjustFlagsAndWidth(declaration);
				this.declaration = declaration;
			}
			if (expression != null)
			{
				this.AdjustFlagsAndWidth(expression);
				this.expression = expression;
			}
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
			this.AdjustFlagsAndWidth(statement);
			this.statement = statement;
		}

		public SyntaxToken AwaitKeyword { get { return this.awaitKeyword; } }
		public SyntaxToken UsingKeyword { get { return this.usingKeyword; } }
		public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
		public VariableDeclarationSyntax Declaration { get { return this.declaration; } }
		public ExpressionSyntax Expression { get { return this.expression; } }
		public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }
		public StatementSyntax Statement { get { return this.statement; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.awaitKeyword;
				case 1: return this.usingKeyword;
				case 2: return this.openParenToken;
				case 3: return this.declaration;
				case 4: return this.expression;
				case 5: return this.closeParenToken;
				case 6: return this.statement;
				default: return null;
			}
		}
		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitUsingStatement(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitUsingStatement(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new UsingStatementSyntax(this.Kind, this.awaitKeyword, this.usingKeyword, this.openParenToken, this.declaration, this.expression, this.closeParenToken, this.statement, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new UsingStatementSyntax(this.Kind, this.awaitKeyword, this.usingKeyword, this.openParenToken, this.declaration, this.expression, this.closeParenToken, this.statement, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class FixedStatementSyntax : StatementSyntax
	{
		public readonly SyntaxToken fixedKeyword;
		public readonly SyntaxToken openParenToken;
		public readonly VariableDeclarationSyntax declaration;
		public readonly SyntaxToken closeParenToken;
		public readonly StatementSyntax statement;

		public FixedStatementSyntax(SyntaxKind kind, SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 5;
			this.AdjustFlagsAndWidth(fixedKeyword);
			this.fixedKeyword = fixedKeyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(declaration);
			this.declaration = declaration;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
			this.AdjustFlagsAndWidth(statement);
			this.statement = statement;
		}


		public FixedStatementSyntax(SyntaxKind kind, SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 5;
			this.AdjustFlagsAndWidth(fixedKeyword);
			this.fixedKeyword = fixedKeyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(declaration);
			this.declaration = declaration;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
			this.AdjustFlagsAndWidth(statement);
			this.statement = statement;
		}


		public FixedStatementSyntax(SyntaxKind kind, SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement)
			: base(kind)
		{
			this.SlotCount = 5;
			this.AdjustFlagsAndWidth(fixedKeyword);
			this.fixedKeyword = fixedKeyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(declaration);
			this.declaration = declaration;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
			this.AdjustFlagsAndWidth(statement);
			this.statement = statement;
		}

		public SyntaxToken FixedKeyword { get { return this.fixedKeyword; } }
		public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
		public VariableDeclarationSyntax Declaration { get { return this.declaration; } }
		public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }
		public StatementSyntax Statement { get { return this.statement; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.fixedKeyword;
				case 1: return this.openParenToken;
				case 2: return this.declaration;
				case 3: return this.closeParenToken;
				case 4: return this.statement;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitFixedStatement(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitFixedStatement(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new FixedStatementSyntax(this.Kind, this.fixedKeyword, this.openParenToken, this.declaration, this.closeParenToken, this.statement, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new FixedStatementSyntax(this.Kind, this.fixedKeyword, this.openParenToken, this.declaration, this.closeParenToken, this.statement, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class CheckedStatementSyntax : StatementSyntax
	{
		public readonly SyntaxToken keyword;
		public readonly BlockSyntax block;

		public CheckedStatementSyntax(SyntaxKind kind, SyntaxToken keyword, BlockSyntax block, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
			this.AdjustFlagsAndWidth(block);
			this.block = block;
		}


		public CheckedStatementSyntax(SyntaxKind kind, SyntaxToken keyword, BlockSyntax block, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
			this.AdjustFlagsAndWidth(block);
			this.block = block;
		}


		public CheckedStatementSyntax(SyntaxKind kind, SyntaxToken keyword, BlockSyntax block)
			: base(kind)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
			this.AdjustFlagsAndWidth(block);
			this.block = block;
		}

		public SyntaxToken Keyword { get { return this.keyword; } }
		public BlockSyntax Block { get { return this.block; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.keyword;
				case 1: return this.block;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitCheckedStatement(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitCheckedStatement(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new CheckedStatementSyntax(this.Kind, this.keyword, this.block, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new CheckedStatementSyntax(this.Kind, this.keyword, this.block, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class UnsafeStatementSyntax : StatementSyntax
	{
		public readonly SyntaxToken unsafeKeyword;
		public readonly BlockSyntax block;

		public UnsafeStatementSyntax(SyntaxKind kind, SyntaxToken unsafeKeyword, BlockSyntax block, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(unsafeKeyword);
			this.unsafeKeyword = unsafeKeyword;
			this.AdjustFlagsAndWidth(block);
			this.block = block;
		}


		public UnsafeStatementSyntax(SyntaxKind kind, SyntaxToken unsafeKeyword, BlockSyntax block, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(unsafeKeyword);
			this.unsafeKeyword = unsafeKeyword;
			this.AdjustFlagsAndWidth(block);
			this.block = block;
		}


		public UnsafeStatementSyntax(SyntaxKind kind, SyntaxToken unsafeKeyword, BlockSyntax block)
			: base(kind)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(unsafeKeyword);
			this.unsafeKeyword = unsafeKeyword;
			this.AdjustFlagsAndWidth(block);
			this.block = block;
		}

		public SyntaxToken UnsafeKeyword { get { return this.unsafeKeyword; } }
		public BlockSyntax Block { get { return this.block; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.unsafeKeyword;
				case 1: return this.block;
				default: return null;
			}
		}
		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitUnsafeStatement(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitUnsafeStatement(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new UnsafeStatementSyntax(this.Kind, this.unsafeKeyword, this.block, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new UnsafeStatementSyntax(this.Kind, this.unsafeKeyword, this.block, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class LockStatementSyntax : StatementSyntax
	{
		public readonly SyntaxToken lockKeyword;
		public readonly SyntaxToken openParenToken;
		public readonly ExpressionSyntax expression;
		public readonly SyntaxToken closeParenToken;
		public readonly StatementSyntax statement;

		public LockStatementSyntax(SyntaxKind kind, SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 5;
			this.AdjustFlagsAndWidth(lockKeyword);
			this.lockKeyword = lockKeyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
			this.AdjustFlagsAndWidth(statement);
			this.statement = statement;
		}


		public LockStatementSyntax(SyntaxKind kind, SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 5;
			this.AdjustFlagsAndWidth(lockKeyword);
			this.lockKeyword = lockKeyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
			this.AdjustFlagsAndWidth(statement);
			this.statement = statement;
		}


		public LockStatementSyntax(SyntaxKind kind, SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
			: base(kind)
		{
			this.SlotCount = 5;
			this.AdjustFlagsAndWidth(lockKeyword);
			this.lockKeyword = lockKeyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
			this.AdjustFlagsAndWidth(statement);
			this.statement = statement;
		}

		public SyntaxToken LockKeyword { get { return this.lockKeyword; } }
		public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
		public ExpressionSyntax Expression { get { return this.expression; } }
		public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }
		public StatementSyntax Statement { get { return this.statement; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.lockKeyword;
				case 1: return this.openParenToken;
				case 2: return this.expression;
				case 3: return this.closeParenToken;
				case 4: return this.statement;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitLockStatement(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitLockStatement(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new LockStatementSyntax(this.Kind, this.lockKeyword, this.openParenToken, this.expression, this.closeParenToken, this.statement, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new LockStatementSyntax(this.Kind, this.lockKeyword, this.openParenToken, this.expression, this.closeParenToken, this.statement, GetDiagnostics(), annotations);
		}
	}

	/// <summary>
	/// Represents an if statement syntax.
	/// </summary>
	public sealed partial class IfStatementSyntax : StatementSyntax
	{
		public readonly SyntaxToken ifKeyword;
		public readonly SyntaxToken openParenToken;
		public readonly ExpressionSyntax condition;
		public readonly SyntaxToken closeParenToken;
		public readonly StatementSyntax statement;
		public readonly ElseClauseSyntax @else;

		public IfStatementSyntax(SyntaxKind kind, SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax @else, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 6;
			this.AdjustFlagsAndWidth(ifKeyword);
			this.ifKeyword = ifKeyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(condition);
			this.condition = condition;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
			this.AdjustFlagsAndWidth(statement);
			this.statement = statement;
			if (@else != null)
			{
				this.AdjustFlagsAndWidth(@else);
				this.@else = @else;
			}
		}


		public IfStatementSyntax(SyntaxKind kind, SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax @else, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 6;
			this.AdjustFlagsAndWidth(ifKeyword);
			this.ifKeyword = ifKeyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(condition);
			this.condition = condition;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
			this.AdjustFlagsAndWidth(statement);
			this.statement = statement;
			if (@else != null)
			{
				this.AdjustFlagsAndWidth(@else);
				this.@else = @else;
			}
		}


		public IfStatementSyntax(SyntaxKind kind, SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax @else)
			: base(kind)
		{
			this.SlotCount = 6;
			this.AdjustFlagsAndWidth(ifKeyword);
			this.ifKeyword = ifKeyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(condition);
			this.condition = condition;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
			this.AdjustFlagsAndWidth(statement);
			this.statement = statement;
			if (@else != null)
			{
				this.AdjustFlagsAndWidth(@else);
				this.@else = @else;
			}
		}

		/// <summary>
		/// Gets a SyntaxToken that represents the if keyword.
		/// </summary>
		public SyntaxToken IfKeyword { get { return this.ifKeyword; } }
		/// <summary>
		/// Gets a SyntaxToken that represents the open parenthesis before the if statement's condition expression.
		/// </summary>
		public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
		/// <summary>
		/// Gets an ExpressionSyntax that represents the condition of the if statement.
		/// </summary>
		public ExpressionSyntax Condition { get { return this.condition; } }
		/// <summary>
		/// Gets a SyntaxToken that represents the close parenthesis after the if statement's condition expression.
		/// </summary>
		public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }
		/// <summary>
		/// Gets a StatementSyntax the represents the statement to be executed when the condition is true.
		/// </summary>
		public StatementSyntax Statement { get { return this.statement; } }
		/// <summary>
		/// Gets an ElseClauseSyntax that represents the statement to be executed when the condition is false if such statement exists.
		/// </summary>
		public ElseClauseSyntax Else { get { return this.@else; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.ifKeyword;
				case 1: return this.openParenToken;
				case 2: return this.condition;
				case 3: return this.closeParenToken;
				case 4: return this.statement;
				case 5: return this.@else;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitIfStatement(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitIfStatement(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new IfStatementSyntax(this.Kind, this.ifKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, this.@else, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new IfStatementSyntax(this.Kind, this.ifKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, this.@else, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Represents an else statement syntax.</summary>
	public sealed partial class ElseClauseSyntax : LeeSyntaxNode
	{
		public readonly SyntaxToken elseKeyword;
		public readonly StatementSyntax statement;

		public ElseClauseSyntax(SyntaxKind kind, SyntaxToken elseKeyword, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(elseKeyword);
			this.elseKeyword = elseKeyword;
			this.AdjustFlagsAndWidth(statement);
			this.statement = statement;
		}


		public ElseClauseSyntax(SyntaxKind kind, SyntaxToken elseKeyword, StatementSyntax statement, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(elseKeyword);
			this.elseKeyword = elseKeyword;
			this.AdjustFlagsAndWidth(statement);
			this.statement = statement;
		}


		public ElseClauseSyntax(SyntaxKind kind, SyntaxToken elseKeyword, StatementSyntax statement)
			: base(kind)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(elseKeyword);
			this.elseKeyword = elseKeyword;
			this.AdjustFlagsAndWidth(statement);
			this.statement = statement;
		}

		/// <summary>
		/// Gets a syntax token
		/// </summary>
		public SyntaxToken ElseKeyword { get { return this.elseKeyword; } }
		public StatementSyntax Statement { get { return this.statement; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.elseKeyword;
				case 1: return this.statement;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitElseClause(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitElseClause(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new ElseClauseSyntax(this.Kind, this.elseKeyword, this.statement, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new ElseClauseSyntax(this.Kind, this.elseKeyword, this.statement, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Represents a switch statement syntax.</summary>
	public sealed partial class SwitchStatementSyntax : StatementSyntax
	{
		public readonly SyntaxToken switchKeyword;
		public readonly SyntaxToken openParenToken;
		public readonly ExpressionSyntax expression;
		public readonly SyntaxToken closeParenToken;
		public readonly SyntaxToken openBraceToken;
		public readonly GreenNode sections;
		public readonly SyntaxToken closeBraceToken;

		public SwitchStatementSyntax(SyntaxKind kind, SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, GreenNode sections, SyntaxToken closeBraceToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 7;
			this.AdjustFlagsAndWidth(switchKeyword);
			this.switchKeyword = switchKeyword;
			if (openParenToken != null)
			{
				this.AdjustFlagsAndWidth(openParenToken);
				this.openParenToken = openParenToken;
			}
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			if (closeParenToken != null)
			{
				this.AdjustFlagsAndWidth(closeParenToken);
				this.closeParenToken = closeParenToken;
			}
			this.AdjustFlagsAndWidth(openBraceToken);
			this.openBraceToken = openBraceToken;
			if (sections != null)
			{
				this.AdjustFlagsAndWidth(sections);
				this.sections = sections;
			}
			this.AdjustFlagsAndWidth(closeBraceToken);
			this.closeBraceToken = closeBraceToken;
		}


		public SwitchStatementSyntax(SyntaxKind kind, SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, GreenNode sections, SyntaxToken closeBraceToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 7;
			this.AdjustFlagsAndWidth(switchKeyword);
			this.switchKeyword = switchKeyword;
			if (openParenToken != null)
			{
				this.AdjustFlagsAndWidth(openParenToken);
				this.openParenToken = openParenToken;
			}
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			if (closeParenToken != null)
			{
				this.AdjustFlagsAndWidth(closeParenToken);
				this.closeParenToken = closeParenToken;
			}
			this.AdjustFlagsAndWidth(openBraceToken);
			this.openBraceToken = openBraceToken;
			if (sections != null)
			{
				this.AdjustFlagsAndWidth(sections);
				this.sections = sections;
			}
			this.AdjustFlagsAndWidth(closeBraceToken);
			this.closeBraceToken = closeBraceToken;
		}


		public SwitchStatementSyntax(SyntaxKind kind, SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, GreenNode sections, SyntaxToken closeBraceToken)
			: base(kind)
		{
			this.SlotCount = 7;
			this.AdjustFlagsAndWidth(switchKeyword);
			this.switchKeyword = switchKeyword;
			if (openParenToken != null)
			{
				this.AdjustFlagsAndWidth(openParenToken);
				this.openParenToken = openParenToken;
			}
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
			if (closeParenToken != null)
			{
				this.AdjustFlagsAndWidth(closeParenToken);
				this.closeParenToken = closeParenToken;
			}
			this.AdjustFlagsAndWidth(openBraceToken);
			this.openBraceToken = openBraceToken;
			if (sections != null)
			{
				this.AdjustFlagsAndWidth(sections);
				this.sections = sections;
			}
			this.AdjustFlagsAndWidth(closeBraceToken);
			this.closeBraceToken = closeBraceToken;
		}

		/// <summary>
		/// Gets a SyntaxToken that represents the switch keyword.
		/// </summary>
		public SyntaxToken SwitchKeyword { get { return this.switchKeyword; } }
		/// <summary>
		/// Gets a SyntaxToken that represents the open parenthesis preceding the switch governing expression.
		/// </summary>
		public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
		/// <summary>
		/// Gets an ExpressionSyntax representing the expression of the switch statement.
		/// </summary>
		public ExpressionSyntax Expression { get { return this.expression; } }
		/// <summary>
		/// Gets a SyntaxToken that represents the close parenthesis following the switch governing expression.
		/// </summary>
		public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }
		/// <summary>
		/// Gets a SyntaxToken that represents the open braces preceding the switch sections.
		/// </summary>
		public SyntaxToken OpenBraceToken { get { return this.openBraceToken; } }
		/// <summary>
		/// Gets a SyntaxList of SwitchSectionSyntax's that represents the switch sections of the switch statement.
		/// </summary>
		public SyntaxList<SwitchSectionSyntax> Sections { get { return new SyntaxList<SwitchSectionSyntax>(this.sections); } }
		/// <summary>
		/// Gets a SyntaxToken that represents the open braces following the switch sections.
		/// </summary>
		public SyntaxToken CloseBraceToken { get { return this.closeBraceToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.switchKeyword;
				case 1: return this.openParenToken;
				case 2: return this.expression;
				case 3: return this.closeParenToken;
				case 4: return this.openBraceToken;
				case 5: return this.sections;
				case 6: return this.closeBraceToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitSwitchStatement(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitSwitchStatement(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new SwitchStatementSyntax(this.Kind, this.switchKeyword, this.openParenToken, this.expression, this.closeParenToken, this.openBraceToken, this.sections, this.closeBraceToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new SwitchStatementSyntax(this.Kind, this.switchKeyword, this.openParenToken, this.expression, this.closeParenToken, this.openBraceToken, this.sections, this.closeBraceToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Represents a switch section syntax of a switch statement.</summary>
	public sealed partial class SwitchSectionSyntax : LeeSyntaxNode
	{
		public readonly GreenNode labels;
		public readonly GreenNode statements;

		public SwitchSectionSyntax(SyntaxKind kind, GreenNode labels, GreenNode statements, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			if (labels != null)
			{
				this.AdjustFlagsAndWidth(labels);
				this.labels = labels;
			}
			if (statements != null)
			{
				this.AdjustFlagsAndWidth(statements);
				this.statements = statements;
			}
		}


		public SwitchSectionSyntax(SyntaxKind kind, GreenNode labels, GreenNode statements, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			if (labels != null)
			{
				this.AdjustFlagsAndWidth(labels);
				this.labels = labels;
			}
			if (statements != null)
			{
				this.AdjustFlagsAndWidth(statements);
				this.statements = statements;
			}
		}


		public SwitchSectionSyntax(SyntaxKind kind, GreenNode labels, GreenNode statements)
			: base(kind)
		{
			this.SlotCount = 2;
			if (labels != null)
			{
				this.AdjustFlagsAndWidth(labels);
				this.labels = labels;
			}
			if (statements != null)
			{
				this.AdjustFlagsAndWidth(statements);
				this.statements = statements;
			}
		}

		/// <summary>
		/// Gets a SyntaxList of SwitchLabelSyntax's the represents the possible labels that control can transfer to within the section.
		/// </summary>
		public SyntaxList<SwitchLabelSyntax> Labels { get { return new SyntaxList<SwitchLabelSyntax>(this.labels); } }
		/// <summary>
		/// Gets a SyntaxList of StatementSyntax's the represents the statements to be executed when control transfer to a label the belongs to the section.
		/// </summary>
		public SyntaxList<StatementSyntax> Statements { get { return new SyntaxList<StatementSyntax>(this.statements); } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.labels;
				case 1: return this.statements;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitSwitchSection(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitSwitchSection(this);
		}


		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new SwitchSectionSyntax(this.Kind, this.labels, this.statements, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new SwitchSectionSyntax(this.Kind, this.labels, this.statements, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Represents a switch label within a switch statement.</summary>
	public abstract partial class SwitchLabelSyntax : LeeSyntaxNode
	{
		public SwitchLabelSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
		  : base(kind, diagnostics, annotations)
		{
		}
		public SwitchLabelSyntax(SyntaxKind kind)
		  : base(kind)
		{
		}

		/// <summary>
		/// Gets a SyntaxToken that represents a case or default keyword that belongs to a switch label.
		/// </summary>
		public abstract SyntaxToken Keyword { get; }

		/// <summary>
		/// Gets a SyntaxToken that represents the colon that terminates the switch label.
		/// </summary>
		public abstract SyntaxToken ColonToken { get; }
	}

	/// <summary>Represents a case label within a switch statement.</summary>
	public sealed partial class CasePatternSwitchLabelSyntax : SwitchLabelSyntax
	{
		public readonly SyntaxToken keyword;
		public readonly PatternSyntax pattern;
		public readonly WhenClauseSyntax whenClause;
		public readonly SyntaxToken colonToken;

		public CasePatternSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken colonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
			this.AdjustFlagsAndWidth(pattern);
			this.pattern = pattern;
			if (whenClause != null)
			{
				this.AdjustFlagsAndWidth(whenClause);
				this.whenClause = whenClause;
			}
			this.AdjustFlagsAndWidth(colonToken);
			this.colonToken = colonToken;
		}


		public CasePatternSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken colonToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
			this.AdjustFlagsAndWidth(pattern);
			this.pattern = pattern;
			if (whenClause != null)
			{
				this.AdjustFlagsAndWidth(whenClause);
				this.whenClause = whenClause;
			}
			this.AdjustFlagsAndWidth(colonToken);
			this.colonToken = colonToken;
		}


		public CasePatternSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken colonToken)
			: base(kind)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
			this.AdjustFlagsAndWidth(pattern);
			this.pattern = pattern;
			if (whenClause != null)
			{
				this.AdjustFlagsAndWidth(whenClause);
				this.whenClause = whenClause;
			}
			this.AdjustFlagsAndWidth(colonToken);
			this.colonToken = colonToken;
		}

		/// <summary>Gets the case keyword token.</summary>
		public override SyntaxToken Keyword { get { return this.keyword; } }
		/// <summary>
		/// Gets a PatternSyntax that represents the pattern that gets matched for the case label.
		/// </summary>
		public PatternSyntax Pattern { get { return this.pattern; } }
		public WhenClauseSyntax WhenClause { get { return this.whenClause; } }
		public override SyntaxToken ColonToken { get { return this.colonToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.keyword;
				case 1: return this.pattern;
				case 2: return this.whenClause;
				case 3: return this.colonToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitCasePatternSwitchLabel(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitCasePatternSwitchLabel(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new CasePatternSwitchLabelSyntax(this.Kind, this.keyword, this.pattern, this.whenClause, this.colonToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new CasePatternSwitchLabelSyntax(this.Kind, this.keyword, this.pattern, this.whenClause, this.colonToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Represents a case label within a switch statement.</summary>
	public sealed partial class CaseSwitchLabelSyntax : SwitchLabelSyntax
	{
		public readonly SyntaxToken keyword;
		public readonly ExpressionSyntax value;
		public readonly SyntaxToken colonToken;

		public CaseSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
			this.AdjustFlagsAndWidth(value);
			this.value = value;
			this.AdjustFlagsAndWidth(colonToken);
			this.colonToken = colonToken;
		}


		public CaseSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
			this.AdjustFlagsAndWidth(value);
			this.value = value;
			this.AdjustFlagsAndWidth(colonToken);
			this.colonToken = colonToken;
		}


		public CaseSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
			this.AdjustFlagsAndWidth(value);
			this.value = value;
			this.AdjustFlagsAndWidth(colonToken);
			this.colonToken = colonToken;
		}

		/// <summary>Gets the case keyword token.</summary>
		public override SyntaxToken Keyword { get { return this.keyword; } }
		/// <summary>
		/// Gets an ExpressionSyntax that represents the constant expression that gets matched for the case label.
		/// </summary>
		public ExpressionSyntax Value { get { return this.value; } }
		public override SyntaxToken ColonToken { get { return this.colonToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.keyword;
				case 1: return this.value;
				case 2: return this.colonToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitCaseSwitchLabel(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitCaseSwitchLabel(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new CaseSwitchLabelSyntax(this.Kind, this.keyword, this.value, this.colonToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new CaseSwitchLabelSyntax(this.Kind, this.keyword, this.value, this.colonToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Represents a default label within a switch statement.</summary>
	public sealed partial class DefaultSwitchLabelSyntax : SwitchLabelSyntax
	{
		public readonly SyntaxToken keyword;
		public readonly SyntaxToken colonToken;

		public DefaultSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken colonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
			this.AdjustFlagsAndWidth(colonToken);
			this.colonToken = colonToken;
		}


		public DefaultSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken colonToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
			this.AdjustFlagsAndWidth(colonToken);
			this.colonToken = colonToken;
		}


		public DefaultSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken colonToken)
			: base(kind)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
			this.AdjustFlagsAndWidth(colonToken);
			this.colonToken = colonToken;
		}

		/// <summary>Gets the default keyword token.</summary>
		public override SyntaxToken Keyword { get { return this.keyword; } }
		public override SyntaxToken ColonToken { get { return this.colonToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.keyword;
				case 1: return this.colonToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitDefaultSwitchLabel(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitDefaultSwitchLabel(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new DefaultSwitchLabelSyntax(this.Kind, this.keyword, this.colonToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new DefaultSwitchLabelSyntax(this.Kind, this.keyword, this.colonToken, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class SwitchExpressionSyntax : ExpressionSyntax
	{
		public readonly ExpressionSyntax governingExpression;
		public readonly SyntaxToken switchKeyword;
		public readonly SyntaxToken openBraceToken;
		public readonly GreenNode arms;
		public readonly SyntaxToken closeBraceToken;

		public SwitchExpressionSyntax(SyntaxKind kind, ExpressionSyntax governingExpression, SyntaxToken switchKeyword, SyntaxToken openBraceToken, GreenNode arms, SyntaxToken closeBraceToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 5;
			this.AdjustFlagsAndWidth(governingExpression);
			this.governingExpression = governingExpression;
			this.AdjustFlagsAndWidth(switchKeyword);
			this.switchKeyword = switchKeyword;
			this.AdjustFlagsAndWidth(openBraceToken);
			this.openBraceToken = openBraceToken;
			if (arms != null)
			{
				this.AdjustFlagsAndWidth(arms);
				this.arms = arms;
			}
			this.AdjustFlagsAndWidth(closeBraceToken);
			this.closeBraceToken = closeBraceToken;
		}


		public SwitchExpressionSyntax(SyntaxKind kind, ExpressionSyntax governingExpression, SyntaxToken switchKeyword, SyntaxToken openBraceToken, GreenNode arms, SyntaxToken closeBraceToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 5;
			this.AdjustFlagsAndWidth(governingExpression);
			this.governingExpression = governingExpression;
			this.AdjustFlagsAndWidth(switchKeyword);
			this.switchKeyword = switchKeyword;
			this.AdjustFlagsAndWidth(openBraceToken);
			this.openBraceToken = openBraceToken;
			if (arms != null)
			{
				this.AdjustFlagsAndWidth(arms);
				this.arms = arms;
			}
			this.AdjustFlagsAndWidth(closeBraceToken);
			this.closeBraceToken = closeBraceToken;
		}


		public SwitchExpressionSyntax(SyntaxKind kind, ExpressionSyntax governingExpression, SyntaxToken switchKeyword, SyntaxToken openBraceToken, GreenNode arms, SyntaxToken closeBraceToken)
			: base(kind)
		{
			this.SlotCount = 5;
			this.AdjustFlagsAndWidth(governingExpression);
			this.governingExpression = governingExpression;
			this.AdjustFlagsAndWidth(switchKeyword);
			this.switchKeyword = switchKeyword;
			this.AdjustFlagsAndWidth(openBraceToken);
			this.openBraceToken = openBraceToken;
			if (arms != null)
			{
				this.AdjustFlagsAndWidth(arms);
				this.arms = arms;
			}
			this.AdjustFlagsAndWidth(closeBraceToken);
			this.closeBraceToken = closeBraceToken;
		}

		public ExpressionSyntax GoverningExpression { get { return this.governingExpression; } }
		public SyntaxToken SwitchKeyword { get { return this.switchKeyword; } }
		public SyntaxToken OpenBraceToken { get { return this.openBraceToken; } }
		public SeparatedSyntaxList<SwitchExpressionArmSyntax> Arms { get { return new SeparatedSyntaxList<SwitchExpressionArmSyntax>(new SyntaxList<LeeSyntaxNode>(this.arms)); } }
		public SyntaxToken CloseBraceToken { get { return this.closeBraceToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.governingExpression;
				case 1: return this.switchKeyword;
				case 2: return this.openBraceToken;
				case 3: return this.arms;
				case 4: return this.closeBraceToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitSwitchExpression(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitSwitchExpression(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new SwitchExpressionSyntax(this.Kind, this.governingExpression, this.switchKeyword, this.openBraceToken, this.arms, this.closeBraceToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new SwitchExpressionSyntax(this.Kind, this.governingExpression, this.switchKeyword, this.openBraceToken, this.arms, this.closeBraceToken, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class SwitchExpressionArmSyntax : LeeSyntaxNode
	{
		public readonly PatternSyntax pattern;
		public readonly WhenClauseSyntax whenClause;
		public readonly SyntaxToken equalsGreaterThanToken;
		public readonly ExpressionSyntax expression;

		public SwitchExpressionArmSyntax(SyntaxKind kind, PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken equalsGreaterThanToken, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(pattern);
			this.pattern = pattern;
			if (whenClause != null)
			{
				this.AdjustFlagsAndWidth(whenClause);
				this.whenClause = whenClause;
			}
			this.AdjustFlagsAndWidth(equalsGreaterThanToken);
			this.equalsGreaterThanToken = equalsGreaterThanToken;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
		}


		public SwitchExpressionArmSyntax(SyntaxKind kind, PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken equalsGreaterThanToken, ExpressionSyntax expression, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(pattern);
			this.pattern = pattern;
			if (whenClause != null)
			{
				this.AdjustFlagsAndWidth(whenClause);
				this.whenClause = whenClause;
			}
			this.AdjustFlagsAndWidth(equalsGreaterThanToken);
			this.equalsGreaterThanToken = equalsGreaterThanToken;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
		}


		public SwitchExpressionArmSyntax(SyntaxKind kind, PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken equalsGreaterThanToken, ExpressionSyntax expression)
			: base(kind)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(pattern);
			this.pattern = pattern;
			if (whenClause != null)
			{
				this.AdjustFlagsAndWidth(whenClause);
				this.whenClause = whenClause;
			}
			this.AdjustFlagsAndWidth(equalsGreaterThanToken);
			this.equalsGreaterThanToken = equalsGreaterThanToken;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
		}

		public PatternSyntax Pattern { get { return this.pattern; } }
		public WhenClauseSyntax WhenClause { get { return this.whenClause; } }
		public SyntaxToken EqualsGreaterThanToken { get { return this.equalsGreaterThanToken; } }
		public ExpressionSyntax Expression { get { return this.expression; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.pattern;
				case 1: return this.whenClause;
				case 2: return this.equalsGreaterThanToken;
				case 3: return this.expression;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitSwitchExpressionArm(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitSwitchExpressionArm(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new SwitchExpressionArmSyntax(this.Kind, this.pattern, this.whenClause, this.equalsGreaterThanToken, this.expression, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new SwitchExpressionArmSyntax(this.Kind, this.pattern, this.whenClause, this.equalsGreaterThanToken, this.expression, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class TryStatementSyntax : StatementSyntax
	{
		public readonly SyntaxToken tryKeyword;
		public readonly BlockSyntax block;
		public readonly GreenNode catches;
		public readonly FinallyClauseSyntax @finally;

		public TryStatementSyntax(SyntaxKind kind, SyntaxToken tryKeyword, BlockSyntax block, GreenNode catches, FinallyClauseSyntax @finally, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(tryKeyword);
			this.tryKeyword = tryKeyword;
			this.AdjustFlagsAndWidth(block);
			this.block = block;
			if (catches != null)
			{
				this.AdjustFlagsAndWidth(catches);
				this.catches = catches;
			}
			if (@finally != null)
			{
				this.AdjustFlagsAndWidth(@finally);
				this.@finally = @finally;
			}
		}


		public TryStatementSyntax(SyntaxKind kind, SyntaxToken tryKeyword, BlockSyntax block, GreenNode catches, FinallyClauseSyntax @finally, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(tryKeyword);
			this.tryKeyword = tryKeyword;
			this.AdjustFlagsAndWidth(block);
			this.block = block;
			if (catches != null)
			{
				this.AdjustFlagsAndWidth(catches);
				this.catches = catches;
			}
			if (@finally != null)
			{
				this.AdjustFlagsAndWidth(@finally);
				this.@finally = @finally;
			}
		}


		public TryStatementSyntax(SyntaxKind kind, SyntaxToken tryKeyword, BlockSyntax block, GreenNode catches, FinallyClauseSyntax @finally)
			: base(kind)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(tryKeyword);
			this.tryKeyword = tryKeyword;
			this.AdjustFlagsAndWidth(block);
			this.block = block;
			if (catches != null)
			{
				this.AdjustFlagsAndWidth(catches);
				this.catches = catches;
			}
			if (@finally != null)
			{
				this.AdjustFlagsAndWidth(@finally);
				this.@finally = @finally;
			}
		}

		public SyntaxToken TryKeyword { get { return this.tryKeyword; } }
		public BlockSyntax Block { get { return this.block; } }
		public SyntaxList<CatchClauseSyntax> Catches { get { return new SyntaxList<CatchClauseSyntax>(this.catches); } }
		public FinallyClauseSyntax Finally { get { return this.@finally; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.tryKeyword;
				case 1: return this.block;
				case 2: return this.catches;
				case 3: return this.@finally;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitTryStatement(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitTryStatement(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new TryStatementSyntax(this.Kind, this.tryKeyword, this.block, this.catches, this.@finally, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new TryStatementSyntax(this.Kind, this.tryKeyword, this.block, this.catches, this.@finally, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class CatchClauseSyntax : LeeSyntaxNode
	{
		public readonly SyntaxToken catchKeyword;
		public readonly CatchDeclarationSyntax declaration;
		public readonly CatchFilterClauseSyntax filter;
		public readonly BlockSyntax block;

		public CatchClauseSyntax(SyntaxKind kind, SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(catchKeyword);
			this.catchKeyword = catchKeyword;
			if (declaration != null)
			{
				this.AdjustFlagsAndWidth(declaration);
				this.declaration = declaration;
			}
			if (filter != null)
			{
				this.AdjustFlagsAndWidth(filter);
				this.filter = filter;
			}
			this.AdjustFlagsAndWidth(block);
			this.block = block;
		}


		public CatchClauseSyntax(SyntaxKind kind, SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(catchKeyword);
			this.catchKeyword = catchKeyword;
			if (declaration != null)
			{
				this.AdjustFlagsAndWidth(declaration);
				this.declaration = declaration;
			}
			if (filter != null)
			{
				this.AdjustFlagsAndWidth(filter);
				this.filter = filter;
			}
			this.AdjustFlagsAndWidth(block);
			this.block = block;
		}


		public CatchClauseSyntax(SyntaxKind kind, SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block)
			: base(kind)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(catchKeyword);
			this.catchKeyword = catchKeyword;
			if (declaration != null)
			{
				this.AdjustFlagsAndWidth(declaration);
				this.declaration = declaration;
			}
			if (filter != null)
			{
				this.AdjustFlagsAndWidth(filter);
				this.filter = filter;
			}
			this.AdjustFlagsAndWidth(block);
			this.block = block;
		}

		public SyntaxToken CatchKeyword { get { return this.catchKeyword; } }
		public CatchDeclarationSyntax Declaration { get { return this.declaration; } }
		public CatchFilterClauseSyntax Filter { get { return this.filter; } }
		public BlockSyntax Block { get { return this.block; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.catchKeyword;
				case 1: return this.declaration;
				case 2: return this.filter;
				case 3: return this.block;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitCatchClause(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitCatchClause(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new CatchClauseSyntax(this.Kind, this.catchKeyword, this.declaration, this.filter, this.block, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new CatchClauseSyntax(this.Kind, this.catchKeyword, this.declaration, this.filter, this.block, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class CatchDeclarationSyntax : LeeSyntaxNode
	{
		public readonly SyntaxToken openParenToken;
		public readonly TypeSyntax type;
		public readonly SyntaxToken identifier;
		public readonly SyntaxToken closeParenToken;

		public CatchDeclarationSyntax(SyntaxKind kind, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			if (identifier != null)
			{
				this.AdjustFlagsAndWidth(identifier);
				this.identifier = identifier;
			}
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}


		public CatchDeclarationSyntax(SyntaxKind kind, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			if (identifier != null)
			{
				this.AdjustFlagsAndWidth(identifier);
				this.identifier = identifier;
			}
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}


		public CatchDeclarationSyntax(SyntaxKind kind, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken)
			: base(kind)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			if (identifier != null)
			{
				this.AdjustFlagsAndWidth(identifier);
				this.identifier = identifier;
			}
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}

		public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
		public TypeSyntax Type { get { return this.type; } }
		public SyntaxToken Identifier { get { return this.identifier; } }
		public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.openParenToken;
				case 1: return this.type;
				case 2: return this.identifier;
				case 3: return this.closeParenToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitCatchDeclaration(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitCatchDeclaration(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new CatchDeclarationSyntax(this.Kind, this.openParenToken, this.type, this.identifier, this.closeParenToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new CatchDeclarationSyntax(this.Kind, this.openParenToken, this.type, this.identifier, this.closeParenToken, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class CatchFilterClauseSyntax : LeeSyntaxNode
	{
		public readonly SyntaxToken whenKeyword;
		public readonly SyntaxToken openParenToken;
		public readonly ExpressionSyntax filterExpression;
		public readonly SyntaxToken closeParenToken;

		public CatchFilterClauseSyntax(SyntaxKind kind, SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(whenKeyword);
			this.whenKeyword = whenKeyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(filterExpression);
			this.filterExpression = filterExpression;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}


		public CatchFilterClauseSyntax(SyntaxKind kind, SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(whenKeyword);
			this.whenKeyword = whenKeyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(filterExpression);
			this.filterExpression = filterExpression;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}


		public CatchFilterClauseSyntax(SyntaxKind kind, SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken)
			: base(kind)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(whenKeyword);
			this.whenKeyword = whenKeyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(filterExpression);
			this.filterExpression = filterExpression;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}

		public SyntaxToken WhenKeyword { get { return this.whenKeyword; } }
		public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
		public ExpressionSyntax FilterExpression { get { return this.filterExpression; } }
		public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.whenKeyword;
				case 1: return this.openParenToken;
				case 2: return this.filterExpression;
				case 3: return this.closeParenToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitCatchFilterClause(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitCatchFilterClause(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new CatchFilterClauseSyntax(this.Kind, this.whenKeyword, this.openParenToken, this.filterExpression, this.closeParenToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new CatchFilterClauseSyntax(this.Kind, this.whenKeyword, this.openParenToken, this.filterExpression, this.closeParenToken, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class FinallyClauseSyntax : LeeSyntaxNode
	{
		public readonly SyntaxToken finallyKeyword;
		public readonly BlockSyntax block;

		public FinallyClauseSyntax(SyntaxKind kind, SyntaxToken finallyKeyword, BlockSyntax block, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(finallyKeyword);
			this.finallyKeyword = finallyKeyword;
			this.AdjustFlagsAndWidth(block);
			this.block = block;
		}


		public FinallyClauseSyntax(SyntaxKind kind, SyntaxToken finallyKeyword, BlockSyntax block, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(finallyKeyword);
			this.finallyKeyword = finallyKeyword;
			this.AdjustFlagsAndWidth(block);
			this.block = block;
		}


		public FinallyClauseSyntax(SyntaxKind kind, SyntaxToken finallyKeyword, BlockSyntax block)
			: base(kind)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(finallyKeyword);
			this.finallyKeyword = finallyKeyword;
			this.AdjustFlagsAndWidth(block);
			this.block = block;
		}

		public SyntaxToken FinallyKeyword { get { return this.finallyKeyword; } }
		public BlockSyntax Block { get { return this.block; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.finallyKeyword;
				case 1: return this.block;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitFinallyClause(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitFinallyClause(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new FinallyClauseSyntax(this.Kind, this.finallyKeyword, this.block, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new FinallyClauseSyntax(this.Kind, this.finallyKeyword, this.block, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class CompilationUnitSyntax : LeeSyntaxNode
	{
		public readonly GreenNode externs;
		public readonly GreenNode usings;
		public readonly GreenNode attributeLists;
		public readonly GreenNode members;
		public readonly SyntaxToken endOfFileToken;

		public CompilationUnitSyntax(SyntaxKind kind, GreenNode externs, GreenNode usings, GreenNode attributeLists, GreenNode members, SyntaxToken endOfFileToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 5;
			if (externs != null)
			{
				this.AdjustFlagsAndWidth(externs);
				this.externs = externs;
			}
			if (usings != null)
			{
				this.AdjustFlagsAndWidth(usings);
				this.usings = usings;
			}
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (members != null)
			{
				this.AdjustFlagsAndWidth(members);
				this.members = members;
			}
			this.AdjustFlagsAndWidth(endOfFileToken);
			this.endOfFileToken = endOfFileToken;
		}


		public CompilationUnitSyntax(SyntaxKind kind, GreenNode externs, GreenNode usings, GreenNode attributeLists, GreenNode members, SyntaxToken endOfFileToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 5;
			if (externs != null)
			{
				this.AdjustFlagsAndWidth(externs);
				this.externs = externs;
			}
			if (usings != null)
			{
				this.AdjustFlagsAndWidth(usings);
				this.usings = usings;
			}
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (members != null)
			{
				this.AdjustFlagsAndWidth(members);
				this.members = members;
			}
			this.AdjustFlagsAndWidth(endOfFileToken);
			this.endOfFileToken = endOfFileToken;
		}


		public CompilationUnitSyntax(SyntaxKind kind, GreenNode externs, GreenNode usings, GreenNode attributeLists, GreenNode members, SyntaxToken endOfFileToken)
			: base(kind)
		{
			this.SlotCount = 5;
			if (externs != null)
			{
				this.AdjustFlagsAndWidth(externs);
				this.externs = externs;
			}
			if (usings != null)
			{
				this.AdjustFlagsAndWidth(usings);
				this.usings = usings;
			}
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (members != null)
			{
				this.AdjustFlagsAndWidth(members);
				this.members = members;
			}
			this.AdjustFlagsAndWidth(endOfFileToken);
			this.endOfFileToken = endOfFileToken;
		}

		public SyntaxList<ExternAliasDirectiveSyntax> Externs { get { return new SyntaxList<ExternAliasDirectiveSyntax>(this.externs); } }
		public SyntaxList<UsingDirectiveSyntax> Usings { get { return new SyntaxList<UsingDirectiveSyntax>(this.usings); } }
		/// <summary>Gets the attribute declaration list.</summary>
		public SyntaxList<AttributeListSyntax> AttributeLists { get { return new SyntaxList<AttributeListSyntax>(this.attributeLists); } }
		public SyntaxList<MemberDeclarationSyntax> Members { get { return new SyntaxList<MemberDeclarationSyntax>(this.members); } }
		public SyntaxToken EndOfFileToken { get { return this.endOfFileToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.externs;
				case 1: return this.usings;
				case 2: return this.attributeLists;
				case 3: return this.members;
				case 4: return this.endOfFileToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitCompilationUnit(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitCompilationUnit(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new CompilationUnitSyntax(this.Kind, this.externs, this.usings, this.attributeLists, this.members, this.endOfFileToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new CompilationUnitSyntax(this.Kind, this.externs, this.usings, this.attributeLists, this.members, this.endOfFileToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>
	/// Represents an ExternAlias directive syntax, e.g. "extern alias MyAlias;" with specifying "/r:MyAlias=SomeAssembly.dll " on the compiler command line.
	/// </summary>
	public sealed partial class ExternAliasDirectiveSyntax : LeeSyntaxNode
	{
		public readonly SyntaxToken externKeyword;
		public readonly SyntaxToken aliasKeyword;
		public readonly SyntaxToken identifier;
		public readonly SyntaxToken semicolonToken;

		public ExternAliasDirectiveSyntax(SyntaxKind kind, SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(externKeyword);
			this.externKeyword = externKeyword;
			this.AdjustFlagsAndWidth(aliasKeyword);
			this.aliasKeyword = aliasKeyword;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			this.AdjustFlagsAndWidth(semicolonToken);
			this.semicolonToken = semicolonToken;
		}


		public ExternAliasDirectiveSyntax(SyntaxKind kind, SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(externKeyword);
			this.externKeyword = externKeyword;
			this.AdjustFlagsAndWidth(aliasKeyword);
			this.aliasKeyword = aliasKeyword;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			this.AdjustFlagsAndWidth(semicolonToken);
			this.semicolonToken = semicolonToken;
		}


		public ExternAliasDirectiveSyntax(SyntaxKind kind, SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken)
			: base(kind)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(externKeyword);
			this.externKeyword = externKeyword;
			this.AdjustFlagsAndWidth(aliasKeyword);
			this.aliasKeyword = aliasKeyword;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			this.AdjustFlagsAndWidth(semicolonToken);
			this.semicolonToken = semicolonToken;
		}

		/// <summary>SyntaxToken representing the extern keyword.</summary>
		public SyntaxToken ExternKeyword { get { return this.externKeyword; } }
		/// <summary>SyntaxToken representing the alias keyword.</summary>
		public SyntaxToken AliasKeyword { get { return this.aliasKeyword; } }
		/// <summary>Gets the identifier.</summary>
		public SyntaxToken Identifier { get { return this.identifier; } }
		/// <summary>SyntaxToken representing the semicolon token.</summary>
		public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.externKeyword;
				case 1: return this.aliasKeyword;
				case 2: return this.identifier;
				case 3: return this.semicolonToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitExternAliasDirective(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitExternAliasDirective(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new ExternAliasDirectiveSyntax(this.Kind, this.externKeyword, this.aliasKeyword, this.identifier, this.semicolonToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new ExternAliasDirectiveSyntax(this.Kind, this.externKeyword, this.aliasKeyword, this.identifier, this.semicolonToken, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class UsingDirectiveSyntax : LeeSyntaxNode
	{
		public readonly SyntaxToken usingKeyword;
		public readonly SyntaxToken staticKeyword;
		public readonly NameEqualsSyntax alias;
		public readonly NameSyntax name;
		public readonly SyntaxToken semicolonToken;

		public UsingDirectiveSyntax(SyntaxKind kind, SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 5;
			this.AdjustFlagsAndWidth(usingKeyword);
			this.usingKeyword = usingKeyword;
			if (staticKeyword != null)
			{
				this.AdjustFlagsAndWidth(staticKeyword);
				this.staticKeyword = staticKeyword;
			}
			if (alias != null)
			{
				this.AdjustFlagsAndWidth(alias);
				this.alias = alias;
			}
			this.AdjustFlagsAndWidth(name);
			this.name = name;
			this.AdjustFlagsAndWidth(semicolonToken);
			this.semicolonToken = semicolonToken;
		}


		public UsingDirectiveSyntax(SyntaxKind kind, SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name, SyntaxToken semicolonToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 5;
			this.AdjustFlagsAndWidth(usingKeyword);
			this.usingKeyword = usingKeyword;
			if (staticKeyword != null)
			{
				this.AdjustFlagsAndWidth(staticKeyword);
				this.staticKeyword = staticKeyword;
			}
			if (alias != null)
			{
				this.AdjustFlagsAndWidth(alias);
				this.alias = alias;
			}
			this.AdjustFlagsAndWidth(name);
			this.name = name;
			this.AdjustFlagsAndWidth(semicolonToken);
			this.semicolonToken = semicolonToken;
		}


		public UsingDirectiveSyntax(SyntaxKind kind, SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name, SyntaxToken semicolonToken)
			: base(kind)
		{
			this.SlotCount = 5;
			this.AdjustFlagsAndWidth(usingKeyword);
			this.usingKeyword = usingKeyword;
			if (staticKeyword != null)
			{
				this.AdjustFlagsAndWidth(staticKeyword);
				this.staticKeyword = staticKeyword;
			}
			if (alias != null)
			{
				this.AdjustFlagsAndWidth(alias);
				this.alias = alias;
			}
			this.AdjustFlagsAndWidth(name);
			this.name = name;
			this.AdjustFlagsAndWidth(semicolonToken);
			this.semicolonToken = semicolonToken;
		}

		public SyntaxToken UsingKeyword { get { return this.usingKeyword; } }
		public SyntaxToken StaticKeyword { get { return this.staticKeyword; } }
		public NameEqualsSyntax Alias { get { return this.alias; } }
		public NameSyntax Name { get { return this.name; } }
		public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.usingKeyword;
				case 1: return this.staticKeyword;
				case 2: return this.alias;
				case 3: return this.name;
				case 4: return this.semicolonToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitUsingDirective(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitUsingDirective(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new UsingDirectiveSyntax(this.Kind, this.usingKeyword, this.staticKeyword, this.alias, this.name, this.semicolonToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new UsingDirectiveSyntax(this.Kind, this.usingKeyword, this.staticKeyword, this.alias, this.name, this.semicolonToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Member declaration syntax.</summary>
	public abstract partial class MemberDeclarationSyntax : LeeSyntaxNode
	{
		public MemberDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
		  : base(kind, diagnostics, annotations)
		{
		}
		public MemberDeclarationSyntax(SyntaxKind kind)
		  : base(kind)
		{
		}
	}

	public sealed partial class NamespaceDeclarationSyntax : MemberDeclarationSyntax
	{
		public readonly SyntaxToken namespaceKeyword;
		public readonly NameSyntax name;
		public readonly SyntaxToken openBraceToken;
		public readonly GreenNode externs;
		public readonly GreenNode usings;
		public readonly GreenNode members;
		public readonly SyntaxToken closeBraceToken;
		public readonly SyntaxToken semicolonToken;

		public NamespaceDeclarationSyntax(SyntaxKind kind, SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, GreenNode externs, GreenNode usings, GreenNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 8;
			this.AdjustFlagsAndWidth(namespaceKeyword);
			this.namespaceKeyword = namespaceKeyword;
			this.AdjustFlagsAndWidth(name);
			this.name = name;
			this.AdjustFlagsAndWidth(openBraceToken);
			this.openBraceToken = openBraceToken;
			if (externs != null)
			{
				this.AdjustFlagsAndWidth(externs);
				this.externs = externs;
			}
			if (usings != null)
			{
				this.AdjustFlagsAndWidth(usings);
				this.usings = usings;
			}
			if (members != null)
			{
				this.AdjustFlagsAndWidth(members);
				this.members = members;
			}
			this.AdjustFlagsAndWidth(closeBraceToken);
			this.closeBraceToken = closeBraceToken;
			if (semicolonToken != null)
			{
				this.AdjustFlagsAndWidth(semicolonToken);
				this.semicolonToken = semicolonToken;
			}
		}


		public NamespaceDeclarationSyntax(SyntaxKind kind, SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, GreenNode externs, GreenNode usings, GreenNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 8;
			this.AdjustFlagsAndWidth(namespaceKeyword);
			this.namespaceKeyword = namespaceKeyword;
			this.AdjustFlagsAndWidth(name);
			this.name = name;
			this.AdjustFlagsAndWidth(openBraceToken);
			this.openBraceToken = openBraceToken;
			if (externs != null)
			{
				this.AdjustFlagsAndWidth(externs);
				this.externs = externs;
			}
			if (usings != null)
			{
				this.AdjustFlagsAndWidth(usings);
				this.usings = usings;
			}
			if (members != null)
			{
				this.AdjustFlagsAndWidth(members);
				this.members = members;
			}
			this.AdjustFlagsAndWidth(closeBraceToken);
			this.closeBraceToken = closeBraceToken;
			if (semicolonToken != null)
			{
				this.AdjustFlagsAndWidth(semicolonToken);
				this.semicolonToken = semicolonToken;
			}
		}


		public NamespaceDeclarationSyntax(SyntaxKind kind, SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, GreenNode externs, GreenNode usings, GreenNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
			: base(kind)
		{
			this.SlotCount = 8;
			this.AdjustFlagsAndWidth(namespaceKeyword);
			this.namespaceKeyword = namespaceKeyword;
			this.AdjustFlagsAndWidth(name);
			this.name = name;
			this.AdjustFlagsAndWidth(openBraceToken);
			this.openBraceToken = openBraceToken;
			if (externs != null)
			{
				this.AdjustFlagsAndWidth(externs);
				this.externs = externs;
			}
			if (usings != null)
			{
				this.AdjustFlagsAndWidth(usings);
				this.usings = usings;
			}
			if (members != null)
			{
				this.AdjustFlagsAndWidth(members);
				this.members = members;
			}
			this.AdjustFlagsAndWidth(closeBraceToken);
			this.closeBraceToken = closeBraceToken;
			if (semicolonToken != null)
			{
				this.AdjustFlagsAndWidth(semicolonToken);
				this.semicolonToken = semicolonToken;
			}
		}

		public SyntaxToken NamespaceKeyword { get { return this.namespaceKeyword; } }
		public NameSyntax Name { get { return this.name; } }
		public SyntaxToken OpenBraceToken { get { return this.openBraceToken; } }
		public SyntaxList<ExternAliasDirectiveSyntax> Externs { get { return new SyntaxList<ExternAliasDirectiveSyntax>(this.externs); } }
		public SyntaxList<UsingDirectiveSyntax> Usings { get { return new SyntaxList<UsingDirectiveSyntax>(this.usings); } }
		public SyntaxList<MemberDeclarationSyntax> Members { get { return new SyntaxList<MemberDeclarationSyntax>(this.members); } }
		public SyntaxToken CloseBraceToken { get { return this.closeBraceToken; } }
		/// <summary>Gets the optional semicolon token.</summary>
		public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.namespaceKeyword;
				case 1: return this.name;
				case 2: return this.openBraceToken;
				case 3: return this.externs;
				case 4: return this.usings;
				case 5: return this.members;
				case 6: return this.closeBraceToken;
				case 7: return this.semicolonToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitNamespaceDeclaration(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitNamespaceDeclaration(this);
		}
		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new NamespaceDeclarationSyntax(this.Kind, this.namespaceKeyword, this.name, this.openBraceToken, this.externs, this.usings, this.members, this.closeBraceToken, this.semicolonToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new NamespaceDeclarationSyntax(this.Kind, this.namespaceKeyword, this.name, this.openBraceToken, this.externs, this.usings, this.members, this.closeBraceToken, this.semicolonToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class representing one or more attributes applied to a language construct.</summary>
	public sealed partial class AttributeListSyntax : LeeSyntaxNode
	{
		public readonly SyntaxToken openBracketToken;
		public readonly AttributeTargetSpecifierSyntax target;
		public readonly GreenNode attributes;
		public readonly SyntaxToken closeBracketToken;

		public AttributeListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax target, GreenNode attributes, SyntaxToken closeBracketToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(openBracketToken);
			this.openBracketToken = openBracketToken;
			if (target != null)
			{
				this.AdjustFlagsAndWidth(target);
				this.target = target;
			}
			if (attributes != null)
			{
				this.AdjustFlagsAndWidth(attributes);
				this.attributes = attributes;
			}
			this.AdjustFlagsAndWidth(closeBracketToken);
			this.closeBracketToken = closeBracketToken;
		}


		public AttributeListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax target, GreenNode attributes, SyntaxToken closeBracketToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(openBracketToken);
			this.openBracketToken = openBracketToken;
			if (target != null)
			{
				this.AdjustFlagsAndWidth(target);
				this.target = target;
			}
			if (attributes != null)
			{
				this.AdjustFlagsAndWidth(attributes);
				this.attributes = attributes;
			}
			this.AdjustFlagsAndWidth(closeBracketToken);
			this.closeBracketToken = closeBracketToken;
		}


		public AttributeListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax target, GreenNode attributes, SyntaxToken closeBracketToken)
			: base(kind)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(openBracketToken);
			this.openBracketToken = openBracketToken;
			if (target != null)
			{
				this.AdjustFlagsAndWidth(target);
				this.target = target;
			}
			if (attributes != null)
			{
				this.AdjustFlagsAndWidth(attributes);
				this.attributes = attributes;
			}
			this.AdjustFlagsAndWidth(closeBracketToken);
			this.closeBracketToken = closeBracketToken;
		}

		/// <summary>Gets the open bracket token.</summary>
		public SyntaxToken OpenBracketToken { get { return this.openBracketToken; } }
		/// <summary>Gets the optional construct targeted by the attribute.</summary>
		public AttributeTargetSpecifierSyntax Target { get { return this.target; } }
		/// <summary>Gets the attribute declaration list.</summary>
		public SeparatedSyntaxList<AttributeSyntax> Attributes { get { return new SeparatedSyntaxList<AttributeSyntax>(new SyntaxList<LeeSyntaxNode>(this.attributes)); } }
		/// <summary>Gets the close bracket token.</summary>
		public SyntaxToken CloseBracketToken { get { return this.closeBracketToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.openBracketToken;
				case 1: return this.target;
				case 2: return this.attributes;
				case 3: return this.closeBracketToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitAttributeList(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitAttributeList(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new AttributeListSyntax(this.Kind, this.openBracketToken, this.target, this.attributes, this.closeBracketToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new AttributeListSyntax(this.Kind, this.openBracketToken, this.target, this.attributes, this.closeBracketToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class representing what language construct an attribute targets.</summary>
	public sealed partial class AttributeTargetSpecifierSyntax : LeeSyntaxNode
	{
		public readonly SyntaxToken identifier;
		public readonly SyntaxToken colonToken;

		public AttributeTargetSpecifierSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken colonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			this.AdjustFlagsAndWidth(colonToken);
			this.colonToken = colonToken;
		}


		public AttributeTargetSpecifierSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken colonToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			this.AdjustFlagsAndWidth(colonToken);
			this.colonToken = colonToken;
		}


		public AttributeTargetSpecifierSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken colonToken)
			: base(kind)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			this.AdjustFlagsAndWidth(colonToken);
			this.colonToken = colonToken;
		}

		/// <summary>Gets the identifier.</summary>
		public SyntaxToken Identifier { get { return this.identifier; } }
		/// <summary>Gets the colon token.</summary>
		public SyntaxToken ColonToken { get { return this.colonToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.identifier;
				case 1: return this.colonToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitAttributeTargetSpecifier(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitAttributeTargetSpecifier(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new AttributeTargetSpecifierSyntax(this.Kind, this.identifier, this.colonToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new AttributeTargetSpecifierSyntax(this.Kind, this.identifier, this.colonToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Attribute syntax.</summary>
	public sealed partial class AttributeSyntax : LeeSyntaxNode
	{
		public readonly NameSyntax name;
		public readonly AttributeArgumentListSyntax argumentList;

		public AttributeSyntax(SyntaxKind kind, NameSyntax name, AttributeArgumentListSyntax argumentList, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(name);
			this.name = name;
			if (argumentList != null)
			{
				this.AdjustFlagsAndWidth(argumentList);
				this.argumentList = argumentList;
			}
		}


		public AttributeSyntax(SyntaxKind kind, NameSyntax name, AttributeArgumentListSyntax argumentList, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(name);
			this.name = name;
			if (argumentList != null)
			{
				this.AdjustFlagsAndWidth(argumentList);
				this.argumentList = argumentList;
			}
		}


		public AttributeSyntax(SyntaxKind kind, NameSyntax name, AttributeArgumentListSyntax argumentList)
			: base(kind)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(name);
			this.name = name;
			if (argumentList != null)
			{
				this.AdjustFlagsAndWidth(argumentList);
				this.argumentList = argumentList;
			}
		}

		/// <summary>Gets the name.</summary>
		public NameSyntax Name { get { return this.name; } }
		public AttributeArgumentListSyntax ArgumentList { get { return this.argumentList; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.name;
				case 1: return this.argumentList;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitAttribute(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitAttribute(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new AttributeSyntax(this.Kind, this.name, this.argumentList, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new AttributeSyntax(this.Kind, this.name, this.argumentList, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Attribute argument list syntax.</summary>
	public sealed partial class AttributeArgumentListSyntax : LeeSyntaxNode
	{
		public readonly SyntaxToken openParenToken;
		public readonly GreenNode arguments;
		public readonly SyntaxToken closeParenToken;

		public AttributeArgumentListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode arguments, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			if (arguments != null)
			{
				this.AdjustFlagsAndWidth(arguments);
				this.arguments = arguments;
			}
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}


		public AttributeArgumentListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode arguments, SyntaxToken closeParenToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			if (arguments != null)
			{
				this.AdjustFlagsAndWidth(arguments);
				this.arguments = arguments;
			}
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}


		public AttributeArgumentListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode arguments, SyntaxToken closeParenToken)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			if (arguments != null)
			{
				this.AdjustFlagsAndWidth(arguments);
				this.arguments = arguments;
			}
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}

		/// <summary>Gets the open paren token.</summary>
		public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
		/// <summary>Gets the arguments syntax list.</summary>
		public SeparatedSyntaxList<AttributeArgumentSyntax> Arguments { get { return new SeparatedSyntaxList<AttributeArgumentSyntax>(new SyntaxList<LeeSyntaxNode>(this.arguments)); } }
		/// <summary>Gets the close paren token.</summary>
		public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.openParenToken;
				case 1: return this.arguments;
				case 2: return this.closeParenToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitAttributeArgumentList(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitAttributeArgumentList(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new AttributeArgumentListSyntax(this.Kind, this.openParenToken, this.arguments, this.closeParenToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new AttributeArgumentListSyntax(this.Kind, this.openParenToken, this.arguments, this.closeParenToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Attribute argument syntax.</summary>
	public sealed partial class AttributeArgumentSyntax : LeeSyntaxNode
	{
		public readonly NameEqualsSyntax nameEquals;
		public readonly NameColonSyntax nameColon;
		public readonly ExpressionSyntax expression;

		public AttributeArgumentSyntax(SyntaxKind kind, NameEqualsSyntax nameEquals, NameColonSyntax nameColon, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			if (nameEquals != null)
			{
				this.AdjustFlagsAndWidth(nameEquals);
				this.nameEquals = nameEquals;
			}
			if (nameColon != null)
			{
				this.AdjustFlagsAndWidth(nameColon);
				this.nameColon = nameColon;
			}
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
		}


		public AttributeArgumentSyntax(SyntaxKind kind, NameEqualsSyntax nameEquals, NameColonSyntax nameColon, ExpressionSyntax expression, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			if (nameEquals != null)
			{
				this.AdjustFlagsAndWidth(nameEquals);
				this.nameEquals = nameEquals;
			}
			if (nameColon != null)
			{
				this.AdjustFlagsAndWidth(nameColon);
				this.nameColon = nameColon;
			}
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
		}


		public AttributeArgumentSyntax(SyntaxKind kind, NameEqualsSyntax nameEquals, NameColonSyntax nameColon, ExpressionSyntax expression)
			: base(kind)
		{
			this.SlotCount = 3;
			if (nameEquals != null)
			{
				this.AdjustFlagsAndWidth(nameEquals);
				this.nameEquals = nameEquals;
			}
			if (nameColon != null)
			{
				this.AdjustFlagsAndWidth(nameColon);
				this.nameColon = nameColon;
			}
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
		}

		public NameEqualsSyntax NameEquals { get { return this.nameEquals; } }
		public NameColonSyntax NameColon { get { return this.nameColon; } }
		/// <summary>Gets the expression.</summary>
		public ExpressionSyntax Expression { get { return this.expression; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.nameEquals;
				case 1: return this.nameColon;
				case 2: return this.expression;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitAttributeArgument(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitAttributeArgument(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new AttributeArgumentSyntax(this.Kind, this.nameEquals, this.nameColon, this.expression, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new AttributeArgumentSyntax(this.Kind, this.nameEquals, this.nameColon, this.expression, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Class representing an identifier name followed by an equals token.</summary>
	public sealed partial class NameEqualsSyntax : LeeSyntaxNode
	{
		public readonly IdentifierNameSyntax name;
		public readonly SyntaxToken equalsToken;

		public NameEqualsSyntax(SyntaxKind kind, IdentifierNameSyntax name, SyntaxToken equalsToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(name);
			this.name = name;
			this.AdjustFlagsAndWidth(equalsToken);
			this.equalsToken = equalsToken;
		}


		public NameEqualsSyntax(SyntaxKind kind, IdentifierNameSyntax name, SyntaxToken equalsToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(name);
			this.name = name;
			this.AdjustFlagsAndWidth(equalsToken);
			this.equalsToken = equalsToken;
		}


		public NameEqualsSyntax(SyntaxKind kind, IdentifierNameSyntax name, SyntaxToken equalsToken)
			: base(kind)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(name);
			this.name = name;
			this.AdjustFlagsAndWidth(equalsToken);
			this.equalsToken = equalsToken;
		}

		/// <summary>Gets the identifier name.</summary>
		public IdentifierNameSyntax Name { get { return this.name; } }
		public SyntaxToken EqualsToken { get { return this.equalsToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.name;
				case 1: return this.equalsToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitNameEquals(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitNameEquals(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new NameEqualsSyntax(this.Kind, this.name, this.equalsToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new NameEqualsSyntax(this.Kind, this.name, this.equalsToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Type parameter list syntax.</summary>
	public sealed partial class TypeParameterListSyntax : LeeSyntaxNode
	{
		public readonly SyntaxToken lessThanToken;
		public readonly GreenNode parameters;
		public readonly SyntaxToken greaterThanToken;

		public TypeParameterListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, GreenNode parameters, SyntaxToken greaterThanToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(lessThanToken);
			this.lessThanToken = lessThanToken;
			if (parameters != null)
			{
				this.AdjustFlagsAndWidth(parameters);
				this.parameters = parameters;
			}
			this.AdjustFlagsAndWidth(greaterThanToken);
			this.greaterThanToken = greaterThanToken;
		}


		public TypeParameterListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, GreenNode parameters, SyntaxToken greaterThanToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(lessThanToken);
			this.lessThanToken = lessThanToken;
			if (parameters != null)
			{
				this.AdjustFlagsAndWidth(parameters);
				this.parameters = parameters;
			}
			this.AdjustFlagsAndWidth(greaterThanToken);
			this.greaterThanToken = greaterThanToken;
		}


		public TypeParameterListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, GreenNode parameters, SyntaxToken greaterThanToken)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(lessThanToken);
			this.lessThanToken = lessThanToken;
			if (parameters != null)
			{
				this.AdjustFlagsAndWidth(parameters);
				this.parameters = parameters;
			}
			this.AdjustFlagsAndWidth(greaterThanToken);
			this.greaterThanToken = greaterThanToken;
		}

		/// <summary>Gets the &lt; token.</summary>
		public SyntaxToken LessThanToken { get { return this.lessThanToken; } }
		/// <summary>Gets the parameter list.</summary>
		public SeparatedSyntaxList<TypeParameterSyntax> Parameters { get { return new SeparatedSyntaxList<TypeParameterSyntax>(new SyntaxList<LeeSyntaxNode>(this.parameters)); } }
		/// <summary>Gets the &gt; token.</summary>
		public SyntaxToken GreaterThanToken { get { return this.greaterThanToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.lessThanToken;
				case 1: return this.parameters;
				case 2: return this.greaterThanToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitTypeParameterList(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitTypeParameterList(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new TypeParameterListSyntax(this.Kind, this.lessThanToken, this.parameters, this.greaterThanToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new TypeParameterListSyntax(this.Kind, this.lessThanToken, this.parameters, this.greaterThanToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Type parameter syntax.</summary>
	public sealed partial class TypeParameterSyntax : LeeSyntaxNode
	{
		public readonly GreenNode attributeLists;
		public readonly SyntaxToken varianceKeyword;
		public readonly SyntaxToken identifier;

		public TypeParameterSyntax(SyntaxKind kind, GreenNode attributeLists, SyntaxToken varianceKeyword, SyntaxToken identifier, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (varianceKeyword != null)
			{
				this.AdjustFlagsAndWidth(varianceKeyword);
				this.varianceKeyword = varianceKeyword;
			}
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
		}


		public TypeParameterSyntax(SyntaxKind kind, GreenNode attributeLists, SyntaxToken varianceKeyword, SyntaxToken identifier, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (varianceKeyword != null)
			{
				this.AdjustFlagsAndWidth(varianceKeyword);
				this.varianceKeyword = varianceKeyword;
			}
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
		}


		public TypeParameterSyntax(SyntaxKind kind, GreenNode attributeLists, SyntaxToken varianceKeyword, SyntaxToken identifier)
			: base(kind)
		{
			this.SlotCount = 3;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (varianceKeyword != null)
			{
				this.AdjustFlagsAndWidth(varianceKeyword);
				this.varianceKeyword = varianceKeyword;
			}
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
		}

		/// <summary>Gets the attribute declaration list.</summary>
		public SyntaxList<AttributeListSyntax> AttributeLists { get { return new SyntaxList<AttributeListSyntax>(this.attributeLists); } }
		public SyntaxToken VarianceKeyword { get { return this.varianceKeyword; } }
		/// <summary>Gets the identifier.</summary>
		public SyntaxToken Identifier { get { return this.identifier; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.attributeLists;
				case 1: return this.varianceKeyword;
				case 2: return this.identifier;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitTypeParameter(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitTypeParameter(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new TypeParameterSyntax(this.Kind, this.attributeLists, this.varianceKeyword, this.identifier, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new TypeParameterSyntax(this.Kind, this.attributeLists, this.varianceKeyword, this.identifier, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Base class for type declaration syntax.</summary>
	public abstract partial class BaseTypeDeclarationSyntax : MemberDeclarationSyntax
	{
		public BaseTypeDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
		  : base(kind, diagnostics, annotations)
		{
		}
		public BaseTypeDeclarationSyntax(SyntaxKind kind)
		  : base(kind)
		{
		}

		/// <summary>Gets the attribute declaration list.</summary>
		public abstract SyntaxList<AttributeListSyntax> AttributeLists { get; }

		/// <summary>Gets the modifier list.</summary>
		public abstract SyntaxList<SyntaxToken> Modifiers { get; }

		/// <summary>Gets the identifier.</summary>
		public abstract SyntaxToken Identifier { get; }

		/// <summary>Gets the base type list.</summary>
		public abstract BaseListSyntax BaseList { get; }

		/// <summary>Gets the open brace token.</summary>
		public abstract SyntaxToken OpenBraceToken { get; }

		/// <summary>Gets the close brace token.</summary>
		public abstract SyntaxToken CloseBraceToken { get; }

		/// <summary>Gets the optional semicolon token.</summary>
		public abstract SyntaxToken SemicolonToken { get; }
	}

	/// <summary>Base class for type declaration syntax (class, struct, interface).</summary>
	public abstract partial class TypeDeclarationSyntax : BaseTypeDeclarationSyntax
	{
		public TypeDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
		  : base(kind, diagnostics, annotations)
		{
		}
		public TypeDeclarationSyntax(SyntaxKind kind)
		  : base(kind)
		{
		}
		/// <summary>Gets the type keyword token ("class", "struct", "interface").</summary>
		public abstract SyntaxToken Keyword { get; }

		public abstract TypeParameterListSyntax TypeParameterList { get; }

		/// <summary>Gets the type constraint list.</summary>
		public abstract SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }

		/// <summary>Gets the member declarations.</summary>
		public abstract SyntaxList<MemberDeclarationSyntax> Members { get; }
	}

	/// <summary>Class type declaration syntax.</summary>
	public sealed partial class ClassDeclarationSyntax : TypeDeclarationSyntax
	{
		public readonly GreenNode attributeLists;
		public readonly GreenNode modifiers;
		public readonly SyntaxToken keyword;
		public readonly SyntaxToken identifier;
		public readonly TypeParameterListSyntax typeParameterList;
		public readonly BaseListSyntax baseList;
		public readonly GreenNode constraintClauses;
		public readonly SyntaxToken openBraceToken;
		public readonly GreenNode members;
		public readonly SyntaxToken closeBraceToken;
		public readonly SyntaxToken semicolonToken;

		public ClassDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, GreenNode constraintClauses, SyntaxToken openBraceToken, GreenNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 11;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			if (typeParameterList != null)
			{
				this.AdjustFlagsAndWidth(typeParameterList);
				this.typeParameterList = typeParameterList;
			}
			if (baseList != null)
			{
				this.AdjustFlagsAndWidth(baseList);
				this.baseList = baseList;
			}
			if (constraintClauses != null)
			{
				this.AdjustFlagsAndWidth(constraintClauses);
				this.constraintClauses = constraintClauses;
			}
			this.AdjustFlagsAndWidth(openBraceToken);
			this.openBraceToken = openBraceToken;
			if (members != null)
			{
				this.AdjustFlagsAndWidth(members);
				this.members = members;
			}
			this.AdjustFlagsAndWidth(closeBraceToken);
			this.closeBraceToken = closeBraceToken;
			if (semicolonToken != null)
			{
				this.AdjustFlagsAndWidth(semicolonToken);
				this.semicolonToken = semicolonToken;
			}
		}


		public ClassDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, GreenNode constraintClauses, SyntaxToken openBraceToken, GreenNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 11;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			if (typeParameterList != null)
			{
				this.AdjustFlagsAndWidth(typeParameterList);
				this.typeParameterList = typeParameterList;
			}
			if (baseList != null)
			{
				this.AdjustFlagsAndWidth(baseList);
				this.baseList = baseList;
			}
			if (constraintClauses != null)
			{
				this.AdjustFlagsAndWidth(constraintClauses);
				this.constraintClauses = constraintClauses;
			}
			this.AdjustFlagsAndWidth(openBraceToken);
			this.openBraceToken = openBraceToken;
			if (members != null)
			{
				this.AdjustFlagsAndWidth(members);
				this.members = members;
			}
			this.AdjustFlagsAndWidth(closeBraceToken);
			this.closeBraceToken = closeBraceToken;
			if (semicolonToken != null)
			{
				this.AdjustFlagsAndWidth(semicolonToken);
				this.semicolonToken = semicolonToken;
			}
		}


		public ClassDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, GreenNode constraintClauses, SyntaxToken openBraceToken, GreenNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
			: base(kind)
		{
			this.SlotCount = 11;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			if (typeParameterList != null)
			{
				this.AdjustFlagsAndWidth(typeParameterList);
				this.typeParameterList = typeParameterList;
			}
			if (baseList != null)
			{
				this.AdjustFlagsAndWidth(baseList);
				this.baseList = baseList;
			}
			if (constraintClauses != null)
			{
				this.AdjustFlagsAndWidth(constraintClauses);
				this.constraintClauses = constraintClauses;
			}
			this.AdjustFlagsAndWidth(openBraceToken);
			this.openBraceToken = openBraceToken;
			if (members != null)
			{
				this.AdjustFlagsAndWidth(members);
				this.members = members;
			}
			this.AdjustFlagsAndWidth(closeBraceToken);
			this.closeBraceToken = closeBraceToken;
			if (semicolonToken != null)
			{
				this.AdjustFlagsAndWidth(semicolonToken);
				this.semicolonToken = semicolonToken;
			}
		}

		public override SyntaxList<AttributeListSyntax> AttributeLists { get { return new SyntaxList<AttributeListSyntax>(this.attributeLists); } }
		public override SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
		/// <summary>Gets the class keyword token.</summary>
		public override SyntaxToken Keyword { get { return this.keyword; } }
		public override SyntaxToken Identifier { get { return this.identifier; } }
		public override TypeParameterListSyntax TypeParameterList { get { return this.typeParameterList; } }
		public override BaseListSyntax BaseList { get { return this.baseList; } }
		public override SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get { return new SyntaxList<TypeParameterConstraintClauseSyntax>(this.constraintClauses); } }
		public override SyntaxToken OpenBraceToken { get { return this.openBraceToken; } }
		public override SyntaxList<MemberDeclarationSyntax> Members { get { return new SyntaxList<MemberDeclarationSyntax>(this.members); } }
		public override SyntaxToken CloseBraceToken { get { return this.closeBraceToken; } }
		public override SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.attributeLists;
				case 1: return this.modifiers;
				case 2: return this.keyword;
				case 3: return this.identifier;
				case 4: return this.typeParameterList;
				case 5: return this.baseList;
				case 6: return this.constraintClauses;
				case 7: return this.openBraceToken;
				case 8: return this.members;
				case 9: return this.closeBraceToken;
				case 10: return this.semicolonToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitClassDeclaration(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitClassDeclaration(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new ClassDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.identifier, this.typeParameterList, this.baseList, this.constraintClauses, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new ClassDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.identifier, this.typeParameterList, this.baseList, this.constraintClauses, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Struct type declaration syntax.</summary>
	public sealed partial class StructDeclarationSyntax : TypeDeclarationSyntax
	{
		public readonly GreenNode attributeLists;
		public readonly GreenNode modifiers;
		public readonly SyntaxToken keyword;
		public readonly SyntaxToken identifier;
		public readonly TypeParameterListSyntax typeParameterList;
		public readonly BaseListSyntax baseList;
		public readonly GreenNode constraintClauses;
		public readonly SyntaxToken openBraceToken;
		public readonly GreenNode members;
		public readonly SyntaxToken closeBraceToken;
		public readonly SyntaxToken semicolonToken;

		public StructDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, GreenNode constraintClauses, SyntaxToken openBraceToken, GreenNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 11;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			if (typeParameterList != null)
			{
				this.AdjustFlagsAndWidth(typeParameterList);
				this.typeParameterList = typeParameterList;
			}
			if (baseList != null)
			{
				this.AdjustFlagsAndWidth(baseList);
				this.baseList = baseList;
			}
			if (constraintClauses != null)
			{
				this.AdjustFlagsAndWidth(constraintClauses);
				this.constraintClauses = constraintClauses;
			}
			this.AdjustFlagsAndWidth(openBraceToken);
			this.openBraceToken = openBraceToken;
			if (members != null)
			{
				this.AdjustFlagsAndWidth(members);
				this.members = members;
			}
			this.AdjustFlagsAndWidth(closeBraceToken);
			this.closeBraceToken = closeBraceToken;
			if (semicolonToken != null)
			{
				this.AdjustFlagsAndWidth(semicolonToken);
				this.semicolonToken = semicolonToken;
			}
		}


		public StructDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, GreenNode constraintClauses, SyntaxToken openBraceToken, GreenNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 11;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			if (typeParameterList != null)
			{
				this.AdjustFlagsAndWidth(typeParameterList);
				this.typeParameterList = typeParameterList;
			}
			if (baseList != null)
			{
				this.AdjustFlagsAndWidth(baseList);
				this.baseList = baseList;
			}
			if (constraintClauses != null)
			{
				this.AdjustFlagsAndWidth(constraintClauses);
				this.constraintClauses = constraintClauses;
			}
			this.AdjustFlagsAndWidth(openBraceToken);
			this.openBraceToken = openBraceToken;
			if (members != null)
			{
				this.AdjustFlagsAndWidth(members);
				this.members = members;
			}
			this.AdjustFlagsAndWidth(closeBraceToken);
			this.closeBraceToken = closeBraceToken;
			if (semicolonToken != null)
			{
				this.AdjustFlagsAndWidth(semicolonToken);
				this.semicolonToken = semicolonToken;
			}
		}


		public StructDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, GreenNode constraintClauses, SyntaxToken openBraceToken, GreenNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
			: base(kind)
		{
			this.SlotCount = 11;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			if (typeParameterList != null)
			{
				this.AdjustFlagsAndWidth(typeParameterList);
				this.typeParameterList = typeParameterList;
			}
			if (baseList != null)
			{
				this.AdjustFlagsAndWidth(baseList);
				this.baseList = baseList;
			}
			if (constraintClauses != null)
			{
				this.AdjustFlagsAndWidth(constraintClauses);
				this.constraintClauses = constraintClauses;
			}
			this.AdjustFlagsAndWidth(openBraceToken);
			this.openBraceToken = openBraceToken;
			if (members != null)
			{
				this.AdjustFlagsAndWidth(members);
				this.members = members;
			}
			this.AdjustFlagsAndWidth(closeBraceToken);
			this.closeBraceToken = closeBraceToken;
			if (semicolonToken != null)
			{
				this.AdjustFlagsAndWidth(semicolonToken);
				this.semicolonToken = semicolonToken;
			}
		}

		public override SyntaxList<AttributeListSyntax> AttributeLists { get { return new SyntaxList<AttributeListSyntax>(this.attributeLists); } }
		public override SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
		/// <summary>Gets the struct keyword token.</summary>
		public override SyntaxToken Keyword { get { return this.keyword; } }
		public override SyntaxToken Identifier { get { return this.identifier; } }
		public override TypeParameterListSyntax TypeParameterList { get { return this.typeParameterList; } }
		public override BaseListSyntax BaseList { get { return this.baseList; } }
		public override SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get { return new SyntaxList<TypeParameterConstraintClauseSyntax>(this.constraintClauses); } }
		public override SyntaxToken OpenBraceToken { get { return this.openBraceToken; } }
		public override SyntaxList<MemberDeclarationSyntax> Members { get { return new SyntaxList<MemberDeclarationSyntax>(this.members); } }
		public override SyntaxToken CloseBraceToken { get { return this.closeBraceToken; } }
		public override SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.attributeLists;
				case 1: return this.modifiers;
				case 2: return this.keyword;
				case 3: return this.identifier;
				case 4: return this.typeParameterList;
				case 5: return this.baseList;
				case 6: return this.constraintClauses;
				case 7: return this.openBraceToken;
				case 8: return this.members;
				case 9: return this.closeBraceToken;
				case 10: return this.semicolonToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitStructDeclaration(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitStructDeclaration(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new StructDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.identifier, this.typeParameterList, this.baseList, this.constraintClauses, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new StructDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.identifier, this.typeParameterList, this.baseList, this.constraintClauses, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Interface type declaration syntax.</summary>
	public sealed partial class InterfaceDeclarationSyntax : TypeDeclarationSyntax
	{
		public readonly GreenNode attributeLists;
		public readonly GreenNode modifiers;
		public readonly SyntaxToken keyword;
		public readonly SyntaxToken identifier;
		public readonly TypeParameterListSyntax typeParameterList;
		public readonly BaseListSyntax baseList;
		public readonly GreenNode constraintClauses;
		public readonly SyntaxToken openBraceToken;
		public readonly GreenNode members;
		public readonly SyntaxToken closeBraceToken;
		public readonly SyntaxToken semicolonToken;

		public InterfaceDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, GreenNode constraintClauses, SyntaxToken openBraceToken, GreenNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 11;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			if (typeParameterList != null)
			{
				this.AdjustFlagsAndWidth(typeParameterList);
				this.typeParameterList = typeParameterList;
			}
			if (baseList != null)
			{
				this.AdjustFlagsAndWidth(baseList);
				this.baseList = baseList;
			}
			if (constraintClauses != null)
			{
				this.AdjustFlagsAndWidth(constraintClauses);
				this.constraintClauses = constraintClauses;
			}
			this.AdjustFlagsAndWidth(openBraceToken);
			this.openBraceToken = openBraceToken;
			if (members != null)
			{
				this.AdjustFlagsAndWidth(members);
				this.members = members;
			}
			this.AdjustFlagsAndWidth(closeBraceToken);
			this.closeBraceToken = closeBraceToken;
			if (semicolonToken != null)
			{
				this.AdjustFlagsAndWidth(semicolonToken);
				this.semicolonToken = semicolonToken;
			}
		}


		public InterfaceDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, GreenNode constraintClauses, SyntaxToken openBraceToken, GreenNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 11;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			if (typeParameterList != null)
			{
				this.AdjustFlagsAndWidth(typeParameterList);
				this.typeParameterList = typeParameterList;
			}
			if (baseList != null)
			{
				this.AdjustFlagsAndWidth(baseList);
				this.baseList = baseList;
			}
			if (constraintClauses != null)
			{
				this.AdjustFlagsAndWidth(constraintClauses);
				this.constraintClauses = constraintClauses;
			}
			this.AdjustFlagsAndWidth(openBraceToken);
			this.openBraceToken = openBraceToken;
			if (members != null)
			{
				this.AdjustFlagsAndWidth(members);
				this.members = members;
			}
			this.AdjustFlagsAndWidth(closeBraceToken);
			this.closeBraceToken = closeBraceToken;
			if (semicolonToken != null)
			{
				this.AdjustFlagsAndWidth(semicolonToken);
				this.semicolonToken = semicolonToken;
			}
		}


		public InterfaceDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, GreenNode constraintClauses, SyntaxToken openBraceToken, GreenNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
			: base(kind)
		{
			this.SlotCount = 11;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			if (typeParameterList != null)
			{
				this.AdjustFlagsAndWidth(typeParameterList);
				this.typeParameterList = typeParameterList;
			}
			if (baseList != null)
			{
				this.AdjustFlagsAndWidth(baseList);
				this.baseList = baseList;
			}
			if (constraintClauses != null)
			{
				this.AdjustFlagsAndWidth(constraintClauses);
				this.constraintClauses = constraintClauses;
			}
			this.AdjustFlagsAndWidth(openBraceToken);
			this.openBraceToken = openBraceToken;
			if (members != null)
			{
				this.AdjustFlagsAndWidth(members);
				this.members = members;
			}
			this.AdjustFlagsAndWidth(closeBraceToken);
			this.closeBraceToken = closeBraceToken;
			if (semicolonToken != null)
			{
				this.AdjustFlagsAndWidth(semicolonToken);
				this.semicolonToken = semicolonToken;
			}
		}

		public override SyntaxList<AttributeListSyntax> AttributeLists { get { return new SyntaxList<AttributeListSyntax>(this.attributeLists); } }
		public override SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
		/// <summary>Gets the interface keyword token.</summary>
		public override SyntaxToken Keyword { get { return this.keyword; } }
		public override SyntaxToken Identifier { get { return this.identifier; } }
		public override TypeParameterListSyntax TypeParameterList { get { return this.typeParameterList; } }
		public override BaseListSyntax BaseList { get { return this.baseList; } }
		public override SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get { return new SyntaxList<TypeParameterConstraintClauseSyntax>(this.constraintClauses); } }
		public override SyntaxToken OpenBraceToken { get { return this.openBraceToken; } }
		public override SyntaxList<MemberDeclarationSyntax> Members { get { return new SyntaxList<MemberDeclarationSyntax>(this.members); } }
		public override SyntaxToken CloseBraceToken { get { return this.closeBraceToken; } }
		public override SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.attributeLists;
				case 1: return this.modifiers;
				case 2: return this.keyword;
				case 3: return this.identifier;
				case 4: return this.typeParameterList;
				case 5: return this.baseList;
				case 6: return this.constraintClauses;
				case 7: return this.openBraceToken;
				case 8: return this.members;
				case 9: return this.closeBraceToken;
				case 10: return this.semicolonToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitInterfaceDeclaration(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitInterfaceDeclaration(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new InterfaceDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.identifier, this.typeParameterList, this.baseList, this.constraintClauses, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new InterfaceDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.identifier, this.typeParameterList, this.baseList, this.constraintClauses, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Enum type declaration syntax.</summary>
	public sealed partial class EnumDeclarationSyntax : BaseTypeDeclarationSyntax
	{
		public readonly GreenNode attributeLists;
		public readonly GreenNode modifiers;
		public readonly SyntaxToken enumKeyword;
		public readonly SyntaxToken identifier;
		public readonly BaseListSyntax baseList;
		public readonly SyntaxToken openBraceToken;
		public readonly GreenNode members;
		public readonly SyntaxToken closeBraceToken;
		public readonly SyntaxToken semicolonToken;

		public EnumDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax baseList, SyntaxToken openBraceToken, GreenNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 9;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(enumKeyword);
			this.enumKeyword = enumKeyword;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			if (baseList != null)
			{
				this.AdjustFlagsAndWidth(baseList);
				this.baseList = baseList;
			}
			this.AdjustFlagsAndWidth(openBraceToken);
			this.openBraceToken = openBraceToken;
			if (members != null)
			{
				this.AdjustFlagsAndWidth(members);
				this.members = members;
			}
			this.AdjustFlagsAndWidth(closeBraceToken);
			this.closeBraceToken = closeBraceToken;
			if (semicolonToken != null)
			{
				this.AdjustFlagsAndWidth(semicolonToken);
				this.semicolonToken = semicolonToken;
			}
		}


		public EnumDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax baseList, SyntaxToken openBraceToken, GreenNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 9;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(enumKeyword);
			this.enumKeyword = enumKeyword;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			if (baseList != null)
			{
				this.AdjustFlagsAndWidth(baseList);
				this.baseList = baseList;
			}
			this.AdjustFlagsAndWidth(openBraceToken);
			this.openBraceToken = openBraceToken;
			if (members != null)
			{
				this.AdjustFlagsAndWidth(members);
				this.members = members;
			}
			this.AdjustFlagsAndWidth(closeBraceToken);
			this.closeBraceToken = closeBraceToken;
			if (semicolonToken != null)
			{
				this.AdjustFlagsAndWidth(semicolonToken);
				this.semicolonToken = semicolonToken;
			}
		}


		public EnumDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax baseList, SyntaxToken openBraceToken, GreenNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
			: base(kind)
		{
			this.SlotCount = 9;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(enumKeyword);
			this.enumKeyword = enumKeyword;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			if (baseList != null)
			{
				this.AdjustFlagsAndWidth(baseList);
				this.baseList = baseList;
			}
			this.AdjustFlagsAndWidth(openBraceToken);
			this.openBraceToken = openBraceToken;
			if (members != null)
			{
				this.AdjustFlagsAndWidth(members);
				this.members = members;
			}
			this.AdjustFlagsAndWidth(closeBraceToken);
			this.closeBraceToken = closeBraceToken;
			if (semicolonToken != null)
			{
				this.AdjustFlagsAndWidth(semicolonToken);
				this.semicolonToken = semicolonToken;
			}
		}

		public override SyntaxList<AttributeListSyntax> AttributeLists { get { return new SyntaxList<AttributeListSyntax>(this.attributeLists); } }
		public override SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
		/// <summary>Gets the enum keyword token.</summary>
		public SyntaxToken EnumKeyword { get { return this.enumKeyword; } }
		public override SyntaxToken Identifier { get { return this.identifier; } }
		public override BaseListSyntax BaseList { get { return this.baseList; } }
		public override SyntaxToken OpenBraceToken { get { return this.openBraceToken; } }
		/// <summary>Gets the members declaration list.</summary>
		public SeparatedSyntaxList<EnumMemberDeclarationSyntax> Members { get { return new SeparatedSyntaxList<EnumMemberDeclarationSyntax>(new SyntaxList<LeeSyntaxNode>(this.members)); } }
		public override SyntaxToken CloseBraceToken { get { return this.closeBraceToken; } }
		/// <summary>Gets the optional semicolon token.</summary>
		public override SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.attributeLists;
				case 1: return this.modifiers;
				case 2: return this.enumKeyword;
				case 3: return this.identifier;
				case 4: return this.baseList;
				case 5: return this.openBraceToken;
				case 6: return this.members;
				case 7: return this.closeBraceToken;
				case 8: return this.semicolonToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitEnumDeclaration(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitEnumDeclaration(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new EnumDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.enumKeyword, this.identifier, this.baseList, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new EnumDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.enumKeyword, this.identifier, this.baseList, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Delegate declaration syntax.</summary>
	public sealed partial class DelegateDeclarationSyntax : MemberDeclarationSyntax
	{
		public readonly GreenNode attributeLists;
		public readonly GreenNode modifiers;
		public readonly SyntaxToken delegateKeyword;
		public readonly TypeSyntax returnType;
		public readonly SyntaxToken identifier;
		public readonly TypeParameterListSyntax typeParameterList;
		public readonly ParameterListSyntax parameterList;
		public readonly GreenNode constraintClauses;
		public readonly SyntaxToken semicolonToken;

		public DelegateDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, GreenNode constraintClauses, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 9;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(delegateKeyword);
			this.delegateKeyword = delegateKeyword;
			this.AdjustFlagsAndWidth(returnType);
			this.returnType = returnType;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			if (typeParameterList != null)
			{
				this.AdjustFlagsAndWidth(typeParameterList);
				this.typeParameterList = typeParameterList;
			}
			this.AdjustFlagsAndWidth(parameterList);
			this.parameterList = parameterList;
			if (constraintClauses != null)
			{
				this.AdjustFlagsAndWidth(constraintClauses);
				this.constraintClauses = constraintClauses;
			}
			this.AdjustFlagsAndWidth(semicolonToken);
			this.semicolonToken = semicolonToken;
		}


		public DelegateDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, GreenNode constraintClauses, SyntaxToken semicolonToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 9;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(delegateKeyword);
			this.delegateKeyword = delegateKeyword;
			this.AdjustFlagsAndWidth(returnType);
			this.returnType = returnType;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			if (typeParameterList != null)
			{
				this.AdjustFlagsAndWidth(typeParameterList);
				this.typeParameterList = typeParameterList;
			}
			this.AdjustFlagsAndWidth(parameterList);
			this.parameterList = parameterList;
			if (constraintClauses != null)
			{
				this.AdjustFlagsAndWidth(constraintClauses);
				this.constraintClauses = constraintClauses;
			}
			this.AdjustFlagsAndWidth(semicolonToken);
			this.semicolonToken = semicolonToken;
		}


		public DelegateDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, GreenNode constraintClauses, SyntaxToken semicolonToken)
			: base(kind)
		{
			this.SlotCount = 9;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(delegateKeyword);
			this.delegateKeyword = delegateKeyword;
			this.AdjustFlagsAndWidth(returnType);
			this.returnType = returnType;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			if (typeParameterList != null)
			{
				this.AdjustFlagsAndWidth(typeParameterList);
				this.typeParameterList = typeParameterList;
			}
			this.AdjustFlagsAndWidth(parameterList);
			this.parameterList = parameterList;
			if (constraintClauses != null)
			{
				this.AdjustFlagsAndWidth(constraintClauses);
				this.constraintClauses = constraintClauses;
			}
			this.AdjustFlagsAndWidth(semicolonToken);
			this.semicolonToken = semicolonToken;
		}

		/// <summary>Gets the attribute declaration list.</summary>
		public SyntaxList<AttributeListSyntax> AttributeLists { get { return new SyntaxList<AttributeListSyntax>(this.attributeLists); } }
		/// <summary>Gets the modifier list.</summary>
		public SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
		/// <summary>Gets the "delegate" keyword.</summary>
		public SyntaxToken DelegateKeyword { get { return this.delegateKeyword; } }
		/// <summary>Gets the return type.</summary>
		public TypeSyntax ReturnType { get { return this.returnType; } }
		/// <summary>Gets the identifier.</summary>
		public SyntaxToken Identifier { get { return this.identifier; } }
		public TypeParameterListSyntax TypeParameterList { get { return this.typeParameterList; } }
		/// <summary>Gets the parameter list.</summary>
		public ParameterListSyntax ParameterList { get { return this.parameterList; } }
		/// <summary>Gets the constraint clause list.</summary>
		public SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get { return new SyntaxList<TypeParameterConstraintClauseSyntax>(this.constraintClauses); } }
		/// <summary>Gets the semicolon token.</summary>
		public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.attributeLists;
				case 1: return this.modifiers;
				case 2: return this.delegateKeyword;
				case 3: return this.returnType;
				case 4: return this.identifier;
				case 5: return this.typeParameterList;
				case 6: return this.parameterList;
				case 7: return this.constraintClauses;
				case 8: return this.semicolonToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitDelegateDeclaration(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitDelegateDeclaration(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new DelegateDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.delegateKeyword, this.returnType, this.identifier, this.typeParameterList, this.parameterList, this.constraintClauses, this.semicolonToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new DelegateDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.delegateKeyword, this.returnType, this.identifier, this.typeParameterList, this.parameterList, this.constraintClauses, this.semicolonToken, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class EnumMemberDeclarationSyntax : MemberDeclarationSyntax
	{
		public readonly GreenNode attributeLists;
		public readonly SyntaxToken identifier;
		public readonly EqualsValueClauseSyntax equalsValue;

		public EnumMemberDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			if (equalsValue != null)
			{
				this.AdjustFlagsAndWidth(equalsValue);
				this.equalsValue = equalsValue;
			}
		}


		public EnumMemberDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			if (equalsValue != null)
			{
				this.AdjustFlagsAndWidth(equalsValue);
				this.equalsValue = equalsValue;
			}
		}


		public EnumMemberDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue)
			: base(kind)
		{
			this.SlotCount = 3;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			if (equalsValue != null)
			{
				this.AdjustFlagsAndWidth(equalsValue);
				this.equalsValue = equalsValue;
			}
		}

		/// <summary>Gets the attribute declaration list.</summary>
		public SyntaxList<AttributeListSyntax> AttributeLists { get { return new SyntaxList<AttributeListSyntax>(this.attributeLists); } }
		/// <summary>Gets the identifier.</summary>
		public SyntaxToken Identifier { get { return this.identifier; } }
		public EqualsValueClauseSyntax EqualsValue { get { return this.equalsValue; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.attributeLists;
				case 1: return this.identifier;
				case 2: return this.equalsValue;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitEnumMemberDeclaration(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitEnumMemberDeclaration(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new EnumMemberDeclarationSyntax(this.Kind, this.attributeLists, this.identifier, this.equalsValue, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new EnumMemberDeclarationSyntax(this.Kind, this.attributeLists, this.identifier, this.equalsValue, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Base list syntax.</summary>
	public sealed partial class BaseListSyntax : LeeSyntaxNode
	{
		public readonly SyntaxToken colonToken;
		public readonly GreenNode types;

		public BaseListSyntax(SyntaxKind kind, SyntaxToken colonToken, GreenNode types, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(colonToken);
			this.colonToken = colonToken;
			if (types != null)
			{
				this.AdjustFlagsAndWidth(types);
				this.types = types;
			}
		}


		public BaseListSyntax(SyntaxKind kind, SyntaxToken colonToken, GreenNode types, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(colonToken);
			this.colonToken = colonToken;
			if (types != null)
			{
				this.AdjustFlagsAndWidth(types);
				this.types = types;
			}
		}


		public BaseListSyntax(SyntaxKind kind, SyntaxToken colonToken, GreenNode types)
			: base(kind)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(colonToken);
			this.colonToken = colonToken;
			if (types != null)
			{
				this.AdjustFlagsAndWidth(types);
				this.types = types;
			}
		}

		/// <summary>Gets the colon token.</summary>
		public SyntaxToken ColonToken { get { return this.colonToken; } }
		/// <summary>Gets the base type references.</summary>
		public SeparatedSyntaxList<BaseTypeSyntax> Types { get { return new SeparatedSyntaxList<BaseTypeSyntax>(new SyntaxList<LeeSyntaxNode>(this.types)); } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.colonToken;
				case 1: return this.types;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitBaseList(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitBaseList(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new BaseListSyntax(this.Kind, this.colonToken, this.types, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new BaseListSyntax(this.Kind, this.colonToken, this.types, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Provides the base class from which the classes that represent base type syntax nodes are derived. This is an abstract class.</summary>
	public abstract partial class BaseTypeSyntax : LeeSyntaxNode
	{
		public BaseTypeSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
		  : base(kind, diagnostics, annotations)
		{
		}
		public BaseTypeSyntax(SyntaxKind kind)
		  : base(kind)
		{
		}

		public abstract TypeSyntax Type { get; }
	}

	public sealed partial class SimpleBaseTypeSyntax : BaseTypeSyntax
	{
		public readonly TypeSyntax type;

		public SimpleBaseTypeSyntax(SyntaxKind kind, TypeSyntax type, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
		}


		public SimpleBaseTypeSyntax(SyntaxKind kind, TypeSyntax type, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
		}


		public SimpleBaseTypeSyntax(SyntaxKind kind, TypeSyntax type)
			: base(kind)
		{
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
		}

		public override TypeSyntax Type { get { return this.type; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.type;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitSimpleBaseType(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitSimpleBaseType(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new SimpleBaseTypeSyntax(this.Kind, this.type, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new SimpleBaseTypeSyntax(this.Kind, this.type, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Type parameter constraint clause.</summary>
	public sealed partial class TypeParameterConstraintClauseSyntax : LeeSyntaxNode
	{
		public readonly SyntaxToken whereKeyword;
		public readonly IdentifierNameSyntax name;
		public readonly SyntaxToken colonToken;
		public readonly GreenNode constraints;

		public TypeParameterConstraintClauseSyntax(SyntaxKind kind, SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, GreenNode constraints, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(whereKeyword);
			this.whereKeyword = whereKeyword;
			this.AdjustFlagsAndWidth(name);
			this.name = name;
			this.AdjustFlagsAndWidth(colonToken);
			this.colonToken = colonToken;
			if (constraints != null)
			{
				this.AdjustFlagsAndWidth(constraints);
				this.constraints = constraints;
			}
		}


		public TypeParameterConstraintClauseSyntax(SyntaxKind kind, SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, GreenNode constraints, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(whereKeyword);
			this.whereKeyword = whereKeyword;
			this.AdjustFlagsAndWidth(name);
			this.name = name;
			this.AdjustFlagsAndWidth(colonToken);
			this.colonToken = colonToken;
			if (constraints != null)
			{
				this.AdjustFlagsAndWidth(constraints);
				this.constraints = constraints;
			}
		}


		public TypeParameterConstraintClauseSyntax(SyntaxKind kind, SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, GreenNode constraints)
			: base(kind)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(whereKeyword);
			this.whereKeyword = whereKeyword;
			this.AdjustFlagsAndWidth(name);
			this.name = name;
			this.AdjustFlagsAndWidth(colonToken);
			this.colonToken = colonToken;
			if (constraints != null)
			{
				this.AdjustFlagsAndWidth(constraints);
				this.constraints = constraints;
			}
		}

		public SyntaxToken WhereKeyword { get { return this.whereKeyword; } }
		/// <summary>Gets the identifier.</summary>
		public IdentifierNameSyntax Name { get { return this.name; } }
		/// <summary>Gets the colon token.</summary>
		public SyntaxToken ColonToken { get { return this.colonToken; } }
		/// <summary>Gets the constraints list.</summary>
		public SeparatedSyntaxList<TypeParameterConstraintSyntax> Constraints { get { return new SeparatedSyntaxList<TypeParameterConstraintSyntax>(new SyntaxList<LeeSyntaxNode>(this.constraints)); } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.whereKeyword;
				case 1: return this.name;
				case 2: return this.colonToken;
				case 3: return this.constraints;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitTypeParameterConstraintClause(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitTypeParameterConstraintClause(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new TypeParameterConstraintClauseSyntax(this.Kind, this.whereKeyword, this.name, this.colonToken, this.constraints, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new TypeParameterConstraintClauseSyntax(this.Kind, this.whereKeyword, this.name, this.colonToken, this.constraints, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Base type for type parameter constraint syntax.</summary>
	public abstract partial class TypeParameterConstraintSyntax : LeeSyntaxNode
	{
		public TypeParameterConstraintSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
		  : base(kind, diagnostics, annotations)
		{
		}
		public TypeParameterConstraintSyntax(SyntaxKind kind)
		  : base(kind)
		{
		}
	}

	/// <summary>Constructor constraint syntax.</summary>
	public sealed partial class ConstructorConstraintSyntax : TypeParameterConstraintSyntax
	{
		public readonly SyntaxToken newKeyword;
		public readonly SyntaxToken openParenToken;
		public readonly SyntaxToken closeParenToken;

		public ConstructorConstraintSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(newKeyword);
			this.newKeyword = newKeyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}


		public ConstructorConstraintSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(newKeyword);
			this.newKeyword = newKeyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}


		public ConstructorConstraintSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(newKeyword);
			this.newKeyword = newKeyword;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}

		/// <summary>Gets the "new" keyword.</summary>
		public SyntaxToken NewKeyword { get { return this.newKeyword; } }
		/// <summary>Gets the open paren keyword.</summary>
		public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
		/// <summary>Gets the close paren keyword.</summary>
		public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.newKeyword;
				case 1: return this.openParenToken;
				case 2: return this.closeParenToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitConstructorConstraint(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitConstructorConstraint(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new ConstructorConstraintSyntax(this.Kind, this.newKeyword, this.openParenToken, this.closeParenToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new ConstructorConstraintSyntax(this.Kind, this.newKeyword, this.openParenToken, this.closeParenToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Base type for class or struct constraint syntax.</summary>
	public sealed partial class ClassOrStructConstraintSyntax : TypeParameterConstraintSyntax
	{
		public readonly SyntaxToken classOrStructKeyword;
		public readonly SyntaxToken questionToken;

		public ClassOrStructConstraintSyntax(SyntaxKind kind, SyntaxToken classOrStructKeyword, SyntaxToken questionToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(classOrStructKeyword);
			this.classOrStructKeyword = classOrStructKeyword;
			if (questionToken != null)
			{
				this.AdjustFlagsAndWidth(questionToken);
				this.questionToken = questionToken;
			}
		}


		public ClassOrStructConstraintSyntax(SyntaxKind kind, SyntaxToken classOrStructKeyword, SyntaxToken questionToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(classOrStructKeyword);
			this.classOrStructKeyword = classOrStructKeyword;
			if (questionToken != null)
			{
				this.AdjustFlagsAndWidth(questionToken);
				this.questionToken = questionToken;
			}
		}


		public ClassOrStructConstraintSyntax(SyntaxKind kind, SyntaxToken classOrStructKeyword, SyntaxToken questionToken)
			: base(kind)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(classOrStructKeyword);
			this.classOrStructKeyword = classOrStructKeyword;
			if (questionToken != null)
			{
				this.AdjustFlagsAndWidth(questionToken);
				this.questionToken = questionToken;
			}
		}

		/// <summary>Gets the constraint keyword ("class" or "struct").</summary>
		public SyntaxToken ClassOrStructKeyword { get { return this.classOrStructKeyword; } }
		/// <summary>SyntaxToken representing the question mark.</summary>
		public SyntaxToken QuestionToken { get { return this.questionToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.classOrStructKeyword;
				case 1: return this.questionToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitClassOrStructConstraint(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitClassOrStructConstraint(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new ClassOrStructConstraintSyntax(this.Kind, this.classOrStructKeyword, this.questionToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new ClassOrStructConstraintSyntax(this.Kind, this.classOrStructKeyword, this.questionToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Type constraint syntax.</summary>
	public sealed partial class TypeConstraintSyntax : TypeParameterConstraintSyntax
	{
		public readonly TypeSyntax type;

		public TypeConstraintSyntax(SyntaxKind kind, TypeSyntax type, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
		}


		public TypeConstraintSyntax(SyntaxKind kind, TypeSyntax type, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
		}


		public TypeConstraintSyntax(SyntaxKind kind, TypeSyntax type)
			: base(kind)
		{
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
		}

		/// <summary>Gets the type syntax.</summary>
		public TypeSyntax Type { get { return this.type; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.type;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitTypeConstraint(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitTypeConstraint(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new TypeConstraintSyntax(this.Kind, this.type, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new TypeConstraintSyntax(this.Kind, this.type, GetDiagnostics(), annotations);
		}
	}

	public abstract partial class BaseFieldDeclarationSyntax : MemberDeclarationSyntax
	{
		public BaseFieldDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
		  : base(kind, diagnostics, annotations)
		{
		}
		public BaseFieldDeclarationSyntax(SyntaxKind kind)
		  : base(kind)
		{
		}

		/// <summary>Gets the attribute declaration list.</summary>
		public abstract SyntaxList<AttributeListSyntax> AttributeLists { get; }

		/// <summary>Gets the modifier list.</summary>
		public abstract SyntaxList<SyntaxToken> Modifiers { get; }

		public abstract VariableDeclarationSyntax Declaration { get; }

		public abstract SyntaxToken SemicolonToken { get; }
	}

	public sealed partial class FieldDeclarationSyntax : BaseFieldDeclarationSyntax
	{
		public readonly GreenNode attributeLists;
		public readonly GreenNode modifiers;
		public readonly VariableDeclarationSyntax declaration;
		public readonly SyntaxToken semicolonToken;

		public FieldDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 4;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(declaration);
			this.declaration = declaration;
			this.AdjustFlagsAndWidth(semicolonToken);
			this.semicolonToken = semicolonToken;
		}


		public FieldDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 4;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(declaration);
			this.declaration = declaration;
			this.AdjustFlagsAndWidth(semicolonToken);
			this.semicolonToken = semicolonToken;
		}


		public FieldDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
			: base(kind)
		{
			this.SlotCount = 4;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(declaration);
			this.declaration = declaration;
			this.AdjustFlagsAndWidth(semicolonToken);
			this.semicolonToken = semicolonToken;
		}

		/// <summary>Gets the attribute declaration list.</summary>
		public override SyntaxList<AttributeListSyntax> AttributeLists { get { return new SyntaxList<AttributeListSyntax>(this.attributeLists); } }
		/// <summary>Gets the modifier list.</summary>
		public override SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
		public override VariableDeclarationSyntax Declaration { get { return this.declaration; } }
		public override SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.attributeLists;
				case 1: return this.modifiers;
				case 2: return this.declaration;
				case 3: return this.semicolonToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitFieldDeclaration(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitFieldDeclaration(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new FieldDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.declaration, this.semicolonToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new FieldDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.declaration, this.semicolonToken, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class EventFieldDeclarationSyntax : BaseFieldDeclarationSyntax
	{
		public readonly GreenNode attributeLists;
		public readonly GreenNode modifiers;
		public readonly SyntaxToken eventKeyword;
		public readonly VariableDeclarationSyntax declaration;
		public readonly SyntaxToken semicolonToken;

		public EventFieldDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 5;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(eventKeyword);
			this.eventKeyword = eventKeyword;
			this.AdjustFlagsAndWidth(declaration);
			this.declaration = declaration;
			this.AdjustFlagsAndWidth(semicolonToken);
			this.semicolonToken = semicolonToken;
		}


		public EventFieldDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 5;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(eventKeyword);
			this.eventKeyword = eventKeyword;
			this.AdjustFlagsAndWidth(declaration);
			this.declaration = declaration;
			this.AdjustFlagsAndWidth(semicolonToken);
			this.semicolonToken = semicolonToken;
		}


		public EventFieldDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
			: base(kind)
		{
			this.SlotCount = 5;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(eventKeyword);
			this.eventKeyword = eventKeyword;
			this.AdjustFlagsAndWidth(declaration);
			this.declaration = declaration;
			this.AdjustFlagsAndWidth(semicolonToken);
			this.semicolonToken = semicolonToken;
		}

		/// <summary>Gets the attribute declaration list.</summary>
		public override SyntaxList<AttributeListSyntax> AttributeLists { get { return new SyntaxList<AttributeListSyntax>(this.attributeLists); } }
		/// <summary>Gets the modifier list.</summary>
		public override SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
		public SyntaxToken EventKeyword { get { return this.eventKeyword; } }
		public override VariableDeclarationSyntax Declaration { get { return this.declaration; } }
		public override SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.attributeLists;
				case 1: return this.modifiers;
				case 2: return this.eventKeyword;
				case 3: return this.declaration;
				case 4: return this.semicolonToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitEventFieldDeclaration(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitEventFieldDeclaration(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new EventFieldDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.eventKeyword, this.declaration, this.semicolonToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new EventFieldDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.eventKeyword, this.declaration, this.semicolonToken, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class ExplicitInterfaceSpecifierSyntax : LeeSyntaxNode
	{
		public readonly NameSyntax name;
		public readonly SyntaxToken dotToken;

		public ExplicitInterfaceSpecifierSyntax(SyntaxKind kind, NameSyntax name, SyntaxToken dotToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(name);
			this.name = name;
			this.AdjustFlagsAndWidth(dotToken);
			this.dotToken = dotToken;
		}


		public ExplicitInterfaceSpecifierSyntax(SyntaxKind kind, NameSyntax name, SyntaxToken dotToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(name);
			this.name = name;
			this.AdjustFlagsAndWidth(dotToken);
			this.dotToken = dotToken;
		}


		public ExplicitInterfaceSpecifierSyntax(SyntaxKind kind, NameSyntax name, SyntaxToken dotToken)
			: base(kind)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(name);
			this.name = name;
			this.AdjustFlagsAndWidth(dotToken);
			this.dotToken = dotToken;
		}

		public NameSyntax Name { get { return this.name; } }
		public SyntaxToken DotToken { get { return this.dotToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.name;
				case 1: return this.dotToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitExplicitInterfaceSpecifier(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitExplicitInterfaceSpecifier(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new ExplicitInterfaceSpecifierSyntax(this.Kind, this.name, this.dotToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new ExplicitInterfaceSpecifierSyntax(this.Kind, this.name, this.dotToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Base type for method declaration syntax.</summary>
	public abstract partial class BaseMethodDeclarationSyntax : MemberDeclarationSyntax
	{
		public BaseMethodDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
		  : base(kind, diagnostics, annotations)
		{
		}
		public BaseMethodDeclarationSyntax(SyntaxKind kind)
		  : base(kind)
		{
		}

		/// <summary>Gets the attribute declaration list.</summary>
		public abstract SyntaxList<AttributeListSyntax> AttributeLists { get; }

		/// <summary>Gets the modifier list.</summary>
		public abstract SyntaxList<SyntaxToken> Modifiers { get; }

		/// <summary>Gets the parameter list.</summary>
		public abstract ParameterListSyntax ParameterList { get; }

		public abstract BlockSyntax Body { get; }

		public abstract ArrowExpressionClauseSyntax ExpressionBody { get; }

		/// <summary>Gets the optional semicolon token.</summary>
		public abstract SyntaxToken SemicolonToken { get; }
	}

	/// <summary>Method declaration syntax.</summary>
	public sealed partial class MethodDeclarationSyntax : BaseMethodDeclarationSyntax
	{
		public readonly GreenNode attributeLists;
		public readonly GreenNode modifiers;
		public readonly TypeSyntax returnType;
		public readonly ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier;
		public readonly SyntaxToken identifier;
		public readonly TypeParameterListSyntax typeParameterList;
		public readonly ParameterListSyntax parameterList;
		public readonly GreenNode constraintClauses;
		public readonly BlockSyntax body;
		public readonly ArrowExpressionClauseSyntax expressionBody;
		public readonly SyntaxToken semicolonToken;

		public MethodDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, GreenNode constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 11;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(returnType);
			this.returnType = returnType;
			if (explicitInterfaceSpecifier != null)
			{
				this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
				this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
			}
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			if (typeParameterList != null)
			{
				this.AdjustFlagsAndWidth(typeParameterList);
				this.typeParameterList = typeParameterList;
			}
			this.AdjustFlagsAndWidth(parameterList);
			this.parameterList = parameterList;
			if (constraintClauses != null)
			{
				this.AdjustFlagsAndWidth(constraintClauses);
				this.constraintClauses = constraintClauses;
			}
			if (body != null)
			{
				this.AdjustFlagsAndWidth(body);
				this.body = body;
			}
			if (expressionBody != null)
			{
				this.AdjustFlagsAndWidth(expressionBody);
				this.expressionBody = expressionBody;
			}
			if (semicolonToken != null)
			{
				this.AdjustFlagsAndWidth(semicolonToken);
				this.semicolonToken = semicolonToken;
			}
		}


		public MethodDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, GreenNode constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 11;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(returnType);
			this.returnType = returnType;
			if (explicitInterfaceSpecifier != null)
			{
				this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
				this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
			}
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			if (typeParameterList != null)
			{
				this.AdjustFlagsAndWidth(typeParameterList);
				this.typeParameterList = typeParameterList;
			}
			this.AdjustFlagsAndWidth(parameterList);
			this.parameterList = parameterList;
			if (constraintClauses != null)
			{
				this.AdjustFlagsAndWidth(constraintClauses);
				this.constraintClauses = constraintClauses;
			}
			if (body != null)
			{
				this.AdjustFlagsAndWidth(body);
				this.body = body;
			}
			if (expressionBody != null)
			{
				this.AdjustFlagsAndWidth(expressionBody);
				this.expressionBody = expressionBody;
			}
			if (semicolonToken != null)
			{
				this.AdjustFlagsAndWidth(semicolonToken);
				this.semicolonToken = semicolonToken;
			}
		}


		public MethodDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, GreenNode constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
			: base(kind)
		{
			this.SlotCount = 11;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(returnType);
			this.returnType = returnType;
			if (explicitInterfaceSpecifier != null)
			{
				this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
				this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
			}
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			if (typeParameterList != null)
			{
				this.AdjustFlagsAndWidth(typeParameterList);
				this.typeParameterList = typeParameterList;
			}
			this.AdjustFlagsAndWidth(parameterList);
			this.parameterList = parameterList;
			if (constraintClauses != null)
			{
				this.AdjustFlagsAndWidth(constraintClauses);
				this.constraintClauses = constraintClauses;
			}
			if (body != null)
			{
				this.AdjustFlagsAndWidth(body);
				this.body = body;
			}
			if (expressionBody != null)
			{
				this.AdjustFlagsAndWidth(expressionBody);
				this.expressionBody = expressionBody;
			}
			if (semicolonToken != null)
			{
				this.AdjustFlagsAndWidth(semicolonToken);
				this.semicolonToken = semicolonToken;
			}
		}

		public override SyntaxList<AttributeListSyntax> AttributeLists { get { return new SyntaxList<AttributeListSyntax>(this.attributeLists); } }
		public override SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
		/// <summary>Gets the return type syntax.</summary>
		public TypeSyntax ReturnType { get { return this.returnType; } }
		public ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get { return this.explicitInterfaceSpecifier; } }
		/// <summary>Gets the identifier.</summary>
		public SyntaxToken Identifier { get { return this.identifier; } }
		public TypeParameterListSyntax TypeParameterList { get { return this.typeParameterList; } }
		public override ParameterListSyntax ParameterList { get { return this.parameterList; } }
		/// <summary>Gets the constraint clause list.</summary>
		public SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get { return new SyntaxList<TypeParameterConstraintClauseSyntax>(this.constraintClauses); } }
		public override BlockSyntax Body { get { return this.body; } }
		public override ArrowExpressionClauseSyntax ExpressionBody { get { return this.expressionBody; } }
		/// <summary>Gets the optional semicolon token.</summary>
		public override SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.attributeLists;
				case 1: return this.modifiers;
				case 2: return this.returnType;
				case 3: return this.explicitInterfaceSpecifier;
				case 4: return this.identifier;
				case 5: return this.typeParameterList;
				case 6: return this.parameterList;
				case 7: return this.constraintClauses;
				case 8: return this.body;
				case 9: return this.expressionBody;
				case 10: return this.semicolonToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitMethodDeclaration(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitMethodDeclaration(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new MethodDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.returnType, this.explicitInterfaceSpecifier, this.identifier, this.typeParameterList, this.parameterList, this.constraintClauses, this.body, this.expressionBody, this.semicolonToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new MethodDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.returnType, this.explicitInterfaceSpecifier, this.identifier, this.typeParameterList, this.parameterList, this.constraintClauses, this.body, this.expressionBody, this.semicolonToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Operator declaration syntax.</summary>
	public sealed partial class OperatorDeclarationSyntax : BaseMethodDeclarationSyntax
	{
		public readonly GreenNode attributeLists;
		public readonly GreenNode modifiers;
		public readonly TypeSyntax returnType;
		public readonly SyntaxToken operatorKeyword;
		public readonly SyntaxToken operatorToken;
		public readonly ParameterListSyntax parameterList;
		public readonly BlockSyntax body;
		public readonly ArrowExpressionClauseSyntax expressionBody;
		public readonly SyntaxToken semicolonToken;

		public OperatorDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 9;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(returnType);
			this.returnType = returnType;
			this.AdjustFlagsAndWidth(operatorKeyword);
			this.operatorKeyword = operatorKeyword;
			this.AdjustFlagsAndWidth(operatorToken);
			this.operatorToken = operatorToken;
			this.AdjustFlagsAndWidth(parameterList);
			this.parameterList = parameterList;
			if (body != null)
			{
				this.AdjustFlagsAndWidth(body);
				this.body = body;
			}
			if (expressionBody != null)
			{
				this.AdjustFlagsAndWidth(expressionBody);
				this.expressionBody = expressionBody;
			}
			if (semicolonToken != null)
			{
				this.AdjustFlagsAndWidth(semicolonToken);
				this.semicolonToken = semicolonToken;
			}
		}


		public OperatorDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 9;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(returnType);
			this.returnType = returnType;
			this.AdjustFlagsAndWidth(operatorKeyword);
			this.operatorKeyword = operatorKeyword;
			this.AdjustFlagsAndWidth(operatorToken);
			this.operatorToken = operatorToken;
			this.AdjustFlagsAndWidth(parameterList);
			this.parameterList = parameterList;
			if (body != null)
			{
				this.AdjustFlagsAndWidth(body);
				this.body = body;
			}
			if (expressionBody != null)
			{
				this.AdjustFlagsAndWidth(expressionBody);
				this.expressionBody = expressionBody;
			}
			if (semicolonToken != null)
			{
				this.AdjustFlagsAndWidth(semicolonToken);
				this.semicolonToken = semicolonToken;
			}
		}


		public OperatorDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
			: base(kind)
		{
			this.SlotCount = 9;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(returnType);
			this.returnType = returnType;
			this.AdjustFlagsAndWidth(operatorKeyword);
			this.operatorKeyword = operatorKeyword;
			this.AdjustFlagsAndWidth(operatorToken);
			this.operatorToken = operatorToken;
			this.AdjustFlagsAndWidth(parameterList);
			this.parameterList = parameterList;
			if (body != null)
			{
				this.AdjustFlagsAndWidth(body);
				this.body = body;
			}
			if (expressionBody != null)
			{
				this.AdjustFlagsAndWidth(expressionBody);
				this.expressionBody = expressionBody;
			}
			if (semicolonToken != null)
			{
				this.AdjustFlagsAndWidth(semicolonToken);
				this.semicolonToken = semicolonToken;
			}
		}

		public override SyntaxList<AttributeListSyntax> AttributeLists { get { return new SyntaxList<AttributeListSyntax>(this.attributeLists); } }
		public override SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
		/// <summary>Gets the return type.</summary>
		public TypeSyntax ReturnType { get { return this.returnType; } }
		/// <summary>Gets the "operator" keyword.</summary>
		public SyntaxToken OperatorKeyword { get { return this.operatorKeyword; } }
		/// <summary>Gets the operator token.</summary>
		public SyntaxToken OperatorToken { get { return this.operatorToken; } }
		public override ParameterListSyntax ParameterList { get { return this.parameterList; } }
		public override BlockSyntax Body { get { return this.body; } }
		public override ArrowExpressionClauseSyntax ExpressionBody { get { return this.expressionBody; } }
		public override SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.attributeLists;
				case 1: return this.modifiers;
				case 2: return this.returnType;
				case 3: return this.operatorKeyword;
				case 4: return this.operatorToken;
				case 5: return this.parameterList;
				case 6: return this.body;
				case 7: return this.expressionBody;
				case 8: return this.semicolonToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitOperatorDeclaration(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitOperatorDeclaration(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new OperatorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.returnType, this.operatorKeyword, this.operatorToken, this.parameterList, this.body, this.expressionBody, this.semicolonToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new OperatorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.returnType, this.operatorKeyword, this.operatorToken, this.parameterList, this.body, this.expressionBody, this.semicolonToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Conversion operator declaration syntax.</summary>
	public sealed partial class ConversionOperatorDeclarationSyntax : BaseMethodDeclarationSyntax
	{
		public readonly GreenNode attributeLists;
		public readonly GreenNode modifiers;
		public readonly SyntaxToken implicitOrExplicitKeyword;
		public readonly SyntaxToken operatorKeyword;
		public readonly TypeSyntax type;
		public readonly ParameterListSyntax parameterList;
		public readonly BlockSyntax body;
		public readonly ArrowExpressionClauseSyntax expressionBody;
		public readonly SyntaxToken semicolonToken;

		public ConversionOperatorDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 9;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(implicitOrExplicitKeyword);
			this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
			this.AdjustFlagsAndWidth(operatorKeyword);
			this.operatorKeyword = operatorKeyword;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			this.AdjustFlagsAndWidth(parameterList);
			this.parameterList = parameterList;
			if (body != null)
			{
				this.AdjustFlagsAndWidth(body);
				this.body = body;
			}
			if (expressionBody != null)
			{
				this.AdjustFlagsAndWidth(expressionBody);
				this.expressionBody = expressionBody;
			}
			if (semicolonToken != null)
			{
				this.AdjustFlagsAndWidth(semicolonToken);
				this.semicolonToken = semicolonToken;
			}
		}


		public ConversionOperatorDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 9;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(implicitOrExplicitKeyword);
			this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
			this.AdjustFlagsAndWidth(operatorKeyword);
			this.operatorKeyword = operatorKeyword;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			this.AdjustFlagsAndWidth(parameterList);
			this.parameterList = parameterList;
			if (body != null)
			{
				this.AdjustFlagsAndWidth(body);
				this.body = body;
			}
			if (expressionBody != null)
			{
				this.AdjustFlagsAndWidth(expressionBody);
				this.expressionBody = expressionBody;
			}
			if (semicolonToken != null)
			{
				this.AdjustFlagsAndWidth(semicolonToken);
				this.semicolonToken = semicolonToken;
			}
		}


		public ConversionOperatorDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
			: base(kind)
		{
			this.SlotCount = 9;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(implicitOrExplicitKeyword);
			this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
			this.AdjustFlagsAndWidth(operatorKeyword);
			this.operatorKeyword = operatorKeyword;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			this.AdjustFlagsAndWidth(parameterList);
			this.parameterList = parameterList;
			if (body != null)
			{
				this.AdjustFlagsAndWidth(body);
				this.body = body;
			}
			if (expressionBody != null)
			{
				this.AdjustFlagsAndWidth(expressionBody);
				this.expressionBody = expressionBody;
			}
			if (semicolonToken != null)
			{
				this.AdjustFlagsAndWidth(semicolonToken);
				this.semicolonToken = semicolonToken;
			}
		}

		public override SyntaxList<AttributeListSyntax> AttributeLists { get { return new SyntaxList<AttributeListSyntax>(this.attributeLists); } }
		public override SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
		/// <summary>Gets the "implicit" or "explicit" token.</summary>
		public SyntaxToken ImplicitOrExplicitKeyword { get { return this.implicitOrExplicitKeyword; } }
		/// <summary>Gets the "operator" token.</summary>
		public SyntaxToken OperatorKeyword { get { return this.operatorKeyword; } }
		/// <summary>Gets the type.</summary>
		public TypeSyntax Type { get { return this.type; } }
		public override ParameterListSyntax ParameterList { get { return this.parameterList; } }
		public override BlockSyntax Body { get { return this.body; } }
		public override ArrowExpressionClauseSyntax ExpressionBody { get { return this.expressionBody; } }
		/// <summary>Gets the optional semicolon token.</summary>
		public override SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.attributeLists;
				case 1: return this.modifiers;
				case 2: return this.implicitOrExplicitKeyword;
				case 3: return this.operatorKeyword;
				case 4: return this.type;
				case 5: return this.parameterList;
				case 6: return this.body;
				case 7: return this.expressionBody;
				case 8: return this.semicolonToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitConversionOperatorDeclaration(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitConversionOperatorDeclaration(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new ConversionOperatorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.implicitOrExplicitKeyword, this.operatorKeyword, this.type, this.parameterList, this.body, this.expressionBody, this.semicolonToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new ConversionOperatorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.implicitOrExplicitKeyword, this.operatorKeyword, this.type, this.parameterList, this.body, this.expressionBody, this.semicolonToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Constructor declaration syntax.</summary>
	public sealed partial class ConstructorDeclarationSyntax : BaseMethodDeclarationSyntax
	{
		public readonly GreenNode attributeLists;
		public readonly GreenNode modifiers;
		public readonly SyntaxToken identifier;
		public readonly ParameterListSyntax parameterList;
		public readonly ConstructorInitializerSyntax initializer;
		public readonly BlockSyntax body;
		public readonly ArrowExpressionClauseSyntax expressionBody;
		public readonly SyntaxToken semicolonToken;

		public ConstructorDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 8;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			this.AdjustFlagsAndWidth(parameterList);
			this.parameterList = parameterList;
			if (initializer != null)
			{
				this.AdjustFlagsAndWidth(initializer);
				this.initializer = initializer;
			}
			if (body != null)
			{
				this.AdjustFlagsAndWidth(body);
				this.body = body;
			}
			if (expressionBody != null)
			{
				this.AdjustFlagsAndWidth(expressionBody);
				this.expressionBody = expressionBody;
			}
			if (semicolonToken != null)
			{
				this.AdjustFlagsAndWidth(semicolonToken);
				this.semicolonToken = semicolonToken;
			}
		}


		public ConstructorDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 8;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			this.AdjustFlagsAndWidth(parameterList);
			this.parameterList = parameterList;
			if (initializer != null)
			{
				this.AdjustFlagsAndWidth(initializer);
				this.initializer = initializer;
			}
			if (body != null)
			{
				this.AdjustFlagsAndWidth(body);
				this.body = body;
			}
			if (expressionBody != null)
			{
				this.AdjustFlagsAndWidth(expressionBody);
				this.expressionBody = expressionBody;
			}
			if (semicolonToken != null)
			{
				this.AdjustFlagsAndWidth(semicolonToken);
				this.semicolonToken = semicolonToken;
			}
		}


		public ConstructorDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
			: base(kind)
		{
			this.SlotCount = 8;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			this.AdjustFlagsAndWidth(parameterList);
			this.parameterList = parameterList;
			if (initializer != null)
			{
				this.AdjustFlagsAndWidth(initializer);
				this.initializer = initializer;
			}
			if (body != null)
			{
				this.AdjustFlagsAndWidth(body);
				this.body = body;
			}
			if (expressionBody != null)
			{
				this.AdjustFlagsAndWidth(expressionBody);
				this.expressionBody = expressionBody;
			}
			if (semicolonToken != null)
			{
				this.AdjustFlagsAndWidth(semicolonToken);
				this.semicolonToken = semicolonToken;
			}
		}

		public override SyntaxList<AttributeListSyntax> AttributeLists { get { return new SyntaxList<AttributeListSyntax>(this.attributeLists); } }
		public override SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
		/// <summary>Gets the identifier.</summary>
		public SyntaxToken Identifier { get { return this.identifier; } }
		public override ParameterListSyntax ParameterList { get { return this.parameterList; } }
		public ConstructorInitializerSyntax Initializer { get { return this.initializer; } }
		public override BlockSyntax Body { get { return this.body; } }
		public override ArrowExpressionClauseSyntax ExpressionBody { get { return this.expressionBody; } }
		/// <summary>Gets the optional semicolon token.</summary>
		public override SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.attributeLists;
				case 1: return this.modifiers;
				case 2: return this.identifier;
				case 3: return this.parameterList;
				case 4: return this.initializer;
				case 5: return this.body;
				case 6: return this.expressionBody;
				case 7: return this.semicolonToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitConstructorDeclaration(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitConstructorDeclaration(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new ConstructorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.identifier, this.parameterList, this.initializer, this.body, this.expressionBody, this.semicolonToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new ConstructorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.identifier, this.parameterList, this.initializer, this.body, this.expressionBody, this.semicolonToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Constructor initializer syntax.</summary>
	public sealed partial class ConstructorInitializerSyntax : LeeSyntaxNode
	{
		public readonly SyntaxToken colonToken;
		public readonly SyntaxToken thisOrBaseKeyword;
		public readonly ArgumentListSyntax argumentList;

		public ConstructorInitializerSyntax(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(colonToken);
			this.colonToken = colonToken;
			this.AdjustFlagsAndWidth(thisOrBaseKeyword);
			this.thisOrBaseKeyword = thisOrBaseKeyword;
			this.AdjustFlagsAndWidth(argumentList);
			this.argumentList = argumentList;
		}


		public ConstructorInitializerSyntax(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(colonToken);
			this.colonToken = colonToken;
			this.AdjustFlagsAndWidth(thisOrBaseKeyword);
			this.thisOrBaseKeyword = thisOrBaseKeyword;
			this.AdjustFlagsAndWidth(argumentList);
			this.argumentList = argumentList;
		}


		public ConstructorInitializerSyntax(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(colonToken);
			this.colonToken = colonToken;
			this.AdjustFlagsAndWidth(thisOrBaseKeyword);
			this.thisOrBaseKeyword = thisOrBaseKeyword;
			this.AdjustFlagsAndWidth(argumentList);
			this.argumentList = argumentList;
		}

		/// <summary>Gets the colon token.</summary>
		public SyntaxToken ColonToken { get { return this.colonToken; } }
		/// <summary>Gets the "this" or "base" keyword.</summary>
		public SyntaxToken ThisOrBaseKeyword { get { return this.thisOrBaseKeyword; } }
		public ArgumentListSyntax ArgumentList { get { return this.argumentList; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.colonToken;
				case 1: return this.thisOrBaseKeyword;
				case 2: return this.argumentList;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitConstructorInitializer(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitConstructorInitializer(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new ConstructorInitializerSyntax(this.Kind, this.colonToken, this.thisOrBaseKeyword, this.argumentList, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new ConstructorInitializerSyntax(this.Kind, this.colonToken, this.thisOrBaseKeyword, this.argumentList, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Destructor declaration syntax.</summary>
	public sealed partial class DestructorDeclarationSyntax : BaseMethodDeclarationSyntax
	{
		public readonly GreenNode attributeLists;
		public readonly GreenNode modifiers;
		public readonly SyntaxToken tildeToken;
		public readonly SyntaxToken identifier;
		public readonly ParameterListSyntax parameterList;
		public readonly BlockSyntax body;
		public readonly ArrowExpressionClauseSyntax expressionBody;
		public readonly SyntaxToken semicolonToken;

		public DestructorDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 8;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(tildeToken);
			this.tildeToken = tildeToken;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			this.AdjustFlagsAndWidth(parameterList);
			this.parameterList = parameterList;
			if (body != null)
			{
				this.AdjustFlagsAndWidth(body);
				this.body = body;
			}
			if (expressionBody != null)
			{
				this.AdjustFlagsAndWidth(expressionBody);
				this.expressionBody = expressionBody;
			}
			if (semicolonToken != null)
			{
				this.AdjustFlagsAndWidth(semicolonToken);
				this.semicolonToken = semicolonToken;
			}
		}


		public DestructorDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 8;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(tildeToken);
			this.tildeToken = tildeToken;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			this.AdjustFlagsAndWidth(parameterList);
			this.parameterList = parameterList;
			if (body != null)
			{
				this.AdjustFlagsAndWidth(body);
				this.body = body;
			}
			if (expressionBody != null)
			{
				this.AdjustFlagsAndWidth(expressionBody);
				this.expressionBody = expressionBody;
			}
			if (semicolonToken != null)
			{
				this.AdjustFlagsAndWidth(semicolonToken);
				this.semicolonToken = semicolonToken;
			}
		}


		public DestructorDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
			: base(kind)
		{
			this.SlotCount = 8;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(tildeToken);
			this.tildeToken = tildeToken;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			this.AdjustFlagsAndWidth(parameterList);
			this.parameterList = parameterList;
			if (body != null)
			{
				this.AdjustFlagsAndWidth(body);
				this.body = body;
			}
			if (expressionBody != null)
			{
				this.AdjustFlagsAndWidth(expressionBody);
				this.expressionBody = expressionBody;
			}
			if (semicolonToken != null)
			{
				this.AdjustFlagsAndWidth(semicolonToken);
				this.semicolonToken = semicolonToken;
			}
		}

		public override SyntaxList<AttributeListSyntax> AttributeLists { get { return new SyntaxList<AttributeListSyntax>(this.attributeLists); } }
		public override SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
		/// <summary>Gets the tilde token.</summary>
		public SyntaxToken TildeToken { get { return this.tildeToken; } }
		/// <summary>Gets the identifier.</summary>
		public SyntaxToken Identifier { get { return this.identifier; } }
		public override ParameterListSyntax ParameterList { get { return this.parameterList; } }
		public override BlockSyntax Body { get { return this.body; } }
		public override ArrowExpressionClauseSyntax ExpressionBody { get { return this.expressionBody; } }
		/// <summary>Gets the optional semicolon token.</summary>
		public override SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.attributeLists;
				case 1: return this.modifiers;
				case 2: return this.tildeToken;
				case 3: return this.identifier;
				case 4: return this.parameterList;
				case 5: return this.body;
				case 6: return this.expressionBody;
				case 7: return this.semicolonToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitDestructorDeclaration(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitDestructorDeclaration(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new DestructorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.tildeToken, this.identifier, this.parameterList, this.body, this.expressionBody, this.semicolonToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new DestructorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.tildeToken, this.identifier, this.parameterList, this.body, this.expressionBody, this.semicolonToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Base type for property declaration syntax.</summary>
	public abstract partial class BasePropertyDeclarationSyntax : MemberDeclarationSyntax
	{
		public BasePropertyDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
		  : base(kind, diagnostics, annotations)
		{
		}
		public BasePropertyDeclarationSyntax(SyntaxKind kind)
		  : base(kind)
		{
		}

		/// <summary>Gets the attribute declaration list.</summary>
		public abstract SyntaxList<AttributeListSyntax> AttributeLists { get; }

		/// <summary>Gets the modifier list.</summary>
		public abstract SyntaxList<SyntaxToken> Modifiers { get; }

		/// <summary>Gets the type syntax.</summary>
		public abstract TypeSyntax Type { get; }

		/// <summary>Gets the optional explicit interface specifier.</summary>
		public abstract ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get; }

		public abstract AccessorListSyntax AccessorList { get; }
	}

	public sealed partial class PropertyDeclarationSyntax : BasePropertyDeclarationSyntax
	{
		public readonly GreenNode attributeLists;
		public readonly GreenNode modifiers;
		public readonly TypeSyntax type;
		public readonly ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier;
		public readonly SyntaxToken identifier;
		public readonly AccessorListSyntax accessorList;
		public readonly ArrowExpressionClauseSyntax expressionBody;
		public readonly EqualsValueClauseSyntax initializer;
		public readonly SyntaxToken semicolonToken;

		public PropertyDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 9;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			if (explicitInterfaceSpecifier != null)
			{
				this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
				this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
			}
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			if (accessorList != null)
			{
				this.AdjustFlagsAndWidth(accessorList);
				this.accessorList = accessorList;
			}
			if (expressionBody != null)
			{
				this.AdjustFlagsAndWidth(expressionBody);
				this.expressionBody = expressionBody;
			}
			if (initializer != null)
			{
				this.AdjustFlagsAndWidth(initializer);
				this.initializer = initializer;
			}
			if (semicolonToken != null)
			{
				this.AdjustFlagsAndWidth(semicolonToken);
				this.semicolonToken = semicolonToken;
			}
		}


		public PropertyDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer, SyntaxToken semicolonToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 9;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			if (explicitInterfaceSpecifier != null)
			{
				this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
				this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
			}
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			if (accessorList != null)
			{
				this.AdjustFlagsAndWidth(accessorList);
				this.accessorList = accessorList;
			}
			if (expressionBody != null)
			{
				this.AdjustFlagsAndWidth(expressionBody);
				this.expressionBody = expressionBody;
			}
			if (initializer != null)
			{
				this.AdjustFlagsAndWidth(initializer);
				this.initializer = initializer;
			}
			if (semicolonToken != null)
			{
				this.AdjustFlagsAndWidth(semicolonToken);
				this.semicolonToken = semicolonToken;
			}
		}


		public PropertyDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer, SyntaxToken semicolonToken)
			: base(kind)
		{
			this.SlotCount = 9;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			if (explicitInterfaceSpecifier != null)
			{
				this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
				this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
			}
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			if (accessorList != null)
			{
				this.AdjustFlagsAndWidth(accessorList);
				this.accessorList = accessorList;
			}
			if (expressionBody != null)
			{
				this.AdjustFlagsAndWidth(expressionBody);
				this.expressionBody = expressionBody;
			}
			if (initializer != null)
			{
				this.AdjustFlagsAndWidth(initializer);
				this.initializer = initializer;
			}
			if (semicolonToken != null)
			{
				this.AdjustFlagsAndWidth(semicolonToken);
				this.semicolonToken = semicolonToken;
			}
		}

		public override SyntaxList<AttributeListSyntax> AttributeLists { get { return new SyntaxList<AttributeListSyntax>(this.attributeLists); } }
		public override SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
		public override TypeSyntax Type { get { return this.type; } }
		public override ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get { return this.explicitInterfaceSpecifier; } }
		/// <summary>Gets the identifier.</summary>
		public SyntaxToken Identifier { get { return this.identifier; } }
		public override AccessorListSyntax AccessorList { get { return this.accessorList; } }
		public ArrowExpressionClauseSyntax ExpressionBody { get { return this.expressionBody; } }
		public EqualsValueClauseSyntax Initializer { get { return this.initializer; } }
		public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.attributeLists;
				case 1: return this.modifiers;
				case 2: return this.type;
				case 3: return this.explicitInterfaceSpecifier;
				case 4: return this.identifier;
				case 5: return this.accessorList;
				case 6: return this.expressionBody;
				case 7: return this.initializer;
				case 8: return this.semicolonToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitPropertyDeclaration(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitPropertyDeclaration(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new PropertyDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.type, this.explicitInterfaceSpecifier, this.identifier, this.accessorList, this.expressionBody, this.initializer, this.semicolonToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new PropertyDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.type, this.explicitInterfaceSpecifier, this.identifier, this.accessorList, this.expressionBody, this.initializer, this.semicolonToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>The syntax for the expression body of an expression-bodied member.</summary>
	public sealed partial class ArrowExpressionClauseSyntax : LeeSyntaxNode
	{
		public readonly SyntaxToken arrowToken;
		public readonly ExpressionSyntax expression;

		public ArrowExpressionClauseSyntax(SyntaxKind kind, SyntaxToken arrowToken, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(arrowToken);
			this.arrowToken = arrowToken;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
		}


		public ArrowExpressionClauseSyntax(SyntaxKind kind, SyntaxToken arrowToken, ExpressionSyntax expression, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(arrowToken);
			this.arrowToken = arrowToken;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
		}


		public ArrowExpressionClauseSyntax(SyntaxKind kind, SyntaxToken arrowToken, ExpressionSyntax expression)
			: base(kind)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(arrowToken);
			this.arrowToken = arrowToken;
			this.AdjustFlagsAndWidth(expression);
			this.expression = expression;
		}

		public SyntaxToken ArrowToken { get { return this.arrowToken; } }
		public ExpressionSyntax Expression { get { return this.expression; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.arrowToken;
				case 1: return this.expression;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitArrowExpressionClause(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitArrowExpressionClause(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new ArrowExpressionClauseSyntax(this.Kind, this.arrowToken, this.expression, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new ArrowExpressionClauseSyntax(this.Kind, this.arrowToken, this.expression, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class EventDeclarationSyntax : BasePropertyDeclarationSyntax
	{
		public readonly GreenNode attributeLists;
		public readonly GreenNode modifiers;
		public readonly SyntaxToken eventKeyword;
		public readonly TypeSyntax type;
		public readonly ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier;
		public readonly SyntaxToken identifier;
		public readonly AccessorListSyntax accessorList;

		public EventDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 7;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(eventKeyword);
			this.eventKeyword = eventKeyword;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			if (explicitInterfaceSpecifier != null)
			{
				this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
				this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
			}
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			this.AdjustFlagsAndWidth(accessorList);
			this.accessorList = accessorList;
		}


		public EventDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 7;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(eventKeyword);
			this.eventKeyword = eventKeyword;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			if (explicitInterfaceSpecifier != null)
			{
				this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
				this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
			}
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			this.AdjustFlagsAndWidth(accessorList);
			this.accessorList = accessorList;
		}


		public EventDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList)
			: base(kind)
		{
			this.SlotCount = 7;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(eventKeyword);
			this.eventKeyword = eventKeyword;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			if (explicitInterfaceSpecifier != null)
			{
				this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
				this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
			}
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			this.AdjustFlagsAndWidth(accessorList);
			this.accessorList = accessorList;
		}

		public override SyntaxList<AttributeListSyntax> AttributeLists { get { return new SyntaxList<AttributeListSyntax>(this.attributeLists); } }
		public override SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
		public SyntaxToken EventKeyword { get { return this.eventKeyword; } }
		public override TypeSyntax Type { get { return this.type; } }
		public override ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get { return this.explicitInterfaceSpecifier; } }
		/// <summary>Gets the identifier.</summary>
		public SyntaxToken Identifier { get { return this.identifier; } }
		public override AccessorListSyntax AccessorList { get { return this.accessorList; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.attributeLists;
				case 1: return this.modifiers;
				case 2: return this.eventKeyword;
				case 3: return this.type;
				case 4: return this.explicitInterfaceSpecifier;
				case 5: return this.identifier;
				case 6: return this.accessorList;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitEventDeclaration(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitEventDeclaration(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new EventDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.eventKeyword, this.type, this.explicitInterfaceSpecifier, this.identifier, this.accessorList, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new EventDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.eventKeyword, this.type, this.explicitInterfaceSpecifier, this.identifier, this.accessorList, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class IndexerDeclarationSyntax : BasePropertyDeclarationSyntax
	{
		public readonly GreenNode attributeLists;
		public readonly GreenNode modifiers;
		public readonly TypeSyntax type;
		public readonly ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier;
		public readonly SyntaxToken thisKeyword;
		public readonly BracketedParameterListSyntax parameterList;
		public readonly AccessorListSyntax accessorList;
		public readonly ArrowExpressionClauseSyntax expressionBody;
		public readonly SyntaxToken semicolonToken;

		public IndexerDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 9;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			if (explicitInterfaceSpecifier != null)
			{
				this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
				this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
			}
			this.AdjustFlagsAndWidth(thisKeyword);
			this.thisKeyword = thisKeyword;
			this.AdjustFlagsAndWidth(parameterList);
			this.parameterList = parameterList;
			if (accessorList != null)
			{
				this.AdjustFlagsAndWidth(accessorList);
				this.accessorList = accessorList;
			}
			if (expressionBody != null)
			{
				this.AdjustFlagsAndWidth(expressionBody);
				this.expressionBody = expressionBody;
			}
			if (semicolonToken != null)
			{
				this.AdjustFlagsAndWidth(semicolonToken);
				this.semicolonToken = semicolonToken;
			}
		}


		public IndexerDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 9;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			if (explicitInterfaceSpecifier != null)
			{
				this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
				this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
			}
			this.AdjustFlagsAndWidth(thisKeyword);
			this.thisKeyword = thisKeyword;
			this.AdjustFlagsAndWidth(parameterList);
			this.parameterList = parameterList;
			if (accessorList != null)
			{
				this.AdjustFlagsAndWidth(accessorList);
				this.accessorList = accessorList;
			}
			if (expressionBody != null)
			{
				this.AdjustFlagsAndWidth(expressionBody);
				this.expressionBody = expressionBody;
			}
			if (semicolonToken != null)
			{
				this.AdjustFlagsAndWidth(semicolonToken);
				this.semicolonToken = semicolonToken;
			}
		}


		public IndexerDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
			: base(kind)
		{
			this.SlotCount = 9;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			if (explicitInterfaceSpecifier != null)
			{
				this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
				this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
			}
			this.AdjustFlagsAndWidth(thisKeyword);
			this.thisKeyword = thisKeyword;
			this.AdjustFlagsAndWidth(parameterList);
			this.parameterList = parameterList;
			if (accessorList != null)
			{
				this.AdjustFlagsAndWidth(accessorList);
				this.accessorList = accessorList;
			}
			if (expressionBody != null)
			{
				this.AdjustFlagsAndWidth(expressionBody);
				this.expressionBody = expressionBody;
			}
			if (semicolonToken != null)
			{
				this.AdjustFlagsAndWidth(semicolonToken);
				this.semicolonToken = semicolonToken;
			}
		}

		public override SyntaxList<AttributeListSyntax> AttributeLists { get { return new SyntaxList<AttributeListSyntax>(this.attributeLists); } }
		public override SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
		public override TypeSyntax Type { get { return this.type; } }
		public override ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get { return this.explicitInterfaceSpecifier; } }
		public SyntaxToken ThisKeyword { get { return this.thisKeyword; } }
		/// <summary>Gets the parameter list.</summary>
		public BracketedParameterListSyntax ParameterList { get { return this.parameterList; } }
		public override AccessorListSyntax AccessorList { get { return this.accessorList; } }
		public ArrowExpressionClauseSyntax ExpressionBody { get { return this.expressionBody; } }
		public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.attributeLists;
				case 1: return this.modifiers;
				case 2: return this.type;
				case 3: return this.explicitInterfaceSpecifier;
				case 4: return this.thisKeyword;
				case 5: return this.parameterList;
				case 6: return this.accessorList;
				case 7: return this.expressionBody;
				case 8: return this.semicolonToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitIndexerDeclaration(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitIndexerDeclaration(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new IndexerDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.type, this.explicitInterfaceSpecifier, this.thisKeyword, this.parameterList, this.accessorList, this.expressionBody, this.semicolonToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new IndexerDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.type, this.explicitInterfaceSpecifier, this.thisKeyword, this.parameterList, this.accessorList, this.expressionBody, this.semicolonToken, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class AccessorListSyntax : LeeSyntaxNode
	{
		public readonly SyntaxToken openBraceToken;
		public readonly GreenNode accessors;
		public readonly SyntaxToken closeBraceToken;

		public AccessorListSyntax(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode accessors, SyntaxToken closeBraceToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openBraceToken);
			this.openBraceToken = openBraceToken;
			if (accessors != null)
			{
				this.AdjustFlagsAndWidth(accessors);
				this.accessors = accessors;
			}
			this.AdjustFlagsAndWidth(closeBraceToken);
			this.closeBraceToken = closeBraceToken;
		}


		public AccessorListSyntax(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode accessors, SyntaxToken closeBraceToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openBraceToken);
			this.openBraceToken = openBraceToken;
			if (accessors != null)
			{
				this.AdjustFlagsAndWidth(accessors);
				this.accessors = accessors;
			}
			this.AdjustFlagsAndWidth(closeBraceToken);
			this.closeBraceToken = closeBraceToken;
		}


		public AccessorListSyntax(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode accessors, SyntaxToken closeBraceToken)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openBraceToken);
			this.openBraceToken = openBraceToken;
			if (accessors != null)
			{
				this.AdjustFlagsAndWidth(accessors);
				this.accessors = accessors;
			}
			this.AdjustFlagsAndWidth(closeBraceToken);
			this.closeBraceToken = closeBraceToken;
		}

		public SyntaxToken OpenBraceToken { get { return this.openBraceToken; } }
		public SyntaxList<AccessorDeclarationSyntax> Accessors { get { return new SyntaxList<AccessorDeclarationSyntax>(this.accessors); } }
		public SyntaxToken CloseBraceToken { get { return this.closeBraceToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.openBraceToken;
				case 1: return this.accessors;
				case 2: return this.closeBraceToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitAccessorList(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitAccessorList(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new AccessorListSyntax(this.Kind, this.openBraceToken, this.accessors, this.closeBraceToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new AccessorListSyntax(this.Kind, this.openBraceToken, this.accessors, this.closeBraceToken, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class AccessorDeclarationSyntax : LeeSyntaxNode
	{
		public readonly GreenNode attributeLists;
		public readonly GreenNode modifiers;
		public readonly SyntaxToken keyword;
		public readonly BlockSyntax body;
		public readonly ArrowExpressionClauseSyntax expressionBody;
		public readonly SyntaxToken semicolonToken;

		public AccessorDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken keyword, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 6;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
			if (body != null)
			{
				this.AdjustFlagsAndWidth(body);
				this.body = body;
			}
			if (expressionBody != null)
			{
				this.AdjustFlagsAndWidth(expressionBody);
				this.expressionBody = expressionBody;
			}
			if (semicolonToken != null)
			{
				this.AdjustFlagsAndWidth(semicolonToken);
				this.semicolonToken = semicolonToken;
			}
		}


		public AccessorDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken keyword, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 6;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
			if (body != null)
			{
				this.AdjustFlagsAndWidth(body);
				this.body = body;
			}
			if (expressionBody != null)
			{
				this.AdjustFlagsAndWidth(expressionBody);
				this.expressionBody = expressionBody;
			}
			if (semicolonToken != null)
			{
				this.AdjustFlagsAndWidth(semicolonToken);
				this.semicolonToken = semicolonToken;
			}
		}


		public AccessorDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken keyword, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
			: base(kind)
		{
			this.SlotCount = 6;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			this.AdjustFlagsAndWidth(keyword);
			this.keyword = keyword;
			if (body != null)
			{
				this.AdjustFlagsAndWidth(body);
				this.body = body;
			}
			if (expressionBody != null)
			{
				this.AdjustFlagsAndWidth(expressionBody);
				this.expressionBody = expressionBody;
			}
			if (semicolonToken != null)
			{
				this.AdjustFlagsAndWidth(semicolonToken);
				this.semicolonToken = semicolonToken;
			}
		}

		/// <summary>Gets the attribute declaration list.</summary>
		public SyntaxList<AttributeListSyntax> AttributeLists { get { return new SyntaxList<AttributeListSyntax>(this.attributeLists); } }
		/// <summary>Gets the modifier list.</summary>
		public SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
		/// <summary>Gets the keyword token, or identifier if an erroneous accessor declaration.</summary>
		public SyntaxToken Keyword { get { return this.keyword; } }
		/// <summary>Gets the optional body block which may be empty, but it is null if there are no braces.</summary>
		public BlockSyntax Body { get { return this.body; } }
		/// <summary>Gets the optional expression body.</summary>
		public ArrowExpressionClauseSyntax ExpressionBody { get { return this.expressionBody; } }
		/// <summary>Gets the optional semicolon token.</summary>
		public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.attributeLists;
				case 1: return this.modifiers;
				case 2: return this.keyword;
				case 3: return this.body;
				case 4: return this.expressionBody;
				case 5: return this.semicolonToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitAccessorDeclaration(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitAccessorDeclaration(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new AccessorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.body, this.expressionBody, this.semicolonToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new AccessorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.body, this.expressionBody, this.semicolonToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Base type for parameter list syntax.</summary>
	public abstract partial class BaseParameterListSyntax : LeeSyntaxNode
	{
		public BaseParameterListSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
		  : base(kind, diagnostics, annotations)
		{
		}
		public BaseParameterListSyntax(SyntaxKind kind)
		  : base(kind)
		{
		}

		/// <summary>Gets the parameter list.</summary>
		public abstract SeparatedSyntaxList<ParameterSyntax> Parameters { get; }
	}

	/// <summary>Parameter list syntax.</summary>
	public sealed partial class ParameterListSyntax : BaseParameterListSyntax
	{
		public readonly SyntaxToken openParenToken;
		public readonly GreenNode parameters;
		public readonly SyntaxToken closeParenToken;

		public ParameterListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode parameters, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			if (parameters != null)
			{
				this.AdjustFlagsAndWidth(parameters);
				this.parameters = parameters;
			}
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}


		public ParameterListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode parameters, SyntaxToken closeParenToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			if (parameters != null)
			{
				this.AdjustFlagsAndWidth(parameters);
				this.parameters = parameters;
			}
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}


		public ParameterListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode parameters, SyntaxToken closeParenToken)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			if (parameters != null)
			{
				this.AdjustFlagsAndWidth(parameters);
				this.parameters = parameters;
			}
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}

		/// <summary>Gets the open paren token.</summary>
		public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
		public override SeparatedSyntaxList<ParameterSyntax> Parameters { get { return new SeparatedSyntaxList<ParameterSyntax>(new SyntaxList<LeeSyntaxNode>(this.parameters)); } }
		/// <summary>Gets the close paren token.</summary>
		public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.openParenToken;
				case 1: return this.parameters;
				case 2: return this.closeParenToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitParameterList(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitParameterList(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new ParameterListSyntax(this.Kind, this.openParenToken, this.parameters, this.closeParenToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new ParameterListSyntax(this.Kind, this.openParenToken, this.parameters, this.closeParenToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Parameter list syntax with surrounding brackets.</summary>
	public sealed partial class BracketedParameterListSyntax : BaseParameterListSyntax
	{
		public readonly SyntaxToken openBracketToken;
		public readonly GreenNode parameters;
		public readonly SyntaxToken closeBracketToken;

		public BracketedParameterListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode parameters, SyntaxToken closeBracketToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openBracketToken);
			this.openBracketToken = openBracketToken;
			if (parameters != null)
			{
				this.AdjustFlagsAndWidth(parameters);
				this.parameters = parameters;
			}
			this.AdjustFlagsAndWidth(closeBracketToken);
			this.closeBracketToken = closeBracketToken;
		}


		public BracketedParameterListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode parameters, SyntaxToken closeBracketToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openBracketToken);
			this.openBracketToken = openBracketToken;
			if (parameters != null)
			{
				this.AdjustFlagsAndWidth(parameters);
				this.parameters = parameters;
			}
			this.AdjustFlagsAndWidth(closeBracketToken);
			this.closeBracketToken = closeBracketToken;
		}


		public BracketedParameterListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode parameters, SyntaxToken closeBracketToken)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openBracketToken);
			this.openBracketToken = openBracketToken;
			if (parameters != null)
			{
				this.AdjustFlagsAndWidth(parameters);
				this.parameters = parameters;
			}
			this.AdjustFlagsAndWidth(closeBracketToken);
			this.closeBracketToken = closeBracketToken;
		}

		/// <summary>Gets the open bracket token.</summary>
		public SyntaxToken OpenBracketToken { get { return this.openBracketToken; } }
		public override SeparatedSyntaxList<ParameterSyntax> Parameters { get { return new SeparatedSyntaxList<ParameterSyntax>(new SyntaxList<LeeSyntaxNode>(this.parameters)); } }
		/// <summary>Gets the close bracket token.</summary>
		public SyntaxToken CloseBracketToken { get { return this.closeBracketToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.openBracketToken;
				case 1: return this.parameters;
				case 2: return this.closeBracketToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitBracketedParameterList(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitBracketedParameterList(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new BracketedParameterListSyntax(this.Kind, this.openBracketToken, this.parameters, this.closeBracketToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new BracketedParameterListSyntax(this.Kind, this.openBracketToken, this.parameters, this.closeBracketToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>Parameter syntax.</summary>
	public sealed partial class ParameterSyntax : LeeSyntaxNode
	{
		public readonly GreenNode attributeLists;
		public readonly GreenNode modifiers;
		public readonly TypeSyntax type;
		public readonly SyntaxToken identifier;
		public readonly EqualsValueClauseSyntax @default;

		public ParameterSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax @default, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 5;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			if (type != null)
			{
				this.AdjustFlagsAndWidth(type);
				this.type = type;
			}
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			if (@default != null)
			{
				this.AdjustFlagsAndWidth(@default);
				this.@default = @default;
			}
		}


		public ParameterSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax @default, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 5;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			if (type != null)
			{
				this.AdjustFlagsAndWidth(type);
				this.type = type;
			}
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			if (@default != null)
			{
				this.AdjustFlagsAndWidth(@default);
				this.@default = @default;
			}
		}


		public ParameterSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax @default)
			: base(kind)
		{
			this.SlotCount = 5;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			if (type != null)
			{
				this.AdjustFlagsAndWidth(type);
				this.type = type;
			}
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			if (@default != null)
			{
				this.AdjustFlagsAndWidth(@default);
				this.@default = @default;
			}
		}

		/// <summary>Gets the attribute declaration list.</summary>
		public SyntaxList<AttributeListSyntax> AttributeLists { get { return new SyntaxList<AttributeListSyntax>(this.attributeLists); } }
		/// <summary>Gets the modifier list.</summary>
		public SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
		public TypeSyntax Type { get { return this.type; } }
		/// <summary>Gets the identifier.</summary>
		public SyntaxToken Identifier { get { return this.identifier; } }
		public EqualsValueClauseSyntax Default { get { return this.@default; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.attributeLists;
				case 1: return this.modifiers;
				case 2: return this.type;
				case 3: return this.identifier;
				case 4: return this.@default;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitParameter(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitParameter(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new ParameterSyntax(this.Kind, this.attributeLists, this.modifiers, this.type, this.identifier, this.@default, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new ParameterSyntax(this.Kind, this.attributeLists, this.modifiers, this.type, this.identifier, this.@default, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class IncompleteMemberSyntax : MemberDeclarationSyntax
	{
		public readonly GreenNode attributeLists;
		public readonly GreenNode modifiers;
		public readonly TypeSyntax type;

		public IncompleteMemberSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, TypeSyntax type, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			if (type != null)
			{
				this.AdjustFlagsAndWidth(type);
				this.type = type;
			}
		}


		public IncompleteMemberSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, TypeSyntax type, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			if (type != null)
			{
				this.AdjustFlagsAndWidth(type);
				this.type = type;
			}
		}


		public IncompleteMemberSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, TypeSyntax type)
			: base(kind)
		{
			this.SlotCount = 3;
			if (attributeLists != null)
			{
				this.AdjustFlagsAndWidth(attributeLists);
				this.attributeLists = attributeLists;
			}
			if (modifiers != null)
			{
				this.AdjustFlagsAndWidth(modifiers);
				this.modifiers = modifiers;
			}
			if (type != null)
			{
				this.AdjustFlagsAndWidth(type);
				this.type = type;
			}
		}

		/// <summary>Gets the attribute declaration list.</summary>
		public SyntaxList<AttributeListSyntax> AttributeLists { get { return new SyntaxList<AttributeListSyntax>(this.attributeLists); } }
		/// <summary>Gets the modifier list.</summary>
		public SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
		public TypeSyntax Type { get { return this.type; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.attributeLists;
				case 1: return this.modifiers;
				case 2: return this.type;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitIncompleteMember(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitIncompleteMember(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new IncompleteMemberSyntax(this.Kind, this.attributeLists, this.modifiers, this.type, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new IncompleteMemberSyntax(this.Kind, this.attributeLists, this.modifiers, this.type, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class SkippedTokensTriviaSyntax : StructuredTriviaSyntax
	{
		public readonly GreenNode tokens;

		public SkippedTokensTriviaSyntax(SyntaxKind kind, GreenNode tokens, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 1;
			if (tokens != null)
			{
				this.AdjustFlagsAndWidth(tokens);
				this.tokens = tokens;
			}
		}


		public SkippedTokensTriviaSyntax(SyntaxKind kind, GreenNode tokens, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 1;
			if (tokens != null)
			{
				this.AdjustFlagsAndWidth(tokens);
				this.tokens = tokens;
			}
		}


		public SkippedTokensTriviaSyntax(SyntaxKind kind, GreenNode tokens)
			: base(kind)
		{
			this.SlotCount = 1;
			if (tokens != null)
			{
				this.AdjustFlagsAndWidth(tokens);
				this.tokens = tokens;
			}
		}

		public SyntaxList<SyntaxToken> Tokens { get { return new SyntaxList<SyntaxToken>(this.tokens); } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.tokens;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitSkippedTokensTrivia(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitSkippedTokensTrivia(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new SkippedTokensTriviaSyntax(this.Kind, this.tokens, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new SkippedTokensTriviaSyntax(this.Kind, this.tokens, GetDiagnostics(), annotations);
		}
	}

	/// <summary>
	/// A symbol referenced by a cref attribute (e.g. in a &lt;see&gt; or &lt;seealso&gt; documentation comment tag).
	/// For example, the M in &lt;see cref="M" /&gt;.
	/// </summary>
	public abstract partial class CrefSyntax : LeeSyntaxNode
	{
		public CrefSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
		  : base(kind, diagnostics, annotations)
		{
		}
		public CrefSyntax(SyntaxKind kind)
		  : base(kind)
		{
		}
	}

	/// <summary>
	/// A symbol reference that definitely refers to a type.
	/// For example, "int", "A::B", "A.B", "A&lt;T&gt;", but not "M()" (has parameter list) or "this" (indexer).
	/// NOTE: TypeCrefSyntax, QualifiedCrefSyntax, and MemberCrefSyntax overlap.  The syntax in a TypeCrefSyntax
	/// will always be bound as type, so it's safer to use QualifiedCrefSyntax or MemberCrefSyntax if the symbol
	/// might be a non-type member.
	/// </summary>
	public sealed partial class TypeCrefSyntax : CrefSyntax
	{
		public readonly TypeSyntax type;

		public TypeCrefSyntax(SyntaxKind kind, TypeSyntax type, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
		}


		public TypeCrefSyntax(SyntaxKind kind, TypeSyntax type, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
		}


		public TypeCrefSyntax(SyntaxKind kind, TypeSyntax type)
			: base(kind)
		{
			this.SlotCount = 1;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
		}

		public TypeSyntax Type { get { return this.type; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.type;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitTypeCref(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitTypeCref(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new TypeCrefSyntax(this.Kind, this.type, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new TypeCrefSyntax(this.Kind, this.type, GetDiagnostics(), annotations);
		}
	}

	/// <summary>
	/// A symbol reference to a type or non-type member that is qualified by an enclosing type or namespace.
	/// For example, cref="System.String.ToString()".
	/// NOTE: TypeCrefSyntax, QualifiedCrefSyntax, and MemberCrefSyntax overlap.  The syntax in a TypeCrefSyntax
	/// will always be bound as type, so it's safer to use QualifiedCrefSyntax or MemberCrefSyntax if the symbol
	/// might be a non-type member.
	/// </summary>
	public sealed partial class QualifiedCrefSyntax : CrefSyntax
	{
		public readonly TypeSyntax container;
		public readonly SyntaxToken dotToken;
		public readonly MemberCrefSyntax member;

		public QualifiedCrefSyntax(SyntaxKind kind, TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(container);
			this.container = container;
			this.AdjustFlagsAndWidth(dotToken);
			this.dotToken = dotToken;
			this.AdjustFlagsAndWidth(member);
			this.member = member;
		}


		public QualifiedCrefSyntax(SyntaxKind kind, TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(container);
			this.container = container;
			this.AdjustFlagsAndWidth(dotToken);
			this.dotToken = dotToken;
			this.AdjustFlagsAndWidth(member);
			this.member = member;
		}


		public QualifiedCrefSyntax(SyntaxKind kind, TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(container);
			this.container = container;
			this.AdjustFlagsAndWidth(dotToken);
			this.dotToken = dotToken;
			this.AdjustFlagsAndWidth(member);
			this.member = member;
		}

		public TypeSyntax Container { get { return this.container; } }
		public SyntaxToken DotToken { get { return this.dotToken; } }
		public MemberCrefSyntax Member { get { return this.member; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.container;
				case 1: return this.dotToken;
				case 2: return this.member;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitQualifiedCref(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitQualifiedCref(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new QualifiedCrefSyntax(this.Kind, this.container, this.dotToken, this.member, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new QualifiedCrefSyntax(this.Kind, this.container, this.dotToken, this.member, GetDiagnostics(), annotations);
		}
	}

	/// <summary>
	/// The unqualified part of a CrefSyntax.
	/// For example, "ToString()" in "object.ToString()".
	/// NOTE: TypeCrefSyntax, QualifiedCrefSyntax, and MemberCrefSyntax overlap.  The syntax in a TypeCrefSyntax
	/// will always be bound as type, so it's safer to use QualifiedCrefSyntax or MemberCrefSyntax if the symbol
	/// might be a non-type member.
	/// </summary>
	public abstract partial class MemberCrefSyntax : CrefSyntax
	{
		public MemberCrefSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
		  : base(kind, diagnostics, annotations)
		{
		}
		public MemberCrefSyntax(SyntaxKind kind)
		  : base(kind)
		{
		}
	}

	/// <summary>
	/// A MemberCrefSyntax specified by a name (an identifier, predefined type keyword, or an alias-qualified name,
	/// with an optional type parameter list) and an optional parameter list.
	/// For example, "M", "M&lt;T&gt;" or "M(int)".
	/// Also, "A::B()" or "string()".
	/// </summary>
	public sealed partial class NameMemberCrefSyntax : MemberCrefSyntax
	{
		public readonly TypeSyntax name;
		public readonly CrefParameterListSyntax parameters;

		public NameMemberCrefSyntax(SyntaxKind kind, TypeSyntax name, CrefParameterListSyntax parameters, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(name);
			this.name = name;
			if (parameters != null)
			{
				this.AdjustFlagsAndWidth(parameters);
				this.parameters = parameters;
			}
		}


		public NameMemberCrefSyntax(SyntaxKind kind, TypeSyntax name, CrefParameterListSyntax parameters, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(name);
			this.name = name;
			if (parameters != null)
			{
				this.AdjustFlagsAndWidth(parameters);
				this.parameters = parameters;
			}
		}


		public NameMemberCrefSyntax(SyntaxKind kind, TypeSyntax name, CrefParameterListSyntax parameters)
			: base(kind)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(name);
			this.name = name;
			if (parameters != null)
			{
				this.AdjustFlagsAndWidth(parameters);
				this.parameters = parameters;
			}
		}

		public TypeSyntax Name { get { return this.name; } }
		public CrefParameterListSyntax Parameters { get { return this.parameters; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.name;
				case 1: return this.parameters;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitNameMemberCref(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitNameMemberCref(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new NameMemberCrefSyntax(this.Kind, this.name, this.parameters, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new NameMemberCrefSyntax(this.Kind, this.name, this.parameters, GetDiagnostics(), annotations);
		}
	}

	/// <summary>
	/// A MemberCrefSyntax specified by a this keyword and an optional parameter list.
	/// For example, "this" or "this[int]".
	/// </summary>
	public sealed partial class IndexerMemberCrefSyntax : MemberCrefSyntax
	{
		public readonly SyntaxToken thisKeyword;
		public readonly CrefBracketedParameterListSyntax parameters;

		public IndexerMemberCrefSyntax(SyntaxKind kind, SyntaxToken thisKeyword, CrefBracketedParameterListSyntax parameters, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(thisKeyword);
			this.thisKeyword = thisKeyword;
			if (parameters != null)
			{
				this.AdjustFlagsAndWidth(parameters);
				this.parameters = parameters;
			}
		}


		public IndexerMemberCrefSyntax(SyntaxKind kind, SyntaxToken thisKeyword, CrefBracketedParameterListSyntax parameters, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(thisKeyword);
			this.thisKeyword = thisKeyword;
			if (parameters != null)
			{
				this.AdjustFlagsAndWidth(parameters);
				this.parameters = parameters;
			}
		}


		public IndexerMemberCrefSyntax(SyntaxKind kind, SyntaxToken thisKeyword, CrefBracketedParameterListSyntax parameters)
			: base(kind)
		{
			this.SlotCount = 2;
			this.AdjustFlagsAndWidth(thisKeyword);
			this.thisKeyword = thisKeyword;
			if (parameters != null)
			{
				this.AdjustFlagsAndWidth(parameters);
				this.parameters = parameters;
			}
		}

		public SyntaxToken ThisKeyword { get { return this.thisKeyword; } }
		public CrefBracketedParameterListSyntax Parameters { get { return this.parameters; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.thisKeyword;
				case 1: return this.parameters;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitIndexerMemberCref(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitIndexerMemberCref(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new IndexerMemberCrefSyntax(this.Kind, this.thisKeyword, this.parameters, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new IndexerMemberCrefSyntax(this.Kind, this.thisKeyword, this.parameters, GetDiagnostics(), annotations);
		}
	}

	/// <summary>
	/// A MemberCrefSyntax specified by an operator keyword, an operator symbol and an optional parameter list.
	/// For example, "operator +" or "operator -[int]".
	/// NOTE: the operator must be overloadable.
	/// </summary>
	public sealed partial class OperatorMemberCrefSyntax : MemberCrefSyntax
	{
		public readonly SyntaxToken operatorKeyword;
		public readonly SyntaxToken operatorToken;
		public readonly CrefParameterListSyntax parameters;

		public OperatorMemberCrefSyntax(SyntaxKind kind, SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax parameters, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(operatorKeyword);
			this.operatorKeyword = operatorKeyword;
			this.AdjustFlagsAndWidth(operatorToken);
			this.operatorToken = operatorToken;
			if (parameters != null)
			{
				this.AdjustFlagsAndWidth(parameters);
				this.parameters = parameters;
			}
		}


		public OperatorMemberCrefSyntax(SyntaxKind kind, SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax parameters, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(operatorKeyword);
			this.operatorKeyword = operatorKeyword;
			this.AdjustFlagsAndWidth(operatorToken);
			this.operatorToken = operatorToken;
			if (parameters != null)
			{
				this.AdjustFlagsAndWidth(parameters);
				this.parameters = parameters;
			}
		}


		public OperatorMemberCrefSyntax(SyntaxKind kind, SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax parameters)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(operatorKeyword);
			this.operatorKeyword = operatorKeyword;
			this.AdjustFlagsAndWidth(operatorToken);
			this.operatorToken = operatorToken;
			if (parameters != null)
			{
				this.AdjustFlagsAndWidth(parameters);
				this.parameters = parameters;
			}
		}

		public SyntaxToken OperatorKeyword { get { return this.operatorKeyword; } }
		/// <summary>Gets the operator token.</summary>
		public SyntaxToken OperatorToken { get { return this.operatorToken; } }
		public CrefParameterListSyntax Parameters { get { return this.parameters; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.operatorKeyword;
				case 1: return this.operatorToken;
				case 2: return this.parameters;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitOperatorMemberCref(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitOperatorMemberCref(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new OperatorMemberCrefSyntax(this.Kind, this.operatorKeyword, this.operatorToken, this.parameters, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new OperatorMemberCrefSyntax(this.Kind, this.operatorKeyword, this.operatorToken, this.parameters, GetDiagnostics(), annotations);
		}
	}

	/// <summary>
	/// A MemberCrefSyntax specified by an implicit or explicit keyword, an operator keyword, a destination type, and an optional parameter list.
	/// For example, "implicit operator int" or "explicit operator MyType(int)".
	/// </summary>
	public sealed partial class ConversionOperatorMemberCrefSyntax : MemberCrefSyntax
	{
		public readonly SyntaxToken implicitOrExplicitKeyword;
		public readonly SyntaxToken operatorKeyword;
		public readonly TypeSyntax type;
		public readonly CrefParameterListSyntax parameters;

		public ConversionOperatorMemberCrefSyntax(SyntaxKind kind, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax parameters, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(implicitOrExplicitKeyword);
			this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
			this.AdjustFlagsAndWidth(operatorKeyword);
			this.operatorKeyword = operatorKeyword;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			if (parameters != null)
			{
				this.AdjustFlagsAndWidth(parameters);
				this.parameters = parameters;
			}
		}


		public ConversionOperatorMemberCrefSyntax(SyntaxKind kind, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax parameters, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(implicitOrExplicitKeyword);
			this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
			this.AdjustFlagsAndWidth(operatorKeyword);
			this.operatorKeyword = operatorKeyword;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			if (parameters != null)
			{
				this.AdjustFlagsAndWidth(parameters);
				this.parameters = parameters;
			}
		}


		public ConversionOperatorMemberCrefSyntax(SyntaxKind kind, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax parameters)
			: base(kind)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(implicitOrExplicitKeyword);
			this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
			this.AdjustFlagsAndWidth(operatorKeyword);
			this.operatorKeyword = operatorKeyword;
			this.AdjustFlagsAndWidth(type);
			this.type = type;
			if (parameters != null)
			{
				this.AdjustFlagsAndWidth(parameters);
				this.parameters = parameters;
			}
		}

		public SyntaxToken ImplicitOrExplicitKeyword { get { return this.implicitOrExplicitKeyword; } }
		public SyntaxToken OperatorKeyword { get { return this.operatorKeyword; } }
		public TypeSyntax Type { get { return this.type; } }
		public CrefParameterListSyntax Parameters { get { return this.parameters; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.implicitOrExplicitKeyword;
				case 1: return this.operatorKeyword;
				case 2: return this.type;
				case 3: return this.parameters;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitConversionOperatorMemberCref(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitConversionOperatorMemberCref(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new ConversionOperatorMemberCrefSyntax(this.Kind, this.implicitOrExplicitKeyword, this.operatorKeyword, this.type, this.parameters, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new ConversionOperatorMemberCrefSyntax(this.Kind, this.implicitOrExplicitKeyword, this.operatorKeyword, this.type, this.parameters, GetDiagnostics(), annotations);
		}
	}

	/// <summary>
	/// A list of cref parameters with surrounding punctuation.
	/// Unlike regular parameters, cref parameters do not have names.
	/// </summary>
	public abstract partial class BaseCrefParameterListSyntax : LeeSyntaxNode
	{
		public BaseCrefParameterListSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
		  : base(kind, diagnostics, annotations)
		{
		}
		public BaseCrefParameterListSyntax(SyntaxKind kind)
		  : base(kind)
		{
		}

		/// <summary>Gets the parameter list.</summary>
		public abstract SeparatedSyntaxList<CrefParameterSyntax> Parameters { get; }
	}

	/// <summary>
	/// A parenthesized list of cref parameters.
	/// </summary>
	public sealed partial class CrefParameterListSyntax : BaseCrefParameterListSyntax
	{
		public readonly SyntaxToken openParenToken;
		public readonly GreenNode parameters;
		public readonly SyntaxToken closeParenToken;

		public CrefParameterListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode parameters, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			if (parameters != null)
			{
				this.AdjustFlagsAndWidth(parameters);
				this.parameters = parameters;
			}
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}


		public CrefParameterListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode parameters, SyntaxToken closeParenToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			if (parameters != null)
			{
				this.AdjustFlagsAndWidth(parameters);
				this.parameters = parameters;
			}
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}


		public CrefParameterListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode parameters, SyntaxToken closeParenToken)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openParenToken);
			this.openParenToken = openParenToken;
			if (parameters != null)
			{
				this.AdjustFlagsAndWidth(parameters);
				this.parameters = parameters;
			}
			this.AdjustFlagsAndWidth(closeParenToken);
			this.closeParenToken = closeParenToken;
		}

		/// <summary>Gets the open paren token.</summary>
		public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
		public override SeparatedSyntaxList<CrefParameterSyntax> Parameters { get { return new SeparatedSyntaxList<CrefParameterSyntax>(new SyntaxList<LeeSyntaxNode>(this.parameters)); } }
		/// <summary>Gets the close paren token.</summary>
		public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.openParenToken;
				case 1: return this.parameters;
				case 2: return this.closeParenToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitCrefParameterList(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitCrefParameterList(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new CrefParameterListSyntax(this.Kind, this.openParenToken, this.parameters, this.closeParenToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new CrefParameterListSyntax(this.Kind, this.openParenToken, this.parameters, this.closeParenToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>
	/// A bracketed list of cref parameters.
	/// </summary>
	public sealed partial class CrefBracketedParameterListSyntax : BaseCrefParameterListSyntax
	{
		public readonly SyntaxToken openBracketToken;
		public readonly GreenNode parameters;
		public readonly SyntaxToken closeBracketToken;

		public CrefBracketedParameterListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode parameters, SyntaxToken closeBracketToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openBracketToken);
			this.openBracketToken = openBracketToken;
			if (parameters != null)
			{
				this.AdjustFlagsAndWidth(parameters);
				this.parameters = parameters;
			}
			this.AdjustFlagsAndWidth(closeBracketToken);
			this.closeBracketToken = closeBracketToken;
		}


		public CrefBracketedParameterListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode parameters, SyntaxToken closeBracketToken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openBracketToken);
			this.openBracketToken = openBracketToken;
			if (parameters != null)
			{
				this.AdjustFlagsAndWidth(parameters);
				this.parameters = parameters;
			}
			this.AdjustFlagsAndWidth(closeBracketToken);
			this.closeBracketToken = closeBracketToken;
		}


		public CrefBracketedParameterListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode parameters, SyntaxToken closeBracketToken)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(openBracketToken);
			this.openBracketToken = openBracketToken;
			if (parameters != null)
			{
				this.AdjustFlagsAndWidth(parameters);
				this.parameters = parameters;
			}
			this.AdjustFlagsAndWidth(closeBracketToken);
			this.closeBracketToken = closeBracketToken;
		}

		/// <summary>Gets the open bracket token.</summary>
		public SyntaxToken OpenBracketToken { get { return this.openBracketToken; } }
		public override SeparatedSyntaxList<CrefParameterSyntax> Parameters { get { return new SeparatedSyntaxList<CrefParameterSyntax>(new SyntaxList<LeeSyntaxNode>(this.parameters)); } }
		/// <summary>Gets the close bracket token.</summary>
		public SyntaxToken CloseBracketToken { get { return this.closeBracketToken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.openBracketToken;
				case 1: return this.parameters;
				case 2: return this.closeBracketToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitCrefBracketedParameterList(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitCrefBracketedParameterList(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new CrefBracketedParameterListSyntax(this.Kind, this.openBracketToken, this.parameters, this.closeBracketToken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new CrefBracketedParameterListSyntax(this.Kind, this.openBracketToken, this.parameters, this.closeBracketToken, GetDiagnostics(), annotations);
		}
	}

	/// <summary>
	/// An element of a BaseCrefParameterListSyntax.
	/// Unlike a regular parameter, a cref parameter has only an optional ref or out keyword and a type -
	/// there is no name and there are no attributes or other modifiers.
	/// </summary>
	public sealed partial class CrefParameterSyntax : LeeSyntaxNode
	{
		public readonly SyntaxToken refKindKeyword;
		public readonly TypeSyntax type;

		public CrefParameterSyntax(SyntaxKind kind, SyntaxToken refKindKeyword, TypeSyntax type, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 2;
			if (refKindKeyword != null)
			{
				this.AdjustFlagsAndWidth(refKindKeyword);
				this.refKindKeyword = refKindKeyword;
			}
			this.AdjustFlagsAndWidth(type);
			this.type = type;
		}


		public CrefParameterSyntax(SyntaxKind kind, SyntaxToken refKindKeyword, TypeSyntax type, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 2;
			if (refKindKeyword != null)
			{
				this.AdjustFlagsAndWidth(refKindKeyword);
				this.refKindKeyword = refKindKeyword;
			}
			this.AdjustFlagsAndWidth(type);
			this.type = type;
		}


		public CrefParameterSyntax(SyntaxKind kind, SyntaxToken refKindKeyword, TypeSyntax type)
			: base(kind)
		{
			this.SlotCount = 2;
			if (refKindKeyword != null)
			{
				this.AdjustFlagsAndWidth(refKindKeyword);
				this.refKindKeyword = refKindKeyword;
			}
			this.AdjustFlagsAndWidth(type);
			this.type = type;
		}

		public SyntaxToken RefKindKeyword { get { return this.refKindKeyword; } }
		public TypeSyntax Type { get { return this.type; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.refKindKeyword;
				case 1: return this.type;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitCrefParameter(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitCrefParameter(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new CrefParameterSyntax(this.Kind, this.refKindKeyword, this.type, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new CrefParameterSyntax(this.Kind, this.refKindKeyword, this.type, GetDiagnostics(), annotations);
		}
	}


	public abstract partial class DirectiveTriviaSyntax : StructuredTriviaSyntax
	{
		public DirectiveTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
		  : base(kind, diagnostics, annotations)
		{
			this.flags |= NodeFlags.ContainsDirectives;
		}
		public DirectiveTriviaSyntax(SyntaxKind kind)
		  : base(kind)
		{
			this.flags |= NodeFlags.ContainsDirectives;
		}

		public abstract SyntaxToken HashToken { get; }

		public abstract SyntaxToken EndOfDirectiveToken { get; }

		public abstract bool IsActive { get; }
	}

	public abstract partial class BranchingDirectiveTriviaSyntax : DirectiveTriviaSyntax
	{
		public BranchingDirectiveTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
		  : base(kind, diagnostics, annotations)
		{
		}
		public BranchingDirectiveTriviaSyntax(SyntaxKind kind)
		  : base(kind)
		{
		}

		public abstract bool BranchTaken { get; }
	}

	public abstract partial class ConditionalDirectiveTriviaSyntax : BranchingDirectiveTriviaSyntax
	{
		public ConditionalDirectiveTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
		  : base(kind, diagnostics, annotations)
		{
		}
		public ConditionalDirectiveTriviaSyntax(SyntaxKind kind)
		  : base(kind)
		{
		}

		public abstract ExpressionSyntax Condition { get; }

		public abstract bool ConditionValue { get; }
	}

	public sealed partial class IfDirectiveTriviaSyntax : ConditionalDirectiveTriviaSyntax
	{
		public readonly SyntaxToken hashToken;
		public readonly SyntaxToken ifKeyword;
		public readonly ExpressionSyntax condition;
		public readonly SyntaxToken endOfDirectiveToken;
		public readonly bool isActive;
		public readonly bool branchTaken;
		public readonly bool conditionValue;

		public IfDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(ifKeyword);
			this.ifKeyword = ifKeyword;
			this.AdjustFlagsAndWidth(condition);
			this.condition = condition;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
			this.branchTaken = branchTaken;
			this.conditionValue = conditionValue;
		}


		public IfDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(ifKeyword);
			this.ifKeyword = ifKeyword;
			this.AdjustFlagsAndWidth(condition);
			this.condition = condition;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
			this.branchTaken = branchTaken;
			this.conditionValue = conditionValue;
		}


		public IfDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
			: base(kind)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(ifKeyword);
			this.ifKeyword = ifKeyword;
			this.AdjustFlagsAndWidth(condition);
			this.condition = condition;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
			this.branchTaken = branchTaken;
			this.conditionValue = conditionValue;
		}

		public override SyntaxToken HashToken { get { return this.hashToken; } }
		public SyntaxToken IfKeyword { get { return this.ifKeyword; } }
		public override ExpressionSyntax Condition { get { return this.condition; } }
		public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
		public override bool IsActive { get { return this.isActive; } }
		public override bool BranchTaken { get { return this.branchTaken; } }
		public override bool ConditionValue { get { return this.conditionValue; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.hashToken;
				case 1: return this.ifKeyword;
				case 2: return this.condition;
				case 3: return this.endOfDirectiveToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitIfDirectiveTrivia(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitIfDirectiveTrivia(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new IfDirectiveTriviaSyntax(this.Kind, this.hashToken, this.ifKeyword, this.condition, this.endOfDirectiveToken, this.isActive, this.branchTaken, this.conditionValue, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new IfDirectiveTriviaSyntax(this.Kind, this.hashToken, this.ifKeyword, this.condition, this.endOfDirectiveToken, this.isActive, this.branchTaken, this.conditionValue, GetDiagnostics(), annotations);
		}

	}

	public sealed partial class ElifDirectiveTriviaSyntax : ConditionalDirectiveTriviaSyntax
	{
		public readonly SyntaxToken hashToken;
		public readonly SyntaxToken elifKeyword;
		public readonly ExpressionSyntax condition;
		public readonly SyntaxToken endOfDirectiveToken;
		public readonly bool isActive;
		public readonly bool branchTaken;
		public readonly bool conditionValue;

		public ElifDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(elifKeyword);
			this.elifKeyword = elifKeyword;
			this.AdjustFlagsAndWidth(condition);
			this.condition = condition;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
			this.branchTaken = branchTaken;
			this.conditionValue = conditionValue;
		}


		public ElifDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(elifKeyword);
			this.elifKeyword = elifKeyword;
			this.AdjustFlagsAndWidth(condition);
			this.condition = condition;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
			this.branchTaken = branchTaken;
			this.conditionValue = conditionValue;
		}


		public ElifDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
			: base(kind)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(elifKeyword);
			this.elifKeyword = elifKeyword;
			this.AdjustFlagsAndWidth(condition);
			this.condition = condition;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
			this.branchTaken = branchTaken;
			this.conditionValue = conditionValue;
		}

		public override SyntaxToken HashToken { get { return this.hashToken; } }
		public SyntaxToken ElifKeyword { get { return this.elifKeyword; } }
		public override ExpressionSyntax Condition { get { return this.condition; } }
		public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
		public override bool IsActive { get { return this.isActive; } }
		public override bool BranchTaken { get { return this.branchTaken; } }
		public override bool ConditionValue { get { return this.conditionValue; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.hashToken;
				case 1: return this.elifKeyword;
				case 2: return this.condition;
				case 3: return this.endOfDirectiveToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitElifDirectiveTrivia(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitElifDirectiveTrivia(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new ElifDirectiveTriviaSyntax(this.Kind, this.hashToken, this.elifKeyword, this.condition, this.endOfDirectiveToken, this.isActive, this.branchTaken, this.conditionValue, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new ElifDirectiveTriviaSyntax(this.Kind, this.hashToken, this.elifKeyword, this.condition, this.endOfDirectiveToken, this.isActive, this.branchTaken, this.conditionValue, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class ElseDirectiveTriviaSyntax : BranchingDirectiveTriviaSyntax
	{
		public readonly SyntaxToken hashToken;
		public readonly SyntaxToken elseKeyword;
		public readonly SyntaxToken endOfDirectiveToken;
		public readonly bool isActive;
		public readonly bool branchTaken;

		public ElseDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(elseKeyword);
			this.elseKeyword = elseKeyword;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
			this.branchTaken = branchTaken;
		}


		public ElseDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(elseKeyword);
			this.elseKeyword = elseKeyword;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
			this.branchTaken = branchTaken;
		}


		public ElseDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(elseKeyword);
			this.elseKeyword = elseKeyword;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
			this.branchTaken = branchTaken;
		}

		public override SyntaxToken HashToken { get { return this.hashToken; } }
		public SyntaxToken ElseKeyword { get { return this.elseKeyword; } }
		public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
		public override bool IsActive { get { return this.isActive; } }
		public override bool BranchTaken { get { return this.branchTaken; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.hashToken;
				case 1: return this.elseKeyword;
				case 2: return this.endOfDirectiveToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitElseDirectiveTrivia(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitElseDirectiveTrivia(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new ElseDirectiveTriviaSyntax(this.Kind, this.hashToken, this.elseKeyword, this.endOfDirectiveToken, this.isActive, this.branchTaken, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new ElseDirectiveTriviaSyntax(this.Kind, this.hashToken, this.elseKeyword, this.endOfDirectiveToken, this.isActive, this.branchTaken, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class EndIfDirectiveTriviaSyntax : DirectiveTriviaSyntax
	{
		public readonly SyntaxToken hashToken;
		public readonly SyntaxToken endIfKeyword;
		public readonly SyntaxToken endOfDirectiveToken;
		public readonly bool isActive;

		public EndIfDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(endIfKeyword);
			this.endIfKeyword = endIfKeyword;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
		}


		public EndIfDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(endIfKeyword);
			this.endIfKeyword = endIfKeyword;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
		}


		public EndIfDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(endIfKeyword);
			this.endIfKeyword = endIfKeyword;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
		}

		public override SyntaxToken HashToken { get { return this.hashToken; } }
		public SyntaxToken EndIfKeyword { get { return this.endIfKeyword; } }
		public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
		public override bool IsActive { get { return this.isActive; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.hashToken;
				case 1: return this.endIfKeyword;
				case 2: return this.endOfDirectiveToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitEndIfDirectiveTrivia(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitEndIfDirectiveTrivia(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new EndIfDirectiveTriviaSyntax(this.Kind, this.hashToken, this.endIfKeyword, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new EndIfDirectiveTriviaSyntax(this.Kind, this.hashToken, this.endIfKeyword, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class RegionDirectiveTriviaSyntax : DirectiveTriviaSyntax
	{
		public readonly SyntaxToken hashToken;
		public readonly SyntaxToken regionKeyword;
		public readonly SyntaxToken endOfDirectiveToken;
		public readonly bool isActive;

		public RegionDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(regionKeyword);
			this.regionKeyword = regionKeyword;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
		}


		public RegionDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(regionKeyword);
			this.regionKeyword = regionKeyword;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
		}


		public RegionDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(regionKeyword);
			this.regionKeyword = regionKeyword;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
		}

		public override SyntaxToken HashToken { get { return this.hashToken; } }
		public SyntaxToken RegionKeyword { get { return this.regionKeyword; } }
		public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
		public override bool IsActive { get { return this.isActive; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.hashToken;
				case 1: return this.regionKeyword;
				case 2: return this.endOfDirectiveToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitRegionDirectiveTrivia(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitRegionDirectiveTrivia(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new RegionDirectiveTriviaSyntax(this.Kind, this.hashToken, this.regionKeyword, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new RegionDirectiveTriviaSyntax(this.Kind, this.hashToken, this.regionKeyword, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class EndRegionDirectiveTriviaSyntax : DirectiveTriviaSyntax
	{
		public readonly SyntaxToken hashToken;
		public readonly SyntaxToken endRegionKeyword;
		public readonly SyntaxToken endOfDirectiveToken;
		public readonly bool isActive;

		public EndRegionDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(endRegionKeyword);
			this.endRegionKeyword = endRegionKeyword;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
		}


		public EndRegionDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(endRegionKeyword);
			this.endRegionKeyword = endRegionKeyword;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
		}


		public EndRegionDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(endRegionKeyword);
			this.endRegionKeyword = endRegionKeyword;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
		}

		public override SyntaxToken HashToken { get { return this.hashToken; } }
		public SyntaxToken EndRegionKeyword { get { return this.endRegionKeyword; } }
		public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
		public override bool IsActive { get { return this.isActive; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.hashToken;
				case 1: return this.endRegionKeyword;
				case 2: return this.endOfDirectiveToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitEndRegionDirectiveTrivia(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitEndRegionDirectiveTrivia(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new EndRegionDirectiveTriviaSyntax(this.Kind, this.hashToken, this.endRegionKeyword, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new EndRegionDirectiveTriviaSyntax(this.Kind, this.hashToken, this.endRegionKeyword, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class ErrorDirectiveTriviaSyntax : DirectiveTriviaSyntax
	{
		public readonly SyntaxToken hashToken;
		public readonly SyntaxToken errorKeyword;
		public readonly SyntaxToken endOfDirectiveToken;
		public readonly bool isActive;

		public ErrorDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(errorKeyword);
			this.errorKeyword = errorKeyword;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
		}


		public ErrorDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(errorKeyword);
			this.errorKeyword = errorKeyword;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
		}


		public ErrorDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(errorKeyword);
			this.errorKeyword = errorKeyword;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
		}

		public override SyntaxToken HashToken { get { return this.hashToken; } }
		public SyntaxToken ErrorKeyword { get { return this.errorKeyword; } }
		public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
		public override bool IsActive { get { return this.isActive; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.hashToken;
				case 1: return this.errorKeyword;
				case 2: return this.endOfDirectiveToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitErrorDirectiveTrivia(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitErrorDirectiveTrivia(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new ErrorDirectiveTriviaSyntax(this.Kind, this.hashToken, this.errorKeyword, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new ErrorDirectiveTriviaSyntax(this.Kind, this.hashToken, this.errorKeyword, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class WarningDirectiveTriviaSyntax : DirectiveTriviaSyntax
	{
		public readonly SyntaxToken hashToken;
		public readonly SyntaxToken warningKeyword;
		public readonly SyntaxToken endOfDirectiveToken;
		public readonly bool isActive;

		public WarningDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(warningKeyword);
			this.warningKeyword = warningKeyword;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
		}


		public WarningDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(warningKeyword);
			this.warningKeyword = warningKeyword;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
		}


		public WarningDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(warningKeyword);
			this.warningKeyword = warningKeyword;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
		}

		public override SyntaxToken HashToken { get { return this.hashToken; } }
		public SyntaxToken WarningKeyword { get { return this.warningKeyword; } }
		public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
		public override bool IsActive { get { return this.isActive; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.hashToken;
				case 1: return this.warningKeyword;
				case 2: return this.endOfDirectiveToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitWarningDirectiveTrivia(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitWarningDirectiveTrivia(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new WarningDirectiveTriviaSyntax(this.Kind, this.hashToken, this.warningKeyword, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new WarningDirectiveTriviaSyntax(this.Kind, this.hashToken, this.warningKeyword, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class BadDirectiveTriviaSyntax : DirectiveTriviaSyntax
	{
		public readonly SyntaxToken hashToken;
		public readonly SyntaxToken identifier;
		public readonly SyntaxToken endOfDirectiveToken;
		public readonly bool isActive;

		public BadDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
		}


		public BadDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
		}


		public BadDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(identifier);
			this.identifier = identifier;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
		}

		public override SyntaxToken HashToken { get { return this.hashToken; } }
		public SyntaxToken Identifier { get { return this.identifier; } }
		public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
		public override bool IsActive { get { return this.isActive; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.hashToken;
				case 1: return this.identifier;
				case 2: return this.endOfDirectiveToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitBadDirectiveTrivia(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitBadDirectiveTrivia(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new BadDirectiveTriviaSyntax(this.Kind, this.hashToken, this.identifier, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new BadDirectiveTriviaSyntax(this.Kind, this.hashToken, this.identifier, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class DefineDirectiveTriviaSyntax : DirectiveTriviaSyntax
	{
		public readonly SyntaxToken hashToken;
		public readonly SyntaxToken defineKeyword;
		public readonly SyntaxToken name;
		public readonly SyntaxToken endOfDirectiveToken;
		public readonly bool isActive;

		public DefineDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(defineKeyword);
			this.defineKeyword = defineKeyword;
			this.AdjustFlagsAndWidth(name);
			this.name = name;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
		}


		public DefineDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(defineKeyword);
			this.defineKeyword = defineKeyword;
			this.AdjustFlagsAndWidth(name);
			this.name = name;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
		}


		public DefineDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
			: base(kind)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(defineKeyword);
			this.defineKeyword = defineKeyword;
			this.AdjustFlagsAndWidth(name);
			this.name = name;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
		}

		public override SyntaxToken HashToken { get { return this.hashToken; } }
		public SyntaxToken DefineKeyword { get { return this.defineKeyword; } }
		public SyntaxToken Name { get { return this.name; } }
		public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
		public override bool IsActive { get { return this.isActive; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.hashToken;
				case 1: return this.defineKeyword;
				case 2: return this.name;
				case 3: return this.endOfDirectiveToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitDefineDirectiveTrivia(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitDefineDirectiveTrivia(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new DefineDirectiveTriviaSyntax(this.Kind, this.hashToken, this.defineKeyword, this.name, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new DefineDirectiveTriviaSyntax(this.Kind, this.hashToken, this.defineKeyword, this.name, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class UndefDirectiveTriviaSyntax : DirectiveTriviaSyntax
	{
		public readonly SyntaxToken hashToken;
		public readonly SyntaxToken undefKeyword;
		public readonly SyntaxToken name;
		public readonly SyntaxToken endOfDirectiveToken;
		public readonly bool isActive;

		public UndefDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(undefKeyword);
			this.undefKeyword = undefKeyword;
			this.AdjustFlagsAndWidth(name);
			this.name = name;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
		}


		public UndefDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(undefKeyword);
			this.undefKeyword = undefKeyword;
			this.AdjustFlagsAndWidth(name);
			this.name = name;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
		}


		public UndefDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
			: base(kind)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(undefKeyword);
			this.undefKeyword = undefKeyword;
			this.AdjustFlagsAndWidth(name);
			this.name = name;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
		}

		public override SyntaxToken HashToken { get { return this.hashToken; } }
		public SyntaxToken UndefKeyword { get { return this.undefKeyword; } }
		public SyntaxToken Name { get { return this.name; } }
		public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
		public override bool IsActive { get { return this.isActive; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.hashToken;
				case 1: return this.undefKeyword;
				case 2: return this.name;
				case 3: return this.endOfDirectiveToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitUndefDirectiveTrivia(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitUndefDirectiveTrivia(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new UndefDirectiveTriviaSyntax(this.Kind, this.hashToken, this.undefKeyword, this.name, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new UndefDirectiveTriviaSyntax(this.Kind, this.hashToken, this.undefKeyword, this.name, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class LineDirectiveTriviaSyntax : DirectiveTriviaSyntax
	{
		public readonly SyntaxToken hashToken;
		public readonly SyntaxToken lineKeyword;
		public readonly SyntaxToken line;
		public readonly SyntaxToken file;
		public readonly SyntaxToken endOfDirectiveToken;
		public readonly bool isActive;

		public LineDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 5;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(lineKeyword);
			this.lineKeyword = lineKeyword;
			this.AdjustFlagsAndWidth(line);
			this.line = line;
			if (file != null)
			{
				this.AdjustFlagsAndWidth(file);
				this.file = file;
			}
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
		}


		public LineDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 5;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(lineKeyword);
			this.lineKeyword = lineKeyword;
			this.AdjustFlagsAndWidth(line);
			this.line = line;
			if (file != null)
			{
				this.AdjustFlagsAndWidth(file);
				this.file = file;
			}
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
		}


		public LineDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
			: base(kind)
		{
			this.SlotCount = 5;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(lineKeyword);
			this.lineKeyword = lineKeyword;
			this.AdjustFlagsAndWidth(line);
			this.line = line;
			if (file != null)
			{
				this.AdjustFlagsAndWidth(file);
				this.file = file;
			}
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
		}

		public override SyntaxToken HashToken { get { return this.hashToken; } }
		public SyntaxToken LineKeyword { get { return this.lineKeyword; } }
		public SyntaxToken Line { get { return this.line; } }
		public SyntaxToken File { get { return this.file; } }
		public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
		public override bool IsActive { get { return this.isActive; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.hashToken;
				case 1: return this.lineKeyword;
				case 2: return this.line;
				case 3: return this.file;
				case 4: return this.endOfDirectiveToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitLineDirectiveTrivia(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitLineDirectiveTrivia(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new LineDirectiveTriviaSyntax(this.Kind, this.hashToken, this.lineKeyword, this.line, this.file, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new LineDirectiveTriviaSyntax(this.Kind, this.hashToken, this.lineKeyword, this.line, this.file, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class PragmaWarningDirectiveTriviaSyntax : DirectiveTriviaSyntax
	{
		public readonly SyntaxToken hashToken;
		public readonly SyntaxToken pragmaKeyword;
		public readonly SyntaxToken warningKeyword;
		public readonly SyntaxToken disableOrRestoreKeyword;
		public readonly SyntaxToken nullableKeyword;
		public readonly GreenNode errorCodes;
		public readonly SyntaxToken endOfDirectiveToken;
		public readonly bool isActive;

		public PragmaWarningDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, SyntaxToken nullableKeyword, GreenNode errorCodes, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 7;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(pragmaKeyword);
			this.pragmaKeyword = pragmaKeyword;
			this.AdjustFlagsAndWidth(warningKeyword);
			this.warningKeyword = warningKeyword;
			this.AdjustFlagsAndWidth(disableOrRestoreKeyword);
			this.disableOrRestoreKeyword = disableOrRestoreKeyword;
			if (nullableKeyword != null)
			{
				this.AdjustFlagsAndWidth(nullableKeyword);
				this.nullableKeyword = nullableKeyword;
			}
			if (errorCodes != null)
			{
				this.AdjustFlagsAndWidth(errorCodes);
				this.errorCodes = errorCodes;
			}
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
		}


		public PragmaWarningDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, SyntaxToken nullableKeyword, GreenNode errorCodes, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 7;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(pragmaKeyword);
			this.pragmaKeyword = pragmaKeyword;
			this.AdjustFlagsAndWidth(warningKeyword);
			this.warningKeyword = warningKeyword;
			this.AdjustFlagsAndWidth(disableOrRestoreKeyword);
			this.disableOrRestoreKeyword = disableOrRestoreKeyword;
			if (nullableKeyword != null)
			{
				this.AdjustFlagsAndWidth(nullableKeyword);
				this.nullableKeyword = nullableKeyword;
			}
			if (errorCodes != null)
			{
				this.AdjustFlagsAndWidth(errorCodes);
				this.errorCodes = errorCodes;
			}
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
		}


		public PragmaWarningDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, SyntaxToken nullableKeyword, GreenNode errorCodes, SyntaxToken endOfDirectiveToken, bool isActive)
			: base(kind)
		{
			this.SlotCount = 7;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(pragmaKeyword);
			this.pragmaKeyword = pragmaKeyword;
			this.AdjustFlagsAndWidth(warningKeyword);
			this.warningKeyword = warningKeyword;
			this.AdjustFlagsAndWidth(disableOrRestoreKeyword);
			this.disableOrRestoreKeyword = disableOrRestoreKeyword;
			if (nullableKeyword != null)
			{
				this.AdjustFlagsAndWidth(nullableKeyword);
				this.nullableKeyword = nullableKeyword;
			}
			if (errorCodes != null)
			{
				this.AdjustFlagsAndWidth(errorCodes);
				this.errorCodes = errorCodes;
			}
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
		}

		public override SyntaxToken HashToken { get { return this.hashToken; } }
		public SyntaxToken PragmaKeyword { get { return this.pragmaKeyword; } }
		public SyntaxToken WarningKeyword { get { return this.warningKeyword; } }
		public SyntaxToken DisableOrRestoreKeyword { get { return this.disableOrRestoreKeyword; } }
		public SyntaxToken NullableKeyword { get { return this.nullableKeyword; } }
		public SeparatedSyntaxList<ExpressionSyntax> ErrorCodes { get { return new SeparatedSyntaxList<ExpressionSyntax>(new SyntaxList<LeeSyntaxNode>(this.errorCodes)); } }
		public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
		public override bool IsActive { get { return this.isActive; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.hashToken;
				case 1: return this.pragmaKeyword;
				case 2: return this.warningKeyword;
				case 3: return this.disableOrRestoreKeyword;
				case 4: return this.nullableKeyword;
				case 5: return this.errorCodes;
				case 6: return this.endOfDirectiveToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitPragmaWarningDirectiveTrivia(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitPragmaWarningDirectiveTrivia(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new PragmaWarningDirectiveTriviaSyntax(this.Kind, this.hashToken, this.pragmaKeyword, this.warningKeyword, this.disableOrRestoreKeyword, this.nullableKeyword, this.errorCodes, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new PragmaWarningDirectiveTriviaSyntax(this.Kind, this.hashToken, this.pragmaKeyword, this.warningKeyword, this.disableOrRestoreKeyword, this.nullableKeyword, this.errorCodes, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class PragmaChecksumDirectiveTriviaSyntax : DirectiveTriviaSyntax
	{
		public readonly SyntaxToken hashToken;
		public readonly SyntaxToken pragmaKeyword;
		public readonly SyntaxToken checksumKeyword;
		public readonly SyntaxToken file;
		public readonly SyntaxToken guid;
		public readonly SyntaxToken bytes;
		public readonly SyntaxToken endOfDirectiveToken;
		public readonly bool isActive;

		public PragmaChecksumDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 7;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(pragmaKeyword);
			this.pragmaKeyword = pragmaKeyword;
			this.AdjustFlagsAndWidth(checksumKeyword);
			this.checksumKeyword = checksumKeyword;
			this.AdjustFlagsAndWidth(file);
			this.file = file;
			this.AdjustFlagsAndWidth(guid);
			this.guid = guid;
			this.AdjustFlagsAndWidth(bytes);
			this.bytes = bytes;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
		}


		public PragmaChecksumDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 7;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(pragmaKeyword);
			this.pragmaKeyword = pragmaKeyword;
			this.AdjustFlagsAndWidth(checksumKeyword);
			this.checksumKeyword = checksumKeyword;
			this.AdjustFlagsAndWidth(file);
			this.file = file;
			this.AdjustFlagsAndWidth(guid);
			this.guid = guid;
			this.AdjustFlagsAndWidth(bytes);
			this.bytes = bytes;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
		}


		public PragmaChecksumDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive)
			: base(kind)
		{
			this.SlotCount = 7;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(pragmaKeyword);
			this.pragmaKeyword = pragmaKeyword;
			this.AdjustFlagsAndWidth(checksumKeyword);
			this.checksumKeyword = checksumKeyword;
			this.AdjustFlagsAndWidth(file);
			this.file = file;
			this.AdjustFlagsAndWidth(guid);
			this.guid = guid;
			this.AdjustFlagsAndWidth(bytes);
			this.bytes = bytes;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
		}

		public override SyntaxToken HashToken { get { return this.hashToken; } }
		public SyntaxToken PragmaKeyword { get { return this.pragmaKeyword; } }
		public SyntaxToken ChecksumKeyword { get { return this.checksumKeyword; } }
		public SyntaxToken File { get { return this.file; } }
		public SyntaxToken Guid { get { return this.guid; } }
		public SyntaxToken Bytes { get { return this.bytes; } }
		public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
		public override bool IsActive { get { return this.isActive; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.hashToken;
				case 1: return this.pragmaKeyword;
				case 2: return this.checksumKeyword;
				case 3: return this.file;
				case 4: return this.guid;
				case 5: return this.bytes;
				case 6: return this.endOfDirectiveToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitPragmaChecksumDirectiveTrivia(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitPragmaChecksumDirectiveTrivia(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new PragmaChecksumDirectiveTriviaSyntax(this.Kind, this.hashToken, this.pragmaKeyword, this.checksumKeyword, this.file, this.guid, this.bytes, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new PragmaChecksumDirectiveTriviaSyntax(this.Kind, this.hashToken, this.pragmaKeyword, this.checksumKeyword, this.file, this.guid, this.bytes, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class ReferenceDirectiveTriviaSyntax : DirectiveTriviaSyntax
	{
		public readonly SyntaxToken hashToken;
		public readonly SyntaxToken referenceKeyword;
		public readonly SyntaxToken file;
		public readonly SyntaxToken endOfDirectiveToken;
		public readonly bool isActive;

		public ReferenceDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(referenceKeyword);
			this.referenceKeyword = referenceKeyword;
			this.AdjustFlagsAndWidth(file);
			this.file = file;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
		}


		public ReferenceDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(referenceKeyword);
			this.referenceKeyword = referenceKeyword;
			this.AdjustFlagsAndWidth(file);
			this.file = file;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
		}


		public ReferenceDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
			: base(kind)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(referenceKeyword);
			this.referenceKeyword = referenceKeyword;
			this.AdjustFlagsAndWidth(file);
			this.file = file;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
		}

		public override SyntaxToken HashToken { get { return this.hashToken; } }
		public SyntaxToken ReferenceKeyword { get { return this.referenceKeyword; } }
		public SyntaxToken File { get { return this.file; } }
		public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
		public override bool IsActive { get { return this.isActive; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.hashToken;
				case 1: return this.referenceKeyword;
				case 2: return this.file;
				case 3: return this.endOfDirectiveToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitReferenceDirectiveTrivia(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitReferenceDirectiveTrivia(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new ReferenceDirectiveTriviaSyntax(this.Kind, this.hashToken, this.referenceKeyword, this.file, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new ReferenceDirectiveTriviaSyntax(this.Kind, this.hashToken, this.referenceKeyword, this.file, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class LoadDirectiveTriviaSyntax : DirectiveTriviaSyntax
	{
		public readonly SyntaxToken hashToken;
		public readonly SyntaxToken loadKeyword;
		public readonly SyntaxToken file;
		public readonly SyntaxToken endOfDirectiveToken;
		public readonly bool isActive;

		public LoadDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(loadKeyword);
			this.loadKeyword = loadKeyword;
			this.AdjustFlagsAndWidth(file);
			this.file = file;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
		}


		public LoadDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(loadKeyword);
			this.loadKeyword = loadKeyword;
			this.AdjustFlagsAndWidth(file);
			this.file = file;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
		}


		public LoadDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
			: base(kind)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(loadKeyword);
			this.loadKeyword = loadKeyword;
			this.AdjustFlagsAndWidth(file);
			this.file = file;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
		}

		public override SyntaxToken HashToken { get { return this.hashToken; } }
		public SyntaxToken LoadKeyword { get { return this.loadKeyword; } }
		public SyntaxToken File { get { return this.file; } }
		public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
		public override bool IsActive { get { return this.isActive; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.hashToken;
				case 1: return this.loadKeyword;
				case 2: return this.file;
				case 3: return this.endOfDirectiveToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitLoadDirectiveTrivia(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitLoadDirectiveTrivia(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new LoadDirectiveTriviaSyntax(this.Kind, this.hashToken, this.loadKeyword, this.file, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new LoadDirectiveTriviaSyntax(this.Kind, this.hashToken, this.loadKeyword, this.file, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class ShebangDirectiveTriviaSyntax : DirectiveTriviaSyntax
	{
		public readonly SyntaxToken hashToken;
		public readonly SyntaxToken exclamationToken;
		public readonly SyntaxToken endOfDirectiveToken;
		public readonly bool isActive;

		public ShebangDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(exclamationToken);
			this.exclamationToken = exclamationToken;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
		}


		public ShebangDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(exclamationToken);
			this.exclamationToken = exclamationToken;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
		}


		public ShebangDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive)
			: base(kind)
		{
			this.SlotCount = 3;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(exclamationToken);
			this.exclamationToken = exclamationToken;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
		}

		public override SyntaxToken HashToken { get { return this.hashToken; } }
		public SyntaxToken ExclamationToken { get { return this.exclamationToken; } }
		public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
		public override bool IsActive { get { return this.isActive; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.hashToken;
				case 1: return this.exclamationToken;
				case 2: return this.endOfDirectiveToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitShebangDirectiveTrivia(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitShebangDirectiveTrivia(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new ShebangDirectiveTriviaSyntax(this.Kind, this.hashToken, this.exclamationToken, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new ShebangDirectiveTriviaSyntax(this.Kind, this.hashToken, this.exclamationToken, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
		}
	}

	public sealed partial class NullableDirectiveTriviaSyntax : DirectiveTriviaSyntax
	{
		public readonly SyntaxToken hashToken;
		public readonly SyntaxToken nullableKeyword;
		public readonly SyntaxToken settingToken;
		public readonly SyntaxToken endOfDirectiveToken;
		public readonly bool isActive;

		public NullableDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken nullableKeyword, SyntaxToken settingToken, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
			: base(kind, diagnostics, annotations)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(nullableKeyword);
			this.nullableKeyword = nullableKeyword;
			this.AdjustFlagsAndWidth(settingToken);
			this.settingToken = settingToken;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
		}


		public NullableDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken nullableKeyword, SyntaxToken settingToken, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
			: base(kind)
		{
			this.SetFactoryContext(context);
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(nullableKeyword);
			this.nullableKeyword = nullableKeyword;
			this.AdjustFlagsAndWidth(settingToken);
			this.settingToken = settingToken;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
		}


		public NullableDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken nullableKeyword, SyntaxToken settingToken, SyntaxToken endOfDirectiveToken, bool isActive)
			: base(kind)
		{
			this.SlotCount = 4;
			this.AdjustFlagsAndWidth(hashToken);
			this.hashToken = hashToken;
			this.AdjustFlagsAndWidth(nullableKeyword);
			this.nullableKeyword = nullableKeyword;
			this.AdjustFlagsAndWidth(settingToken);
			this.settingToken = settingToken;
			this.AdjustFlagsAndWidth(endOfDirectiveToken);
			this.endOfDirectiveToken = endOfDirectiveToken;
			this.isActive = isActive;
		}

		public override SyntaxToken HashToken { get { return this.hashToken; } }
		public SyntaxToken NullableKeyword { get { return this.nullableKeyword; } }
		public SyntaxToken SettingToken { get { return this.settingToken; } }
		public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
		public override bool IsActive { get { return this.isActive; } }

		public override GreenNode GetSlot(int index)
		{
			switch (index)
			{
				case 0: return this.hashToken;
				case 1: return this.nullableKeyword;
				case 2: return this.settingToken;
				case 3: return this.endOfDirectiveToken;
				default: return null;
			}
		}

		public override TResult Accept<TResult>(LeeSyntaxVisitor<TResult> visitor)
		{
			return visitor.VisitNullableDirectiveTrivia(this);
		}

		public override void Accept(LeeSyntaxVisitor visitor)
		{
			visitor.VisitNullableDirectiveTrivia(this);
		}

		public override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
		{
			return new NullableDirectiveTriviaSyntax(this.Kind, this.hashToken, this.nullableKeyword, this.settingToken, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
		}

		public override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
		{
			return new NullableDirectiveTriviaSyntax(this.Kind, this.hashToken, this.nullableKeyword, this.settingToken, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
		}
	}

	public partial class LeeSyntaxVisitor<TResult>
	{
		public virtual TResult VisitIdentifierName(IdentifierNameSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitQualifiedName(QualifiedNameSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitGenericName(GenericNameSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitTypeArgumentList(TypeArgumentListSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitAliasQualifiedName(AliasQualifiedNameSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitPredefinedType(PredefinedTypeSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitArrayType(ArrayTypeSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitPointerType(PointerTypeSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitNullableType(NullableTypeSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitTupleType(TupleTypeSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitTupleElement(TupleElementSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitOmittedTypeArgument(OmittedTypeArgumentSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitRefType(RefTypeSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitParenthesizedExpression(ParenthesizedExpressionSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitTupleExpression(TupleExpressionSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitPrefixUnaryExpression(PrefixUnaryExpressionSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitAwaitExpression(AwaitExpressionSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitPostfixUnaryExpression(PostfixUnaryExpressionSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitMemberAccessExpression(MemberAccessExpressionSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitConditionalAccessExpression(ConditionalAccessExpressionSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitMemberBindingExpression(MemberBindingExpressionSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitElementBindingExpression(ElementBindingExpressionSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitRangeExpression(RangeExpressionSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitImplicitElementAccess(ImplicitElementAccessSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitBinaryExpression(BinaryExpressionSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitAssignmentExpression(AssignmentExpressionSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitConditionalExpression(ConditionalExpressionSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitThisExpression(ThisExpressionSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitBaseExpression(BaseExpressionSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitLiteralExpression(LiteralExpressionSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitMakeRefExpression(MakeRefExpressionSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitRefTypeExpression(RefTypeExpressionSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitRefValueExpression(RefValueExpressionSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitCheckedExpression(CheckedExpressionSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitDefaultExpression(DefaultExpressionSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitTypeOfExpression(TypeOfExpressionSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitSizeOfExpression(SizeOfExpressionSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitInvocationExpression(InvocationExpressionSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitElementAccessExpression(ElementAccessExpressionSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitArgumentList(ArgumentListSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitBracketedArgumentList(BracketedArgumentListSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitArgument(ArgumentSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitNameColon(NameColonSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitDeclarationExpression(DeclarationExpressionSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitCastExpression(CastExpressionSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitAnonymousMethodExpression(AnonymousMethodExpressionSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitRefExpression(RefExpressionSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitInitializerExpression(InitializerExpressionSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitObjectCreationExpression(ObjectCreationExpressionSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitAnonymousObjectMemberDeclarator(AnonymousObjectMemberDeclaratorSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitArrayCreationExpression(ArrayCreationExpressionSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitImplicitArrayCreationExpression(ImplicitArrayCreationExpressionSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitStackAllocArrayCreationExpression(StackAllocArrayCreationExpressionSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitImplicitStackAllocArrayCreationExpression(ImplicitStackAllocArrayCreationExpressionSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitQueryExpression(QueryExpressionSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitQueryBody(QueryBodySyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitFromClause(FromClauseSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitLetClause(LetClauseSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitJoinClause(JoinClauseSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitJoinIntoClause(JoinIntoClauseSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitWhereClause(WhereClauseSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitOrderByClause(OrderByClauseSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitOrdering(OrderingSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitSelectClause(SelectClauseSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitGroupClause(GroupClauseSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitQueryContinuation(QueryContinuationSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitOmittedArraySizeExpression(OmittedArraySizeExpressionSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitInterpolatedStringExpression(InterpolatedStringExpressionSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitIsPatternExpression(IsPatternExpressionSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitThrowExpression(ThrowExpressionSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitWhenClause(WhenClauseSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitDiscardPattern(DiscardPatternSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitDeclarationPattern(DeclarationPatternSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitVarPattern(VarPatternSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitRecursivePattern(RecursivePatternSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitPositionalPatternClause(PositionalPatternClauseSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitPropertyPatternClause(PropertyPatternClauseSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitSubpattern(SubpatternSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitConstantPattern(ConstantPatternSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitInterpolatedStringText(InterpolatedStringTextSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitInterpolation(InterpolationSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitInterpolationAlignmentClause(InterpolationAlignmentClauseSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitInterpolationFormatClause(InterpolationFormatClauseSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitGlobalStatement(GlobalStatementSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitBlock(BlockSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitLocalFunctionStatement(LocalFunctionStatementSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitVariableDeclaration(VariableDeclarationSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitVariableDeclarator(VariableDeclaratorSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitEqualsValueClause(EqualsValueClauseSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitSingleVariableDesignation(SingleVariableDesignationSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitDiscardDesignation(DiscardDesignationSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitParenthesizedVariableDesignation(ParenthesizedVariableDesignationSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitExpressionStatement(ExpressionStatementSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitEmptyStatement(EmptyStatementSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitLabeledStatement(LabeledStatementSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitGotoStatement(GotoStatementSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitBreakStatement(BreakStatementSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitContinueStatement(ContinueStatementSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitReturnStatement(ReturnStatementSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitThrowStatement(ThrowStatementSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitYieldStatement(YieldStatementSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitWhileStatement(WhileStatementSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitDoStatement(DoStatementSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitForStatement(ForStatementSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitForEachStatement(ForEachStatementSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitForEachVariableStatement(ForEachVariableStatementSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitUsingStatement(UsingStatementSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitFixedStatement(FixedStatementSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitCheckedStatement(CheckedStatementSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitUnsafeStatement(UnsafeStatementSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitLockStatement(LockStatementSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitIfStatement(IfStatementSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitElseClause(ElseClauseSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitSwitchStatement(SwitchStatementSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitSwitchSection(SwitchSectionSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitCasePatternSwitchLabel(CasePatternSwitchLabelSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitCaseSwitchLabel(CaseSwitchLabelSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitDefaultSwitchLabel(DefaultSwitchLabelSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitSwitchExpression(SwitchExpressionSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitSwitchExpressionArm(SwitchExpressionArmSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitTryStatement(TryStatementSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitCatchClause(CatchClauseSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitCatchDeclaration(CatchDeclarationSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitCatchFilterClause(CatchFilterClauseSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitFinallyClause(FinallyClauseSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitCompilationUnit(CompilationUnitSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitExternAliasDirective(ExternAliasDirectiveSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitUsingDirective(UsingDirectiveSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitAttributeList(AttributeListSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitAttributeTargetSpecifier(AttributeTargetSpecifierSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitAttribute(AttributeSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitAttributeArgumentList(AttributeArgumentListSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitAttributeArgument(AttributeArgumentSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitNameEquals(NameEqualsSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitTypeParameterList(TypeParameterListSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitTypeParameter(TypeParameterSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitClassDeclaration(ClassDeclarationSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitStructDeclaration(StructDeclarationSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitInterfaceDeclaration(InterfaceDeclarationSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitEnumDeclaration(EnumDeclarationSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitDelegateDeclaration(DelegateDeclarationSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitBaseList(BaseListSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitSimpleBaseType(SimpleBaseTypeSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitTypeParameterConstraintClause(TypeParameterConstraintClauseSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitConstructorConstraint(ConstructorConstraintSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitClassOrStructConstraint(ClassOrStructConstraintSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitTypeConstraint(TypeConstraintSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitFieldDeclaration(FieldDeclarationSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitEventFieldDeclaration(EventFieldDeclarationSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitMethodDeclaration(MethodDeclarationSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitOperatorDeclaration(OperatorDeclarationSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitConstructorDeclaration(ConstructorDeclarationSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitConstructorInitializer(ConstructorInitializerSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitDestructorDeclaration(DestructorDeclarationSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitPropertyDeclaration(PropertyDeclarationSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitArrowExpressionClause(ArrowExpressionClauseSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitEventDeclaration(EventDeclarationSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitIndexerDeclaration(IndexerDeclarationSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitAccessorList(AccessorListSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitAccessorDeclaration(AccessorDeclarationSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitParameterList(ParameterListSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitBracketedParameterList(BracketedParameterListSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitParameter(ParameterSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitIncompleteMember(IncompleteMemberSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitTypeCref(TypeCrefSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitQualifiedCref(QualifiedCrefSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitNameMemberCref(NameMemberCrefSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitIndexerMemberCref(IndexerMemberCrefSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitOperatorMemberCref(OperatorMemberCrefSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitConversionOperatorMemberCref(ConversionOperatorMemberCrefSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitCrefParameterList(CrefParameterListSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitCrefBracketedParameterList(CrefBracketedParameterListSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitCrefParameter(CrefParameterSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitIfDirectiveTrivia(IfDirectiveTriviaSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitElifDirectiveTrivia(ElifDirectiveTriviaSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitElseDirectiveTrivia(ElseDirectiveTriviaSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitEndIfDirectiveTrivia(EndIfDirectiveTriviaSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitRegionDirectiveTrivia(RegionDirectiveTriviaSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitEndRegionDirectiveTrivia(EndRegionDirectiveTriviaSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitErrorDirectiveTrivia(ErrorDirectiveTriviaSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitWarningDirectiveTrivia(WarningDirectiveTriviaSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitBadDirectiveTrivia(BadDirectiveTriviaSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitDefineDirectiveTrivia(DefineDirectiveTriviaSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitUndefDirectiveTrivia(UndefDirectiveTriviaSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitLineDirectiveTrivia(LineDirectiveTriviaSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitPragmaWarningDirectiveTrivia(PragmaWarningDirectiveTriviaSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitPragmaChecksumDirectiveTrivia(PragmaChecksumDirectiveTriviaSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitReferenceDirectiveTrivia(ReferenceDirectiveTriviaSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitLoadDirectiveTrivia(LoadDirectiveTriviaSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitShebangDirectiveTrivia(ShebangDirectiveTriviaSyntax node)
		{
			return this.DefaultVisit(node);
		}

		public virtual TResult VisitNullableDirectiveTrivia(NullableDirectiveTriviaSyntax node)
		{
			return this.DefaultVisit(node);
		}
	}


	public partial class LeeSyntaxVisitor
	{
		public virtual void VisitIdentifierName(IdentifierNameSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitQualifiedName(QualifiedNameSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitGenericName(GenericNameSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitTypeArgumentList(TypeArgumentListSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitAliasQualifiedName(AliasQualifiedNameSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitPredefinedType(PredefinedTypeSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitArrayType(ArrayTypeSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitPointerType(PointerTypeSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitNullableType(NullableTypeSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitTupleType(TupleTypeSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitTupleElement(TupleElementSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitOmittedTypeArgument(OmittedTypeArgumentSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitRefType(RefTypeSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitParenthesizedExpression(ParenthesizedExpressionSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitTupleExpression(TupleExpressionSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitPrefixUnaryExpression(PrefixUnaryExpressionSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitAwaitExpression(AwaitExpressionSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitPostfixUnaryExpression(PostfixUnaryExpressionSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitMemberAccessExpression(MemberAccessExpressionSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitConditionalAccessExpression(ConditionalAccessExpressionSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitMemberBindingExpression(MemberBindingExpressionSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitElementBindingExpression(ElementBindingExpressionSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitRangeExpression(RangeExpressionSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitImplicitElementAccess(ImplicitElementAccessSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitBinaryExpression(BinaryExpressionSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitAssignmentExpression(AssignmentExpressionSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitConditionalExpression(ConditionalExpressionSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitThisExpression(ThisExpressionSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitBaseExpression(BaseExpressionSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitLiteralExpression(LiteralExpressionSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitMakeRefExpression(MakeRefExpressionSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitRefTypeExpression(RefTypeExpressionSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitRefValueExpression(RefValueExpressionSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitCheckedExpression(CheckedExpressionSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitDefaultExpression(DefaultExpressionSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitTypeOfExpression(TypeOfExpressionSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitSizeOfExpression(SizeOfExpressionSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitInvocationExpression(InvocationExpressionSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitElementAccessExpression(ElementAccessExpressionSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitArgumentList(ArgumentListSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitBracketedArgumentList(BracketedArgumentListSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitArgument(ArgumentSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitNameColon(NameColonSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitDeclarationExpression(DeclarationExpressionSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitCastExpression(CastExpressionSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitAnonymousMethodExpression(AnonymousMethodExpressionSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitRefExpression(RefExpressionSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitInitializerExpression(InitializerExpressionSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitObjectCreationExpression(ObjectCreationExpressionSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitAnonymousObjectMemberDeclarator(AnonymousObjectMemberDeclaratorSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitArrayCreationExpression(ArrayCreationExpressionSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitImplicitArrayCreationExpression(ImplicitArrayCreationExpressionSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitStackAllocArrayCreationExpression(StackAllocArrayCreationExpressionSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitImplicitStackAllocArrayCreationExpression(ImplicitStackAllocArrayCreationExpressionSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitQueryExpression(QueryExpressionSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitQueryBody(QueryBodySyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitFromClause(FromClauseSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitLetClause(LetClauseSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitJoinClause(JoinClauseSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitJoinIntoClause(JoinIntoClauseSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitWhereClause(WhereClauseSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitOrderByClause(OrderByClauseSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitOrdering(OrderingSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitSelectClause(SelectClauseSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitGroupClause(GroupClauseSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitQueryContinuation(QueryContinuationSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitOmittedArraySizeExpression(OmittedArraySizeExpressionSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitInterpolatedStringExpression(InterpolatedStringExpressionSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitIsPatternExpression(IsPatternExpressionSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitThrowExpression(ThrowExpressionSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitWhenClause(WhenClauseSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitDiscardPattern(DiscardPatternSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitDeclarationPattern(DeclarationPatternSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitVarPattern(VarPatternSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitRecursivePattern(RecursivePatternSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitPositionalPatternClause(PositionalPatternClauseSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitPropertyPatternClause(PropertyPatternClauseSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitSubpattern(SubpatternSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitConstantPattern(ConstantPatternSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitInterpolatedStringText(InterpolatedStringTextSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitInterpolation(InterpolationSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitInterpolationAlignmentClause(InterpolationAlignmentClauseSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitInterpolationFormatClause(InterpolationFormatClauseSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitGlobalStatement(GlobalStatementSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitBlock(BlockSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitLocalFunctionStatement(LocalFunctionStatementSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitVariableDeclaration(VariableDeclarationSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitVariableDeclarator(VariableDeclaratorSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitEqualsValueClause(EqualsValueClauseSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitSingleVariableDesignation(SingleVariableDesignationSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitDiscardDesignation(DiscardDesignationSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitParenthesizedVariableDesignation(ParenthesizedVariableDesignationSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitExpressionStatement(ExpressionStatementSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitEmptyStatement(EmptyStatementSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitLabeledStatement(LabeledStatementSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitGotoStatement(GotoStatementSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitBreakStatement(BreakStatementSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitContinueStatement(ContinueStatementSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitReturnStatement(ReturnStatementSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitThrowStatement(ThrowStatementSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitYieldStatement(YieldStatementSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitWhileStatement(WhileStatementSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitDoStatement(DoStatementSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitForStatement(ForStatementSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitForEachStatement(ForEachStatementSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitForEachVariableStatement(ForEachVariableStatementSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitUsingStatement(UsingStatementSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitFixedStatement(FixedStatementSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitCheckedStatement(CheckedStatementSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitUnsafeStatement(UnsafeStatementSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitLockStatement(LockStatementSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitIfStatement(IfStatementSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitElseClause(ElseClauseSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitSwitchStatement(SwitchStatementSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitSwitchSection(SwitchSectionSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitCasePatternSwitchLabel(CasePatternSwitchLabelSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitCaseSwitchLabel(CaseSwitchLabelSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitDefaultSwitchLabel(DefaultSwitchLabelSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitSwitchExpression(SwitchExpressionSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitSwitchExpressionArm(SwitchExpressionArmSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitTryStatement(TryStatementSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitCatchClause(CatchClauseSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitCatchDeclaration(CatchDeclarationSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitCatchFilterClause(CatchFilterClauseSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitFinallyClause(FinallyClauseSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitCompilationUnit(CompilationUnitSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitExternAliasDirective(ExternAliasDirectiveSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitUsingDirective(UsingDirectiveSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitAttributeList(AttributeListSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitAttributeTargetSpecifier(AttributeTargetSpecifierSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitAttribute(AttributeSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitAttributeArgumentList(AttributeArgumentListSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitAttributeArgument(AttributeArgumentSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitNameEquals(NameEqualsSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitTypeParameterList(TypeParameterListSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitTypeParameter(TypeParameterSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitClassDeclaration(ClassDeclarationSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitStructDeclaration(StructDeclarationSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitInterfaceDeclaration(InterfaceDeclarationSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitEnumDeclaration(EnumDeclarationSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitDelegateDeclaration(DelegateDeclarationSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitBaseList(BaseListSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitSimpleBaseType(SimpleBaseTypeSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitTypeParameterConstraintClause(TypeParameterConstraintClauseSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitConstructorConstraint(ConstructorConstraintSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitClassOrStructConstraint(ClassOrStructConstraintSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitTypeConstraint(TypeConstraintSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitFieldDeclaration(FieldDeclarationSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitEventFieldDeclaration(EventFieldDeclarationSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitMethodDeclaration(MethodDeclarationSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitOperatorDeclaration(OperatorDeclarationSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitConstructorDeclaration(ConstructorDeclarationSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitConstructorInitializer(ConstructorInitializerSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitDestructorDeclaration(DestructorDeclarationSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitPropertyDeclaration(PropertyDeclarationSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitArrowExpressionClause(ArrowExpressionClauseSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitEventDeclaration(EventDeclarationSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitIndexerDeclaration(IndexerDeclarationSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitAccessorList(AccessorListSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitAccessorDeclaration(AccessorDeclarationSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitParameterList(ParameterListSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitBracketedParameterList(BracketedParameterListSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitParameter(ParameterSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitIncompleteMember(IncompleteMemberSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitTypeCref(TypeCrefSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitQualifiedCref(QualifiedCrefSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitNameMemberCref(NameMemberCrefSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitIndexerMemberCref(IndexerMemberCrefSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitOperatorMemberCref(OperatorMemberCrefSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitConversionOperatorMemberCref(ConversionOperatorMemberCrefSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitCrefParameterList(CrefParameterListSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitCrefBracketedParameterList(CrefBracketedParameterListSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitCrefParameter(CrefParameterSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitIfDirectiveTrivia(IfDirectiveTriviaSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitElifDirectiveTrivia(ElifDirectiveTriviaSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitElseDirectiveTrivia(ElseDirectiveTriviaSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitEndIfDirectiveTrivia(EndIfDirectiveTriviaSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitRegionDirectiveTrivia(RegionDirectiveTriviaSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitEndRegionDirectiveTrivia(EndRegionDirectiveTriviaSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitErrorDirectiveTrivia(ErrorDirectiveTriviaSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitWarningDirectiveTrivia(WarningDirectiveTriviaSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitBadDirectiveTrivia(BadDirectiveTriviaSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitDefineDirectiveTrivia(DefineDirectiveTriviaSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitUndefDirectiveTrivia(UndefDirectiveTriviaSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitLineDirectiveTrivia(LineDirectiveTriviaSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitPragmaWarningDirectiveTrivia(PragmaWarningDirectiveTriviaSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitPragmaChecksumDirectiveTrivia(PragmaChecksumDirectiveTriviaSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitReferenceDirectiveTrivia(ReferenceDirectiveTriviaSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitLoadDirectiveTrivia(LoadDirectiveTriviaSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitShebangDirectiveTrivia(ShebangDirectiveTriviaSyntax node)
		{
			this.DefaultVisit(node);
		}

		public virtual void VisitNullableDirectiveTrivia(NullableDirectiveTriviaSyntax node)
		{
			this.DefaultVisit(node);
		}
	}
	

	public partial class ContextAwareSyntax
	{
		private SyntaxFactoryContext context;


		public ContextAwareSyntax(SyntaxFactoryContext context)
		{
			this.context = context;
		}
		public IdentifierNameSyntax IdentifierName(SyntaxToken identifier)
		{
#if DEBUG
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
				case SyntaxKind.GlobalKeyword:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
#endif

			var result = new IdentifierNameSyntax(SyntaxKind.IdentifierName, identifier, this.context);

			return result;
		}

		public QualifiedNameSyntax QualifiedName(NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right)
		{
#if DEBUG
			if (left == null)
				throw new ArgumentNullException(nameof(left));
			if (dotToken == null)
				throw new ArgumentNullException(nameof(dotToken));
			switch (dotToken.Kind)
			{
				case SyntaxKind.DotToken:
					break;
				default:
					throw new ArgumentException(nameof(dotToken));
			}
			if (right == null)
				throw new ArgumentNullException(nameof(right));
#endif

			var result = new QualifiedNameSyntax(SyntaxKind.QualifiedName, left, dotToken, right, this.context);
			return result;
		}

		public GenericNameSyntax GenericName(SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList)
		{
#if DEBUG
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
			if (typeArgumentList == null)
				throw new ArgumentNullException(nameof(typeArgumentList));
#endif

			var result = new GenericNameSyntax(SyntaxKind.GenericName, identifier, typeArgumentList, this.context);

			return result;
		}

		public TypeArgumentListSyntax TypeArgumentList(SyntaxToken lessThanToken, SeparatedSyntaxList<TypeSyntax> arguments, SyntaxToken greaterThanToken)
		{
#if DEBUG
			if (lessThanToken == null)
				throw new ArgumentNullException(nameof(lessThanToken));
			switch (lessThanToken.Kind)
			{
				case SyntaxKind.LessThanToken:
					break;
				default:
					throw new ArgumentException(nameof(lessThanToken));
			}
			if (greaterThanToken == null)
				throw new ArgumentNullException(nameof(greaterThanToken));
			switch (greaterThanToken.Kind)
			{
				case SyntaxKind.GreaterThanToken:
					break;
				default:
					throw new ArgumentException(nameof(greaterThanToken));
			}
#endif

			var result = new TypeArgumentListSyntax(SyntaxKind.TypeArgumentList, lessThanToken, arguments.Node, greaterThanToken, this.context);

			return result;
		}

		public AliasQualifiedNameSyntax AliasQualifiedName(IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name)
		{
#if DEBUG
			if (alias == null)
				throw new ArgumentNullException(nameof(alias));
			if (colonColonToken == null)
				throw new ArgumentNullException(nameof(colonColonToken));
			switch (colonColonToken.Kind)
			{
				case SyntaxKind.ColonColonToken:
					break;
				default:
					throw new ArgumentException(nameof(colonColonToken));
			}
			if (name == null)
				throw new ArgumentNullException(nameof(name));
#endif

			var result = new AliasQualifiedNameSyntax(SyntaxKind.AliasQualifiedName, alias, colonColonToken, name, this.context);

			return result;
		}

		public PredefinedTypeSyntax PredefinedType(SyntaxToken keyword)
		{
#if DEBUG
			if (keyword == null)
				throw new ArgumentNullException(nameof(keyword));
			switch (keyword.Kind)
			{
				case SyntaxKind.BoolKeyword:
				case SyntaxKind.ByteKeyword:
				case SyntaxKind.SByteKeyword:
				case SyntaxKind.IntKeyword:
				case SyntaxKind.UIntKeyword:
				case SyntaxKind.ShortKeyword:
				case SyntaxKind.UShortKeyword:
				case SyntaxKind.LongKeyword:
				case SyntaxKind.ULongKeyword:
				case SyntaxKind.FloatKeyword:
				case SyntaxKind.DoubleKeyword:
				case SyntaxKind.DecimalKeyword:
				case SyntaxKind.StringKeyword:
				case SyntaxKind.CharKeyword:
				case SyntaxKind.ObjectKeyword:
				case SyntaxKind.VoidKeyword:
					break;
				default:
					throw new ArgumentException(nameof(keyword));
			}
#endif

			var result = new PredefinedTypeSyntax(SyntaxKind.PredefinedType, keyword, this.context);

			return result;
		}

		public ArrayTypeSyntax ArrayType(TypeSyntax elementType, SyntaxList<ArrayRankSpecifierSyntax> rankSpecifiers)
		{
#if DEBUG
			if (elementType == null)
				throw new ArgumentNullException(nameof(elementType));
#endif

			var result = new ArrayTypeSyntax(SyntaxKind.ArrayType, elementType, rankSpecifiers.Node, this.context);

			return result;
		}

		public ArrayRankSpecifierSyntax ArrayRankSpecifier(SyntaxToken openBracketToken, SeparatedSyntaxList<ExpressionSyntax> sizes, SyntaxToken closeBracketToken)
		{
#if DEBUG
			if (openBracketToken == null)
				throw new ArgumentNullException(nameof(openBracketToken));
			switch (openBracketToken.Kind)
			{
				case SyntaxKind.OpenBracketToken:
					break;
				default:
					throw new ArgumentException(nameof(openBracketToken));
			}
			if (closeBracketToken == null)
				throw new ArgumentNullException(nameof(closeBracketToken));
			switch (closeBracketToken.Kind)
			{
				case SyntaxKind.CloseBracketToken:
					break;
				default:
					throw new ArgumentException(nameof(closeBracketToken));
			}
#endif

			var result = new ArrayRankSpecifierSyntax(SyntaxKind.ArrayRankSpecifier, openBracketToken, sizes.Node, closeBracketToken, this.context);
			return result;
		}

		public PointerTypeSyntax PointerType(TypeSyntax elementType, SyntaxToken asteriskToken)
		{
#if DEBUG
			if (elementType == null)
				throw new ArgumentNullException(nameof(elementType));
			if (asteriskToken == null)
				throw new ArgumentNullException(nameof(asteriskToken));
			switch (asteriskToken.Kind)
			{
				case SyntaxKind.AsteriskToken:
					break;
				default:
					throw new ArgumentException(nameof(asteriskToken));
			}
#endif

			var result = new PointerTypeSyntax(SyntaxKind.PointerType, elementType, asteriskToken, this.context);

			return result;
		}

		public NullableTypeSyntax NullableType(TypeSyntax elementType, SyntaxToken questionToken)
		{
#if DEBUG
			if (elementType == null)
				throw new ArgumentNullException(nameof(elementType));
			if (questionToken == null)
				throw new ArgumentNullException(nameof(questionToken));
			switch (questionToken.Kind)
			{
				case SyntaxKind.QuestionToken:
					break;
				default:
					throw new ArgumentException(nameof(questionToken));
			}
#endif

			var result = new NullableTypeSyntax(SyntaxKind.NullableType, elementType, questionToken, this.context);

			return result;
		}

		public TupleTypeSyntax TupleType(SyntaxToken openParenToken, SeparatedSyntaxList<TupleElementSyntax> elements, SyntaxToken closeParenToken)
		{
#if DEBUG
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
#endif

			var result = new TupleTypeSyntax(SyntaxKind.TupleType, openParenToken, elements.Node, closeParenToken, this.context);

			return result;
		}

		public TupleElementSyntax TupleElement(TypeSyntax type, SyntaxToken identifier)
		{
#if DEBUG
			if (type == null)
				throw new ArgumentNullException(nameof(type));
			if (identifier != null)
			{
				switch (identifier.Kind)
				{
					case SyntaxKind.IdentifierToken:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(identifier));
				}
			}
#endif

			var result = new TupleElementSyntax(SyntaxKind.TupleElement, type, identifier, this.context);

			return result;
		}

		public OmittedTypeArgumentSyntax OmittedTypeArgument(SyntaxToken omittedTypeArgumentToken)
		{
#if DEBUG
			if (omittedTypeArgumentToken == null)
				throw new ArgumentNullException(nameof(omittedTypeArgumentToken));
			switch (omittedTypeArgumentToken.Kind)
			{
				case SyntaxKind.OmittedTypeArgumentToken:
					break;
				default:
					throw new ArgumentException(nameof(omittedTypeArgumentToken));
			}
#endif

			var result = new OmittedTypeArgumentSyntax(SyntaxKind.OmittedTypeArgument, omittedTypeArgumentToken, this.context);

			return result;
		}

		public RefTypeSyntax RefType(SyntaxToken refKeyword, SyntaxToken readOnlyKeyword, TypeSyntax type)
		{
#if DEBUG
			if (refKeyword == null)
				throw new ArgumentNullException(nameof(refKeyword));
			switch (refKeyword.Kind)
			{
				case SyntaxKind.RefKeyword:
					break;
				default:
					throw new ArgumentException(nameof(refKeyword));
			}
			if (readOnlyKeyword != null)
			{
				switch (readOnlyKeyword.Kind)
				{
					case SyntaxKind.ReadOnlyKeyword:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(readOnlyKeyword));
				}
			}
			if (type == null)
				throw new ArgumentNullException(nameof(type));
#endif

			var result = new RefTypeSyntax(SyntaxKind.RefType, refKeyword, readOnlyKeyword, type, this.context);
			return result;
		}

		public ParenthesizedExpressionSyntax ParenthesizedExpression(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
		{
#if DEBUG
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
#endif

			var result = new ParenthesizedExpressionSyntax(SyntaxKind.ParenthesizedExpression, openParenToken, expression, closeParenToken, this.context);

			return result;
		}

		public TupleExpressionSyntax TupleExpression(SyntaxToken openParenToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
		{
#if DEBUG
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
#endif

			var result = new TupleExpressionSyntax(SyntaxKind.TupleExpression, openParenToken, arguments.Node, closeParenToken, this.context);

			return result;
		}

		public PrefixUnaryExpressionSyntax PrefixUnaryExpression(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand)
		{
			switch (kind)
			{
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.BitwiseNotExpression:
				case SyntaxKind.LogicalNotExpression:
				case SyntaxKind.PreIncrementExpression:
				case SyntaxKind.PreDecrementExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.PointerIndirectionExpression:
				case SyntaxKind.IndexExpression:
					break;
				default:
					throw new ArgumentException(nameof(kind));
			}
#if DEBUG
			if (operatorToken == null)
				throw new ArgumentNullException(nameof(operatorToken));
			switch (operatorToken.Kind)
			{
				case SyntaxKind.PlusToken:
				case SyntaxKind.MinusToken:
				case SyntaxKind.TildeToken:
				case SyntaxKind.ExclamationToken:
				case SyntaxKind.PlusPlusToken:
				case SyntaxKind.MinusMinusToken:
				case SyntaxKind.AmpersandToken:
				case SyntaxKind.AsteriskToken:
				case SyntaxKind.CaretToken:
					break;
				default:
					throw new ArgumentException(nameof(operatorToken));
			}
			if (operand == null)
				throw new ArgumentNullException(nameof(operand));
#endif

			var result = new PrefixUnaryExpressionSyntax(kind, operatorToken, operand, this.context);

			return result;
		}

		public AwaitExpressionSyntax AwaitExpression(SyntaxToken awaitKeyword, ExpressionSyntax expression)
		{
#if DEBUG
			if (awaitKeyword == null)
				throw new ArgumentNullException(nameof(awaitKeyword));
			switch (awaitKeyword.Kind)
			{
				case SyntaxKind.AwaitKeyword:
					break;
				default:
					throw new ArgumentException(nameof(awaitKeyword));
			}
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
#endif

			var result = new AwaitExpressionSyntax(SyntaxKind.AwaitExpression, awaitKeyword, expression, this.context);

			return result;
		}

		public PostfixUnaryExpressionSyntax PostfixUnaryExpression(SyntaxKind kind, ExpressionSyntax operand, SyntaxToken operatorToken)
		{
			switch (kind)
			{
				case SyntaxKind.PostIncrementExpression:
				case SyntaxKind.PostDecrementExpression:
				case SyntaxKind.SuppressNullableWarningExpression:
					break;
				default:
					throw new ArgumentException(nameof(kind));
			}
#if DEBUG
			if (operand == null)
				throw new ArgumentNullException(nameof(operand));
			if (operatorToken == null)
				throw new ArgumentNullException(nameof(operatorToken));
			switch (operatorToken.Kind)
			{
				case SyntaxKind.PlusPlusToken:
				case SyntaxKind.MinusMinusToken:
				case SyntaxKind.ExclamationToken:
					break;
				default:
					throw new ArgumentException(nameof(operatorToken));
			}
#endif

			var result = new PostfixUnaryExpressionSyntax(kind, operand, operatorToken, this.context);
			return result;
		}

		public MemberAccessExpressionSyntax MemberAccessExpression(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name)
		{
			switch (kind)
			{
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.PointerMemberAccessExpression:
					break;
				default:
					throw new ArgumentException(nameof(kind));
			}
#if DEBUG
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
			if (operatorToken == null)
				throw new ArgumentNullException(nameof(operatorToken));
			switch (operatorToken.Kind)
			{
				case SyntaxKind.DotToken:
				case SyntaxKind.MinusGreaterThanToken:
					break;
				default:
					throw new ArgumentException(nameof(operatorToken));
			}
			if (name == null)
				throw new ArgumentNullException(nameof(name));
#endif

			var result = new MemberAccessExpressionSyntax(kind, expression, operatorToken, name, this.context);

			return result;
		}

		public ConditionalAccessExpressionSyntax ConditionalAccessExpression(ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull)
		{
#if DEBUG
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
			if (operatorToken == null)
				throw new ArgumentNullException(nameof(operatorToken));
			switch (operatorToken.Kind)
			{
				case SyntaxKind.QuestionToken:
					break;
				default:
					throw new ArgumentException(nameof(operatorToken));
			}
			if (whenNotNull == null)
				throw new ArgumentNullException(nameof(whenNotNull));
#endif

			var result = new ConditionalAccessExpressionSyntax(SyntaxKind.ConditionalAccessExpression, expression, operatorToken, whenNotNull, this.context);

			return result;
		}

		public MemberBindingExpressionSyntax MemberBindingExpression(SyntaxToken operatorToken, SimpleNameSyntax name)
		{
#if DEBUG
			if (operatorToken == null)
				throw new ArgumentNullException(nameof(operatorToken));
			switch (operatorToken.Kind)
			{
				case SyntaxKind.DotToken:
					break;
				default:
					throw new ArgumentException(nameof(operatorToken));
			}
			if (name == null)
				throw new ArgumentNullException(nameof(name));
#endif

			var result = new MemberBindingExpressionSyntax(SyntaxKind.MemberBindingExpression, operatorToken, name, this.context);

			return result;
		}

		public ElementBindingExpressionSyntax ElementBindingExpression(BracketedArgumentListSyntax argumentList)
		{
#if DEBUG
			if (argumentList == null)
				throw new ArgumentNullException(nameof(argumentList));
#endif

			var result = new ElementBindingExpressionSyntax(SyntaxKind.ElementBindingExpression, argumentList, this.context);
			return result;
		}

		public RangeExpressionSyntax RangeExpression(ExpressionSyntax leftOperand, SyntaxToken operatorToken, ExpressionSyntax rightOperand)
		{
#if DEBUG
			if (operatorToken == null)
				throw new ArgumentNullException(nameof(operatorToken));
			switch (operatorToken.Kind)
			{
				case SyntaxKind.DotDotToken:
					break;
				default:
					throw new ArgumentException(nameof(operatorToken));
			}
#endif
			var result = new RangeExpressionSyntax(SyntaxKind.RangeExpression, leftOperand, operatorToken, rightOperand, this.context);

			return result;
		}

		public ImplicitElementAccessSyntax ImplicitElementAccess(BracketedArgumentListSyntax argumentList)
		{
#if DEBUG
			if (argumentList == null)
				throw new ArgumentNullException(nameof(argumentList));
#endif
			var result = new ImplicitElementAccessSyntax(SyntaxKind.ImplicitElementAccess, argumentList, this.context);
			return result;
		}

		public BinaryExpressionSyntax BinaryExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
		{
			switch (kind)
			{
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.LogicalOrExpression:
				case SyntaxKind.LogicalAndExpression:
				case SyntaxKind.BitwiseOrExpression:
				case SyntaxKind.BitwiseAndExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.AsExpression:
				case SyntaxKind.CoalesceExpression:
					break;
				default:
					throw new ArgumentException(nameof(kind));
			}
#if DEBUG
			if (left == null)
				throw new ArgumentNullException(nameof(left));
			if (operatorToken == null)
				throw new ArgumentNullException(nameof(operatorToken));
			switch (operatorToken.Kind)
			{
				case SyntaxKind.PlusToken:
				case SyntaxKind.MinusToken:
				case SyntaxKind.AsteriskToken:
				case SyntaxKind.SlashToken:
				case SyntaxKind.PercentToken:
				case SyntaxKind.LessThanLessThanToken:
				case SyntaxKind.GreaterThanGreaterThanToken:
				case SyntaxKind.BarBarToken:
				case SyntaxKind.AmpersandAmpersandToken:
				case SyntaxKind.BarToken:
				case SyntaxKind.AmpersandToken:
				case SyntaxKind.CaretToken:
				case SyntaxKind.EqualsEqualsToken:
				case SyntaxKind.ExclamationEqualsToken:
				case SyntaxKind.LessThanToken:
				case SyntaxKind.LessThanEqualsToken:
				case SyntaxKind.GreaterThanToken:
				case SyntaxKind.GreaterThanEqualsToken:
				case SyntaxKind.IsKeyword:
				case SyntaxKind.AsKeyword:
				case SyntaxKind.QuestionQuestionToken:
					break;
				default:
					throw new ArgumentException(nameof(operatorToken));
			}
			if (right == null)
				throw new ArgumentNullException(nameof(right));
#endif

			var result = new BinaryExpressionSyntax(kind, left, operatorToken, right, this.context);

			return result;
		}

		public AssignmentExpressionSyntax AssignmentExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
		{
			switch (kind)
			{
				case SyntaxKind.SimpleAssignmentExpression:
				case SyntaxKind.AddAssignmentExpression:
				case SyntaxKind.SubtractAssignmentExpression:
				case SyntaxKind.MultiplyAssignmentExpression:
				case SyntaxKind.DivideAssignmentExpression:
				case SyntaxKind.ModuloAssignmentExpression:
				case SyntaxKind.AndAssignmentExpression:
				case SyntaxKind.ExclusiveOrAssignmentExpression:
				case SyntaxKind.OrAssignmentExpression:
				case SyntaxKind.LeftShiftAssignmentExpression:
				case SyntaxKind.RightShiftAssignmentExpression:
				case SyntaxKind.CoalesceAssignmentExpression:
					break;
				default:
					throw new ArgumentException(nameof(kind));
			}
#if DEBUG
			if (left == null)
				throw new ArgumentNullException(nameof(left));
			if (operatorToken == null)
				throw new ArgumentNullException(nameof(operatorToken));
			switch (operatorToken.Kind)
			{
				case SyntaxKind.EqualsToken:
				case SyntaxKind.PlusEqualsToken:
				case SyntaxKind.MinusEqualsToken:
				case SyntaxKind.AsteriskEqualsToken:
				case SyntaxKind.SlashEqualsToken:
				case SyntaxKind.PercentEqualsToken:
				case SyntaxKind.AmpersandEqualsToken:
				case SyntaxKind.CaretEqualsToken:
				case SyntaxKind.BarEqualsToken:
				case SyntaxKind.LessThanLessThanEqualsToken:
				case SyntaxKind.GreaterThanGreaterThanEqualsToken:
				case SyntaxKind.QuestionQuestionEqualsToken:
					break;
				default:
					throw new ArgumentException(nameof(operatorToken));
			}
			if (right == null)
				throw new ArgumentNullException(nameof(right));
#endif

			var result = new AssignmentExpressionSyntax(kind, left, operatorToken, right, this.context);
			return result;
		}

		public ConditionalExpressionSyntax ConditionalExpression(ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse)
		{
#if DEBUG
			if (condition == null)
				throw new ArgumentNullException(nameof(condition));
			if (questionToken == null)
				throw new ArgumentNullException(nameof(questionToken));
			switch (questionToken.Kind)
			{
				case SyntaxKind.QuestionToken:
					break;
				default:
					throw new ArgumentException(nameof(questionToken));
			}
			if (whenTrue == null)
				throw new ArgumentNullException(nameof(whenTrue));
			if (colonToken == null)
				throw new ArgumentNullException(nameof(colonToken));
			switch (colonToken.Kind)
			{
				case SyntaxKind.ColonToken:
					break;
				default:
					throw new ArgumentException(nameof(colonToken));
			}
			if (whenFalse == null)
				throw new ArgumentNullException(nameof(whenFalse));
#endif

			return new ConditionalExpressionSyntax(SyntaxKind.ConditionalExpression, condition, questionToken, whenTrue, colonToken, whenFalse, this.context);
		}

		public ThisExpressionSyntax ThisExpression(SyntaxToken token)
		{
#if DEBUG
			if (token == null)
				throw new ArgumentNullException(nameof(token));
			switch (token.Kind)
			{
				case SyntaxKind.ThisKeyword:
					break;
				default:
					throw new ArgumentException(nameof(token));
			}
#endif

			var result = new ThisExpressionSyntax(SyntaxKind.ThisExpression, token, this.context);

			return result;
		}

		public BaseExpressionSyntax BaseExpression(SyntaxToken token)
		{
#if DEBUG
			if (token == null)
				throw new ArgumentNullException(nameof(token));
			switch (token.Kind)
			{
				case SyntaxKind.BaseKeyword:
					break;
				default:
					throw new ArgumentException(nameof(token));
			}
#endif

			var result = new BaseExpressionSyntax(SyntaxKind.BaseExpression, token, this.context);
			return result;
		}

		public LiteralExpressionSyntax LiteralExpression(SyntaxKind kind, SyntaxToken token)
		{
			switch (kind)
			{
				case SyntaxKind.ArgListExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NullLiteralExpression:
				case SyntaxKind.DefaultLiteralExpression:
					break;
				default:
					throw new ArgumentException(nameof(kind));
			}
#if DEBUG
			if (token == null)
				throw new ArgumentNullException(nameof(token));
			switch (token.Kind)
			{
				case SyntaxKind.ArgListKeyword:
				case SyntaxKind.NumericLiteralToken:
				case SyntaxKind.StringLiteralToken:
				case SyntaxKind.CharacterLiteralToken:
				case SyntaxKind.TrueKeyword:
				case SyntaxKind.FalseKeyword:
				case SyntaxKind.NullKeyword:
				case SyntaxKind.DefaultKeyword:
					break;
				default:
					throw new ArgumentException(nameof(token));
			}
#endif

			var result = new LiteralExpressionSyntax(kind, token, this.context);
			return result;
		}

		public MakeRefExpressionSyntax MakeRefExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
		{
#if DEBUG
			if (keyword == null)
				throw new ArgumentNullException(nameof(keyword));
			switch (keyword.Kind)
			{
				case SyntaxKind.MakeRefKeyword:
					break;
				default:
					throw new ArgumentException(nameof(keyword));
			}
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
#endif

			return new MakeRefExpressionSyntax(SyntaxKind.MakeRefExpression, keyword, openParenToken, expression, closeParenToken, this.context);
		}

		public RefTypeExpressionSyntax RefTypeExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
		{
#if DEBUG
			if (keyword == null)
				throw new ArgumentNullException(nameof(keyword));
			switch (keyword.Kind)
			{
				case SyntaxKind.RefTypeKeyword:
					break;
				default:
					throw new ArgumentException(nameof(keyword));
			}
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
#endif

			return new RefTypeExpressionSyntax(SyntaxKind.RefTypeExpression, keyword, openParenToken, expression, closeParenToken, this.context);
		}

		public RefValueExpressionSyntax RefValueExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken)
		{
#if DEBUG
			if (keyword == null)
				throw new ArgumentNullException(nameof(keyword));
			switch (keyword.Kind)
			{
				case SyntaxKind.RefValueKeyword:
					break;
				default:
					throw new ArgumentException(nameof(keyword));
			}
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
			if (comma == null)
				throw new ArgumentNullException(nameof(comma));
			switch (comma.Kind)
			{
				case SyntaxKind.CommaToken:
					break;
				default:
					throw new ArgumentException(nameof(comma));
			}
			if (type == null)
				throw new ArgumentNullException(nameof(type));
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
#endif

			return new RefValueExpressionSyntax(SyntaxKind.RefValueExpression, keyword, openParenToken, expression, comma, type, closeParenToken, this.context);
		}

		public CheckedExpressionSyntax CheckedExpression(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
		{
			switch (kind)
			{
				case SyntaxKind.CheckedExpression:
				case SyntaxKind.UncheckedExpression:
					break;
				default:
					throw new ArgumentException(nameof(kind));
			}
#if DEBUG
			if (keyword == null)
				throw new ArgumentNullException(nameof(keyword));
			switch (keyword.Kind)
			{
				case SyntaxKind.CheckedKeyword:
				case SyntaxKind.UncheckedKeyword:
					break;
				default:
					throw new ArgumentException(nameof(keyword));
			}
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
#endif

			return new CheckedExpressionSyntax(kind, keyword, openParenToken, expression, closeParenToken, this.context);
		}

		public DefaultExpressionSyntax DefaultExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
		{
#if DEBUG
			if (keyword == null)
				throw new ArgumentNullException(nameof(keyword));
			switch (keyword.Kind)
			{
				case SyntaxKind.DefaultKeyword:
					break;
				default:
					throw new ArgumentException(nameof(keyword));
			}
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (type == null)
				throw new ArgumentNullException(nameof(type));
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
#endif

			return new DefaultExpressionSyntax(SyntaxKind.DefaultExpression, keyword, openParenToken, type, closeParenToken, this.context);
		}

		public TypeOfExpressionSyntax TypeOfExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
		{
#if DEBUG
			if (keyword == null)
				throw new ArgumentNullException(nameof(keyword));
			switch (keyword.Kind)
			{
				case SyntaxKind.TypeOfKeyword:
					break;
				default:
					throw new ArgumentException(nameof(keyword));
			}
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (type == null)
				throw new ArgumentNullException(nameof(type));
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
#endif

			return new TypeOfExpressionSyntax(SyntaxKind.TypeOfExpression, keyword, openParenToken, type, closeParenToken, this.context);
		}

		public SizeOfExpressionSyntax SizeOfExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
		{
#if DEBUG
			if (keyword == null)
				throw new ArgumentNullException(nameof(keyword));
			switch (keyword.Kind)
			{
				case SyntaxKind.SizeOfKeyword:
					break;
				default:
					throw new ArgumentException(nameof(keyword));
			}
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (type == null)
				throw new ArgumentNullException(nameof(type));
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
#endif

			return new SizeOfExpressionSyntax(SyntaxKind.SizeOfExpression, keyword, openParenToken, type, closeParenToken, this.context);
		}

		public InvocationExpressionSyntax InvocationExpression(ExpressionSyntax expression, ArgumentListSyntax argumentList)
		{
#if DEBUG
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
			if (argumentList == null)
				throw new ArgumentNullException(nameof(argumentList));
#endif

			var result = new InvocationExpressionSyntax(SyntaxKind.InvocationExpression, expression, argumentList, this.context);

			return result;
		}

		public ElementAccessExpressionSyntax ElementAccessExpression(ExpressionSyntax expression, BracketedArgumentListSyntax argumentList)
		{
#if DEBUG
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
			if (argumentList == null)
				throw new ArgumentNullException(nameof(argumentList));
#endif
			var result = new ElementAccessExpressionSyntax(SyntaxKind.ElementAccessExpression, expression, argumentList, this.context);
			return result;
		}

		public ArgumentListSyntax ArgumentList(SyntaxToken openParenToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
		{
#if DEBUG
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
#endif

			var result = new ArgumentListSyntax(SyntaxKind.ArgumentList, openParenToken, arguments.Node, closeParenToken, this.context);
			return result;
		}

		public BracketedArgumentListSyntax BracketedArgumentList(SyntaxToken openBracketToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeBracketToken)
		{
#if DEBUG
			if (openBracketToken == null)
				throw new ArgumentNullException(nameof(openBracketToken));
			switch (openBracketToken.Kind)
			{
				case SyntaxKind.OpenBracketToken:
					break;
				default:
					throw new ArgumentException(nameof(openBracketToken));
			}
			if (closeBracketToken == null)
				throw new ArgumentNullException(nameof(closeBracketToken));
			switch (closeBracketToken.Kind)
			{
				case SyntaxKind.CloseBracketToken:
					break;
				default:
					throw new ArgumentException(nameof(closeBracketToken));
			}
#endif

			var result = new BracketedArgumentListSyntax(SyntaxKind.BracketedArgumentList, openBracketToken, arguments.Node, closeBracketToken, this.context);
			return result;
		}

		public ArgumentSyntax Argument(NameColonSyntax nameColon, SyntaxToken refKindKeyword, ExpressionSyntax expression)
		{
#if DEBUG
			if (refKindKeyword != null)
			{
				switch (refKindKeyword.Kind)
				{
					case SyntaxKind.RefKeyword:
					case SyntaxKind.OutKeyword:
					case SyntaxKind.InKeyword:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(refKindKeyword));
				}
			}
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
#endif

			var result = new ArgumentSyntax(SyntaxKind.Argument, nameColon, refKindKeyword, expression, this.context);

			return result;
		}

		public NameColonSyntax NameColon(IdentifierNameSyntax name, SyntaxToken colonToken)
		{
#if DEBUG
			if (name == null)
				throw new ArgumentNullException(nameof(name));
			if (colonToken == null)
				throw new ArgumentNullException(nameof(colonToken));
			switch (colonToken.Kind)
			{
				case SyntaxKind.ColonToken:
					break;
				default:
					throw new ArgumentException(nameof(colonToken));
			}
#endif

			var result = new NameColonSyntax(SyntaxKind.NameColon, name, colonToken, this.context);

			return result;
		}

		public DeclarationExpressionSyntax DeclarationExpression(TypeSyntax type, VariableDesignationSyntax designation)
		{
#if DEBUG
			if (type == null)
				throw new ArgumentNullException(nameof(type));
			if (designation == null)
				throw new ArgumentNullException(nameof(designation));
#endif
			var result = new DeclarationExpressionSyntax(SyntaxKind.DeclarationExpression, type, designation, this.context);
			return result;
		}

		public CastExpressionSyntax CastExpression(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression)
		{
#if DEBUG
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (type == null)
				throw new ArgumentNullException(nameof(type));
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
#endif

			return new CastExpressionSyntax(SyntaxKind.CastExpression, openParenToken, type, closeParenToken, expression, this.context);
		}

		public AnonymousMethodExpressionSyntax AnonymousMethodExpression(SyntaxToken asyncKeyword, SyntaxToken delegateKeyword, ParameterListSyntax parameterList, LeeSyntaxNode body)
		{
#if DEBUG
			if (asyncKeyword != null)
			{
				switch (asyncKeyword.Kind)
				{
					case SyntaxKind.AsyncKeyword:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(asyncKeyword));
				}
			}
			if (delegateKeyword == null)
				throw new ArgumentNullException(nameof(delegateKeyword));
			switch (delegateKeyword.Kind)
			{
				case SyntaxKind.DelegateKeyword:
					break;
				default:
					throw new ArgumentException(nameof(delegateKeyword));
			}
			if (body == null)
				throw new ArgumentNullException(nameof(body));
#endif

			return new AnonymousMethodExpressionSyntax(SyntaxKind.AnonymousMethodExpression, asyncKeyword, delegateKeyword, parameterList, body, this.context);
		}

		public SimpleLambdaExpressionSyntax SimpleLambdaExpression(SyntaxToken asyncKeyword, ParameterSyntax parameter, SyntaxToken arrowToken, LeeSyntaxNode body)
		{
#if DEBUG
			if (asyncKeyword != null)
			{
				switch (asyncKeyword.Kind)
				{
					case SyntaxKind.AsyncKeyword:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(asyncKeyword));
				}
			}
			if (parameter == null)
				throw new ArgumentNullException(nameof(parameter));
			if (arrowToken == null)
				throw new ArgumentNullException(nameof(arrowToken));
			switch (arrowToken.Kind)
			{
				case SyntaxKind.EqualsGreaterThanToken:
					break;
				default:
					throw new ArgumentException(nameof(arrowToken));
			}
			if (body == null)
				throw new ArgumentNullException(nameof(body));
#endif

			return new SimpleLambdaExpressionSyntax(SyntaxKind.SimpleLambdaExpression, asyncKeyword, parameter, arrowToken, body, this.context);
		}

		public RefExpressionSyntax RefExpression(SyntaxToken refKeyword, ExpressionSyntax expression)
		{
#if DEBUG
			if (refKeyword == null)
				throw new ArgumentNullException(nameof(refKeyword));
			switch (refKeyword.Kind)
			{
				case SyntaxKind.RefKeyword:
					break;
				default:
					throw new ArgumentException(nameof(refKeyword));
			}
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
#endif

			var result = new RefExpressionSyntax(SyntaxKind.RefExpression, refKeyword, expression, this.context);

			return result;
		}

		public ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(SyntaxToken asyncKeyword, ParameterListSyntax parameterList, SyntaxToken arrowToken, LeeSyntaxNode body)
		{
#if DEBUG
			if (asyncKeyword != null)
			{
				switch (asyncKeyword.Kind)
				{
					case SyntaxKind.AsyncKeyword:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(asyncKeyword));
				}
			}
			if (parameterList == null)
				throw new ArgumentNullException(nameof(parameterList));
			if (arrowToken == null)
				throw new ArgumentNullException(nameof(arrowToken));
			switch (arrowToken.Kind)
			{
				case SyntaxKind.EqualsGreaterThanToken:
					break;
				default:
					throw new ArgumentException(nameof(arrowToken));
			}
			if (body == null)
				throw new ArgumentNullException(nameof(body));
#endif

			return new ParenthesizedLambdaExpressionSyntax(SyntaxKind.ParenthesizedLambdaExpression, asyncKeyword, parameterList, arrowToken, body, this.context);
		}

		public InitializerExpressionSyntax InitializerExpression(SyntaxKind kind, SyntaxToken openBraceToken, SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken closeBraceToken)
		{
			switch (kind)
			{
				case SyntaxKind.ObjectInitializerExpression:
				case SyntaxKind.CollectionInitializerExpression:
				case SyntaxKind.ArrayInitializerExpression:
				case SyntaxKind.ComplexElementInitializerExpression:
					break;
				default:
					throw new ArgumentException(nameof(kind));
			}
#if DEBUG
			if (openBraceToken == null)
				throw new ArgumentNullException(nameof(openBraceToken));
			switch (openBraceToken.Kind)
			{
				case SyntaxKind.OpenBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(openBraceToken));
			}
			if (closeBraceToken == null)
				throw new ArgumentNullException(nameof(closeBraceToken));
			switch (closeBraceToken.Kind)
			{
				case SyntaxKind.CloseBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(closeBraceToken));
			}
#endif

			var result = new InitializerExpressionSyntax(kind, openBraceToken, expressions.Node, closeBraceToken, this.context);
			return result;
		}

		public ObjectCreationExpressionSyntax ObjectCreationExpression(SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer)
		{
#if DEBUG
			if (newKeyword == null)
				throw new ArgumentNullException(nameof(newKeyword));
			switch (newKeyword.Kind)
			{
				case SyntaxKind.NewKeyword:
					break;
				default:
					throw new ArgumentException(nameof(newKeyword));
			}
			if (type == null)
				throw new ArgumentNullException(nameof(type));
#endif

			return new ObjectCreationExpressionSyntax(SyntaxKind.ObjectCreationExpression, newKeyword, type, argumentList, initializer, this.context);
		}

		public AnonymousObjectMemberDeclaratorSyntax AnonymousObjectMemberDeclarator(NameEqualsSyntax nameEquals, ExpressionSyntax expression)
		{
#if DEBUG
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
#endif

			var result = new AnonymousObjectMemberDeclaratorSyntax(SyntaxKind.AnonymousObjectMemberDeclarator, nameEquals, expression, this.context);

			return result;
		}

		public AnonymousObjectCreationExpressionSyntax AnonymousObjectCreationExpression(SyntaxToken newKeyword, SyntaxToken openBraceToken, SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> initializers, SyntaxToken closeBraceToken)
		{
#if DEBUG
			if (newKeyword == null)
				throw new ArgumentNullException(nameof(newKeyword));
			switch (newKeyword.Kind)
			{
				case SyntaxKind.NewKeyword:
					break;
				default:
					throw new ArgumentException(nameof(newKeyword));
			}
			if (openBraceToken == null)
				throw new ArgumentNullException(nameof(openBraceToken));
			switch (openBraceToken.Kind)
			{
				case SyntaxKind.OpenBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(openBraceToken));
			}
			if (closeBraceToken == null)
				throw new ArgumentNullException(nameof(closeBraceToken));
			switch (closeBraceToken.Kind)
			{
				case SyntaxKind.CloseBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(closeBraceToken));
			}
#endif

			return new AnonymousObjectCreationExpressionSyntax(SyntaxKind.AnonymousObjectCreationExpression, newKeyword, openBraceToken, initializers.Node, closeBraceToken, this.context);
		}

		public ArrayCreationExpressionSyntax ArrayCreationExpression(SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax initializer)
		{
#if DEBUG
			if (newKeyword == null)
				throw new ArgumentNullException(nameof(newKeyword));
			switch (newKeyword.Kind)
			{
				case SyntaxKind.NewKeyword:
					break;
				default:
					throw new ArgumentException(nameof(newKeyword));
			}
			if (type == null)
				throw new ArgumentNullException(nameof(type));
#endif

			var result = new ArrayCreationExpressionSyntax(SyntaxKind.ArrayCreationExpression, newKeyword, type, initializer, this.context);
			return result;
		}

		public ImplicitArrayCreationExpressionSyntax ImplicitArrayCreationExpression(SyntaxToken newKeyword, SyntaxToken openBracketToken, SyntaxList<SyntaxToken> commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer)
		{
#if DEBUG
			if (newKeyword == null)
				throw new ArgumentNullException(nameof(newKeyword));
			switch (newKeyword.Kind)
			{
				case SyntaxKind.NewKeyword:
					break;
				default:
					throw new ArgumentException(nameof(newKeyword));
			}
			if (openBracketToken == null)
				throw new ArgumentNullException(nameof(openBracketToken));
			switch (openBracketToken.Kind)
			{
				case SyntaxKind.OpenBracketToken:
					break;
				default:
					throw new ArgumentException(nameof(openBracketToken));
			}
			if (closeBracketToken == null)
				throw new ArgumentNullException(nameof(closeBracketToken));
			switch (closeBracketToken.Kind)
			{
				case SyntaxKind.CloseBracketToken:
					break;
				default:
					throw new ArgumentException(nameof(closeBracketToken));
			}
			if (initializer == null)
				throw new ArgumentNullException(nameof(initializer));
#endif

			return new ImplicitArrayCreationExpressionSyntax(SyntaxKind.ImplicitArrayCreationExpression, newKeyword, openBracketToken, commas.Node, closeBracketToken, initializer, this.context);
		}

		public StackAllocArrayCreationExpressionSyntax StackAllocArrayCreationExpression(SyntaxToken stackAllocKeyword, TypeSyntax type, InitializerExpressionSyntax initializer)
		{
#if DEBUG
			if (stackAllocKeyword == null)
				throw new ArgumentNullException(nameof(stackAllocKeyword));
			switch (stackAllocKeyword.Kind)
			{
				case SyntaxKind.StackAllocKeyword:
					break;
				default:
					throw new ArgumentException(nameof(stackAllocKeyword));
			}
			if (type == null)
				throw new ArgumentNullException(nameof(type));
#endif

			var result = new StackAllocArrayCreationExpressionSyntax(SyntaxKind.StackAllocArrayCreationExpression, stackAllocKeyword, type, initializer, this.context);
			return result;
		}

		public ImplicitStackAllocArrayCreationExpressionSyntax ImplicitStackAllocArrayCreationExpression(SyntaxToken stackAllocKeyword, SyntaxToken openBracketToken, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer)
		{
#if DEBUG
			if (stackAllocKeyword == null)
				throw new ArgumentNullException(nameof(stackAllocKeyword));
			switch (stackAllocKeyword.Kind)
			{
				case SyntaxKind.StackAllocKeyword:
					break;
				default:
					throw new ArgumentException(nameof(stackAllocKeyword));
			}
			if (openBracketToken == null)
				throw new ArgumentNullException(nameof(openBracketToken));
			switch (openBracketToken.Kind)
			{
				case SyntaxKind.OpenBracketToken:
					break;
				default:
					throw new ArgumentException(nameof(openBracketToken));
			}
			if (closeBracketToken == null)
				throw new ArgumentNullException(nameof(closeBracketToken));
			switch (closeBracketToken.Kind)
			{
				case SyntaxKind.CloseBracketToken:
					break;
				default:
					throw new ArgumentException(nameof(closeBracketToken));
			}
			if (initializer == null)
				throw new ArgumentNullException(nameof(initializer));
#endif

			return new ImplicitStackAllocArrayCreationExpressionSyntax(SyntaxKind.ImplicitStackAllocArrayCreationExpression, stackAllocKeyword, openBracketToken, closeBracketToken, initializer, this.context);
		}

		public QueryExpressionSyntax QueryExpression(FromClauseSyntax fromClause, QueryBodySyntax body)
		{
#if DEBUG
			if (fromClause == null)
				throw new ArgumentNullException(nameof(fromClause));
			if (body == null)
				throw new ArgumentNullException(nameof(body));
#endif
			var result = new QueryExpressionSyntax(SyntaxKind.QueryExpression, fromClause, body, this.context);
			return result;
		}

		public QueryBodySyntax QueryBody(SyntaxList<QueryClauseSyntax> clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax continuation)
		{
#if DEBUG
			if (selectOrGroup == null)
				throw new ArgumentNullException(nameof(selectOrGroup));
#endif
			var result = new QueryBodySyntax(SyntaxKind.QueryBody, clauses.Node, selectOrGroup, continuation, this.context);

			return result;
		}

		public FromClauseSyntax FromClause(SyntaxToken fromKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression)
		{
#if DEBUG
			if (fromKeyword == null)
				throw new ArgumentNullException(nameof(fromKeyword));
			switch (fromKeyword.Kind)
			{
				case SyntaxKind.FromKeyword:
					break;
				default:
					throw new ArgumentException(nameof(fromKeyword));
			}
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
			if (inKeyword == null)
				throw new ArgumentNullException(nameof(inKeyword));
			switch (inKeyword.Kind)
			{
				case SyntaxKind.InKeyword:
					break;
				default:
					throw new ArgumentException(nameof(inKeyword));
			}
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
#endif

			return new FromClauseSyntax(SyntaxKind.FromClause, fromKeyword, type, identifier, inKeyword, expression, this.context);
		}

		public LetClauseSyntax LetClause(SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression)
		{
#if DEBUG
			if (letKeyword == null)
				throw new ArgumentNullException(nameof(letKeyword));
			switch (letKeyword.Kind)
			{
				case SyntaxKind.LetKeyword:
					break;
				default:
					throw new ArgumentException(nameof(letKeyword));
			}
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
			if (equalsToken == null)
				throw new ArgumentNullException(nameof(equalsToken));
			switch (equalsToken.Kind)
			{
				case SyntaxKind.EqualsToken:
					break;
				default:
					throw new ArgumentException(nameof(equalsToken));
			}
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
#endif

			return new LetClauseSyntax(SyntaxKind.LetClause, letKeyword, identifier, equalsToken, expression, this.context);
		}

		public JoinClauseSyntax JoinClause(SyntaxToken joinKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into)
		{
#if DEBUG
			if (joinKeyword == null)
				throw new ArgumentNullException(nameof(joinKeyword));
			switch (joinKeyword.Kind)
			{
				case SyntaxKind.JoinKeyword:
					break;
				default:
					throw new ArgumentException(nameof(joinKeyword));
			}
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
			if (inKeyword == null)
				throw new ArgumentNullException(nameof(inKeyword));
			switch (inKeyword.Kind)
			{
				case SyntaxKind.InKeyword:
					break;
				default:
					throw new ArgumentException(nameof(inKeyword));
			}
			if (inExpression == null)
				throw new ArgumentNullException(nameof(inExpression));
			if (onKeyword == null)
				throw new ArgumentNullException(nameof(onKeyword));
			switch (onKeyword.Kind)
			{
				case SyntaxKind.OnKeyword:
					break;
				default:
					throw new ArgumentException(nameof(onKeyword));
			}
			if (leftExpression == null)
				throw new ArgumentNullException(nameof(leftExpression));
			if (equalsKeyword == null)
				throw new ArgumentNullException(nameof(equalsKeyword));
			switch (equalsKeyword.Kind)
			{
				case SyntaxKind.EqualsKeyword:
					break;
				default:
					throw new ArgumentException(nameof(equalsKeyword));
			}
			if (rightExpression == null)
				throw new ArgumentNullException(nameof(rightExpression));
#endif

			return new JoinClauseSyntax(SyntaxKind.JoinClause, joinKeyword, type, identifier, inKeyword, inExpression, onKeyword, leftExpression, equalsKeyword, rightExpression, into, this.context);
		}

		public JoinIntoClauseSyntax JoinIntoClause(SyntaxToken intoKeyword, SyntaxToken identifier)
		{
#if DEBUG
			if (intoKeyword == null)
				throw new ArgumentNullException(nameof(intoKeyword));
			switch (intoKeyword.Kind)
			{
				case SyntaxKind.IntoKeyword:
					break;
				default:
					throw new ArgumentException(nameof(intoKeyword));
			}
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
#endif

			var result = new JoinIntoClauseSyntax(SyntaxKind.JoinIntoClause, intoKeyword, identifier, this.context);

			return result;
		}

		public WhereClauseSyntax WhereClause(SyntaxToken whereKeyword, ExpressionSyntax condition)
		{
#if DEBUG
			if (whereKeyword == null)
				throw new ArgumentNullException(nameof(whereKeyword));
			switch (whereKeyword.Kind)
			{
				case SyntaxKind.WhereKeyword:
					break;
				default:
					throw new ArgumentException(nameof(whereKeyword));
			}
			if (condition == null)
				throw new ArgumentNullException(nameof(condition));
#endif

			var result = new WhereClauseSyntax(SyntaxKind.WhereClause, whereKeyword, condition, this.context);

			return result;
		}

		public OrderByClauseSyntax OrderByClause(SyntaxToken orderByKeyword, SeparatedSyntaxList<OrderingSyntax> orderings)
		{
#if DEBUG
			if (orderByKeyword == null)
				throw new ArgumentNullException(nameof(orderByKeyword));
			switch (orderByKeyword.Kind)
			{
				case SyntaxKind.OrderByKeyword:
					break;
				default:
					throw new ArgumentException(nameof(orderByKeyword));
			}
#endif

			var result = new OrderByClauseSyntax(SyntaxKind.OrderByClause, orderByKeyword, orderings.Node, this.context);
			return result;
		}

		public OrderingSyntax Ordering(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword)
		{
			switch (kind)
			{
				case SyntaxKind.AscendingOrdering:
				case SyntaxKind.DescendingOrdering:
					break;
				default:
					throw new ArgumentException(nameof(kind));
			}
#if DEBUG
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
			if (ascendingOrDescendingKeyword != null)
			{
				switch (ascendingOrDescendingKeyword.Kind)
				{
					case SyntaxKind.AscendingKeyword:
					case SyntaxKind.DescendingKeyword:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(ascendingOrDescendingKeyword));
				}
			}
#endif

			var result = new OrderingSyntax(kind, expression, ascendingOrDescendingKeyword, this.context);
			return result;
		}

		public SelectClauseSyntax SelectClause(SyntaxToken selectKeyword, ExpressionSyntax expression)
		{
#if DEBUG
			if (selectKeyword == null)
				throw new ArgumentNullException(nameof(selectKeyword));
			switch (selectKeyword.Kind)
			{
				case SyntaxKind.SelectKeyword:
					break;
				default:
					throw new ArgumentException(nameof(selectKeyword));
			}
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
#endif
			var result = new SelectClauseSyntax(SyntaxKind.SelectClause, selectKeyword, expression, this.context);

			return result;
		}

		public GroupClauseSyntax GroupClause(SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression)
		{
#if DEBUG
			if (groupKeyword == null)
				throw new ArgumentNullException(nameof(groupKeyword));
			switch (groupKeyword.Kind)
			{
				case SyntaxKind.GroupKeyword:
					break;
				default:
					throw new ArgumentException(nameof(groupKeyword));
			}
			if (groupExpression == null)
				throw new ArgumentNullException(nameof(groupExpression));
			if (byKeyword == null)
				throw new ArgumentNullException(nameof(byKeyword));
			switch (byKeyword.Kind)
			{
				case SyntaxKind.ByKeyword:
					break;
				default:
					throw new ArgumentException(nameof(byKeyword));
			}
			if (byExpression == null)
				throw new ArgumentNullException(nameof(byExpression));
#endif

			return new GroupClauseSyntax(SyntaxKind.GroupClause, groupKeyword, groupExpression, byKeyword, byExpression, this.context);
		}

		public QueryContinuationSyntax QueryContinuation(SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body)
		{
#if DEBUG
			if (intoKeyword == null)
				throw new ArgumentNullException(nameof(intoKeyword));
			switch (intoKeyword.Kind)
			{
				case SyntaxKind.IntoKeyword:
					break;
				default:
					throw new ArgumentException(nameof(intoKeyword));
			}
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
			if (body == null)
				throw new ArgumentNullException(nameof(body));
#endif

			var result = new QueryContinuationSyntax(SyntaxKind.QueryContinuation, intoKeyword, identifier, body, this.context);
			return result;
		}

		public OmittedArraySizeExpressionSyntax OmittedArraySizeExpression(SyntaxToken omittedArraySizeExpressionToken)
		{
#if DEBUG
			if (omittedArraySizeExpressionToken == null)
				throw new ArgumentNullException(nameof(omittedArraySizeExpressionToken));
			switch (omittedArraySizeExpressionToken.Kind)
			{
				case SyntaxKind.OmittedArraySizeExpressionToken:
					break;
				default:
					throw new ArgumentException(nameof(omittedArraySizeExpressionToken));
			}
#endif

			var result = new OmittedArraySizeExpressionSyntax(SyntaxKind.OmittedArraySizeExpression, omittedArraySizeExpressionToken, this.context);
			return result;
		}

		public InterpolatedStringExpressionSyntax InterpolatedStringExpression(SyntaxToken stringStartToken, SyntaxList<InterpolatedStringContentSyntax> contents, SyntaxToken stringEndToken)
		{
#if DEBUG
			if (stringStartToken == null)
				throw new ArgumentNullException(nameof(stringStartToken));
			switch (stringStartToken.Kind)
			{
				case SyntaxKind.InterpolatedStringStartToken:
				case SyntaxKind.InterpolatedVerbatimStringStartToken:
					break;
				default:
					throw new ArgumentException(nameof(stringStartToken));
			}
			if (stringEndToken == null)
				throw new ArgumentNullException(nameof(stringEndToken));
			switch (stringEndToken.Kind)
			{
				case SyntaxKind.InterpolatedStringEndToken:
					break;
				default:
					throw new ArgumentException(nameof(stringEndToken));
			}
#endif

			var result = new InterpolatedStringExpressionSyntax(SyntaxKind.InterpolatedStringExpression, stringStartToken, contents.Node, stringEndToken, this.context);

			return result;
		}

		public IsPatternExpressionSyntax IsPatternExpression(ExpressionSyntax expression, SyntaxToken isKeyword, PatternSyntax pattern)
		{
#if DEBUG
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
			if (isKeyword == null)
				throw new ArgumentNullException(nameof(isKeyword));
			switch (isKeyword.Kind)
			{
				case SyntaxKind.IsKeyword:
					break;
				default:
					throw new ArgumentException(nameof(isKeyword));
			}
			if (pattern == null)
				throw new ArgumentNullException(nameof(pattern));
#endif

			var result = new IsPatternExpressionSyntax(SyntaxKind.IsPatternExpression, expression, isKeyword, pattern, this.context);
			return result;
		}

		public ThrowExpressionSyntax ThrowExpression(SyntaxToken throwKeyword, ExpressionSyntax expression)
		{
#if DEBUG
			if (throwKeyword == null)
				throw new ArgumentNullException(nameof(throwKeyword));
			switch (throwKeyword.Kind)
			{
				case SyntaxKind.ThrowKeyword:
					break;
				default:
					throw new ArgumentException(nameof(throwKeyword));
			}
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
#endif

			var result = new ThrowExpressionSyntax(SyntaxKind.ThrowExpression, throwKeyword, expression, this.context);

			return result;
		}

		public WhenClauseSyntax WhenClause(SyntaxToken whenKeyword, ExpressionSyntax condition)
		{
#if DEBUG
			if (whenKeyword == null)
				throw new ArgumentNullException(nameof(whenKeyword));
			switch (whenKeyword.Kind)
			{
				case SyntaxKind.WhenKeyword:
					break;
				default:
					throw new ArgumentException(nameof(whenKeyword));
			}
			if (condition == null)
				throw new ArgumentNullException(nameof(condition));
#endif
			var result = new WhenClauseSyntax(SyntaxKind.WhenClause, whenKeyword, condition, this.context);

			return result;
		}

		public DiscardPatternSyntax DiscardPattern(SyntaxToken underscoreToken)
		{
#if DEBUG
			if (underscoreToken == null)
				throw new ArgumentNullException(nameof(underscoreToken));
			switch (underscoreToken.Kind)
			{
				case SyntaxKind.UnderscoreToken:
					break;
				default:
					throw new ArgumentException(nameof(underscoreToken));
			}
#endif
			var result = new DiscardPatternSyntax(SyntaxKind.DiscardPattern, underscoreToken, this.context);
			return result;
		}

		public DeclarationPatternSyntax DeclarationPattern(TypeSyntax type, VariableDesignationSyntax designation)
		{
#if DEBUG
			if (type == null)
				throw new ArgumentNullException(nameof(type));
			if (designation == null)
				throw new ArgumentNullException(nameof(designation));
#endif
			var result = new DeclarationPatternSyntax(SyntaxKind.DeclarationPattern, type, designation, this.context);
			return result;
		}

		public VarPatternSyntax VarPattern(SyntaxToken varKeyword, VariableDesignationSyntax designation)
		{
#if DEBUG
			if (varKeyword == null)
				throw new ArgumentNullException(nameof(varKeyword));
			switch (varKeyword.Kind)
			{
				case SyntaxKind.VarKeyword:
					break;
				default:
					throw new ArgumentException(nameof(varKeyword));
			}
			if (designation == null)
				throw new ArgumentNullException(nameof(designation));
#endif
			var result = new VarPatternSyntax(SyntaxKind.VarPattern, varKeyword, designation, this.context);
			return result;
		}

		public RecursivePatternSyntax RecursivePattern(TypeSyntax type, PositionalPatternClauseSyntax positionalPatternClause, PropertyPatternClauseSyntax propertyPatternClause, VariableDesignationSyntax designation)
		{
#if DEBUG
#endif

			return new RecursivePatternSyntax(SyntaxKind.RecursivePattern, type, positionalPatternClause, propertyPatternClause, designation, this.context);
		}

		public PositionalPatternClauseSyntax PositionalPatternClause(SyntaxToken openParenToken, SeparatedSyntaxList<SubpatternSyntax> subpatterns, SyntaxToken closeParenToken)
		{
#if DEBUG
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
#endif
			var result = new PositionalPatternClauseSyntax(SyntaxKind.PositionalPatternClause, openParenToken, subpatterns.Node, closeParenToken, this.context);
			return result;
		}

		public PropertyPatternClauseSyntax PropertyPatternClause(SyntaxToken openBraceToken, SeparatedSyntaxList<SubpatternSyntax> subpatterns, SyntaxToken closeBraceToken)
		{
#if DEBUG
			if (openBraceToken == null)
				throw new ArgumentNullException(nameof(openBraceToken));
			switch (openBraceToken.Kind)
			{
				case SyntaxKind.OpenBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(openBraceToken));
			}
			if (closeBraceToken == null)
				throw new ArgumentNullException(nameof(closeBraceToken));
			switch (closeBraceToken.Kind)
			{
				case SyntaxKind.CloseBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(closeBraceToken));
			}
#endif

			var result = new PropertyPatternClauseSyntax(SyntaxKind.PropertyPatternClause, openBraceToken, subpatterns.Node, closeBraceToken, this.context);
			return result;
		}

		public SubpatternSyntax Subpattern(NameColonSyntax nameColon, PatternSyntax pattern)
		{
#if DEBUG
			if (pattern == null)
				throw new ArgumentNullException(nameof(pattern));
#endif

			var result = new SubpatternSyntax(SyntaxKind.Subpattern, nameColon, pattern, this.context);
			return result;
		}

		public ConstantPatternSyntax ConstantPattern(ExpressionSyntax expression)
		{
#if DEBUG
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
#endif
			var result = new ConstantPatternSyntax(SyntaxKind.ConstantPattern, expression, this.context);

			return result;
		}

		public InterpolatedStringTextSyntax InterpolatedStringText(SyntaxToken textToken)
		{
#if DEBUG
			if (textToken == null)
				throw new ArgumentNullException(nameof(textToken));
			switch (textToken.Kind)
			{
				case SyntaxKind.InterpolatedStringTextToken:
					break;
				default:
					throw new ArgumentException(nameof(textToken));
			}
#endif

			var result = new InterpolatedStringTextSyntax(SyntaxKind.InterpolatedStringText, textToken, this.context);

			return result;
		}

		public InterpolationSyntax Interpolation(SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, SyntaxToken closeBraceToken)
		{
#if DEBUG
			if (openBraceToken == null)
				throw new ArgumentNullException(nameof(openBraceToken));
			switch (openBraceToken.Kind)
			{
				case SyntaxKind.OpenBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(openBraceToken));
			}
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
			if (closeBraceToken == null)
				throw new ArgumentNullException(nameof(closeBraceToken));
			switch (closeBraceToken.Kind)
			{
				case SyntaxKind.CloseBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(closeBraceToken));
			}
#endif

			return new InterpolationSyntax(SyntaxKind.Interpolation, openBraceToken, expression, alignmentClause, formatClause, closeBraceToken, this.context);
		}

		public InterpolationAlignmentClauseSyntax InterpolationAlignmentClause(SyntaxToken commaToken, ExpressionSyntax value)
		{
#if DEBUG
			if (commaToken == null)
				throw new ArgumentNullException(nameof(commaToken));
			if (value == null)
				throw new ArgumentNullException(nameof(value));
#endif

			var result = new InterpolationAlignmentClauseSyntax(SyntaxKind.InterpolationAlignmentClause, commaToken, value, this.context);

			return result;
		}

		public InterpolationFormatClauseSyntax InterpolationFormatClause(SyntaxToken colonToken, SyntaxToken formatStringToken)
		{
#if DEBUG
			if (colonToken == null)
				throw new ArgumentNullException(nameof(colonToken));
			if (formatStringToken == null)
				throw new ArgumentNullException(nameof(formatStringToken));
			switch (formatStringToken.Kind)
			{
				case SyntaxKind.InterpolatedStringTextToken:
					break;
				default:
					throw new ArgumentException(nameof(formatStringToken));
			}
#endif
			var result = new InterpolationFormatClauseSyntax(SyntaxKind.InterpolationFormatClause, colonToken, formatStringToken, this.context);

			return result;
		}

		public GlobalStatementSyntax GlobalStatement(StatementSyntax statement)
		{
#if DEBUG
			if (statement == null)
				throw new ArgumentNullException(nameof(statement));
#endif

			var result = new GlobalStatementSyntax(SyntaxKind.GlobalStatement, statement, this.context);
			return result;
		}

		public BlockSyntax Block(SyntaxToken openBraceToken, SyntaxList<StatementSyntax> statements, SyntaxToken closeBraceToken)
		{
#if DEBUG
			if (openBraceToken == null)
				throw new ArgumentNullException(nameof(openBraceToken));
			switch (openBraceToken.Kind)
			{
				case SyntaxKind.OpenBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(openBraceToken));
			}
			if (closeBraceToken == null)
				throw new ArgumentNullException(nameof(closeBraceToken));
			switch (closeBraceToken.Kind)
			{
				case SyntaxKind.CloseBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(closeBraceToken));
			}
#endif
			var result = new BlockSyntax(SyntaxKind.Block, openBraceToken, statements.Node, closeBraceToken, this.context);

			return result;
		}

		public LocalFunctionStatementSyntax LocalFunctionStatement(SyntaxList<SyntaxToken> modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (returnType == null)
				throw new ArgumentNullException(nameof(returnType));
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
			if (parameterList == null)
				throw new ArgumentNullException(nameof(parameterList));
			if (semicolonToken != null)
			{
				switch (semicolonToken.Kind)
				{
					case SyntaxKind.SemicolonToken:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(semicolonToken));
				}
			}
#endif

			return new LocalFunctionStatementSyntax(SyntaxKind.LocalFunctionStatement, modifiers.Node, returnType, identifier, typeParameterList, parameterList, constraintClauses.Node, body, expressionBody, semicolonToken, this.context);
		}

		public LocalDeclarationStatementSyntax LocalDeclarationStatement(SyntaxToken awaitKeyword, SyntaxToken usingKeyword, SyntaxList<SyntaxToken> modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (awaitKeyword != null)
			{
				switch (awaitKeyword.Kind)
				{
					case SyntaxKind.AwaitKeyword:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(awaitKeyword));
				}
			}
			if (usingKeyword != null)
			{
				switch (usingKeyword.Kind)
				{
					case SyntaxKind.UsingKeyword:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(usingKeyword));
				}
			}
			if (declaration == null)
				throw new ArgumentNullException(nameof(declaration));
			if (semicolonToken == null)
				throw new ArgumentNullException(nameof(semicolonToken));
			switch (semicolonToken.Kind)
			{
				case SyntaxKind.SemicolonToken:
					break;
				default:
					throw new ArgumentException(nameof(semicolonToken));
			}
#endif

			return new LocalDeclarationStatementSyntax(SyntaxKind.LocalDeclarationStatement, awaitKeyword, usingKeyword, modifiers.Node, declaration, semicolonToken, this.context);
		}

		public VariableDeclarationSyntax VariableDeclaration(TypeSyntax type, SeparatedSyntaxList<VariableDeclaratorSyntax> variables)
		{
#if DEBUG
			if (type == null)
				throw new ArgumentNullException(nameof(type));
#endif
			var result = new VariableDeclarationSyntax(SyntaxKind.VariableDeclaration, type, variables.Node, this.context);

			return result;
		}

		public VariableDeclaratorSyntax VariableDeclarator(SyntaxToken identifier, BracketedArgumentListSyntax argumentList, EqualsValueClauseSyntax initializer)
		{
#if DEBUG
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
#endif

			var result = new VariableDeclaratorSyntax(SyntaxKind.VariableDeclarator, identifier, argumentList, initializer, this.context);

			return result;
		}

		public EqualsValueClauseSyntax EqualsValueClause(SyntaxToken equalsToken, ExpressionSyntax value)
		{
#if DEBUG
			if (equalsToken == null)
				throw new ArgumentNullException(nameof(equalsToken));
			switch (equalsToken.Kind)
			{
				case SyntaxKind.EqualsToken:
					break;
				default:
					throw new ArgumentException(nameof(equalsToken));
			}
			if (value == null)
				throw new ArgumentNullException(nameof(value));
#endif
			var result = new EqualsValueClauseSyntax(SyntaxKind.EqualsValueClause, equalsToken, value, this.context);

			return result;
		}

		public SingleVariableDesignationSyntax SingleVariableDesignation(SyntaxToken identifier)
		{
#if DEBUG
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
#endif

			var result = new SingleVariableDesignationSyntax(SyntaxKind.SingleVariableDesignation, identifier, this.context);
			return result;
		}

		public DiscardDesignationSyntax DiscardDesignation(SyntaxToken underscoreToken)
		{
#if DEBUG
			if (underscoreToken == null)
				throw new ArgumentNullException(nameof(underscoreToken));
			switch (underscoreToken.Kind)
			{
				case SyntaxKind.UnderscoreToken:
					break;
				default:
					throw new ArgumentException(nameof(underscoreToken));
			}
#endif

			var result = new DiscardDesignationSyntax(SyntaxKind.DiscardDesignation, underscoreToken, this.context);

			return result;
		}

		public ParenthesizedVariableDesignationSyntax ParenthesizedVariableDesignation(SyntaxToken openParenToken, SeparatedSyntaxList<VariableDesignationSyntax> variables, SyntaxToken closeParenToken)
		{
#if DEBUG
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
#endif

			var result = new ParenthesizedVariableDesignationSyntax(SyntaxKind.ParenthesizedVariableDesignation, openParenToken, variables.Node, closeParenToken, this.context);
			return result;
		}

		public ExpressionStatementSyntax ExpressionStatement(ExpressionSyntax expression, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
			if (semicolonToken == null)
				throw new ArgumentNullException(nameof(semicolonToken));
			switch (semicolonToken.Kind)
			{
				case SyntaxKind.SemicolonToken:
					break;
				default:
					throw new ArgumentException(nameof(semicolonToken));
			}
#endif

			var result = new ExpressionStatementSyntax(SyntaxKind.ExpressionStatement, expression, semicolonToken, this.context);
			return result;
		}

		public EmptyStatementSyntax EmptyStatement(SyntaxToken semicolonToken)
		{
#if DEBUG
			if (semicolonToken == null)
				throw new ArgumentNullException(nameof(semicolonToken));
			switch (semicolonToken.Kind)
			{
				case SyntaxKind.SemicolonToken:
					break;
				default:
					throw new ArgumentException(nameof(semicolonToken));
			}
#endif

			var result = new EmptyStatementSyntax(SyntaxKind.EmptyStatement, semicolonToken, this.context);
			return result;
		}

		public LabeledStatementSyntax LabeledStatement(SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement)
		{
#if DEBUG
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
			if (colonToken == null)
				throw new ArgumentNullException(nameof(colonToken));
			switch (colonToken.Kind)
			{
				case SyntaxKind.ColonToken:
					break;
				default:
					throw new ArgumentException(nameof(colonToken));
			}
			if (statement == null)
				throw new ArgumentNullException(nameof(statement));
#endif

			var result = new LabeledStatementSyntax(SyntaxKind.LabeledStatement, identifier, colonToken, statement, this.context);

			return result;
		}

		public GotoStatementSyntax GotoStatement(SyntaxKind kind, SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
		{
			switch (kind)
			{
				case SyntaxKind.GotoStatement:
				case SyntaxKind.GotoCaseStatement:
				case SyntaxKind.GotoDefaultStatement:
					break;
				default:
					throw new ArgumentException(nameof(kind));
			}
#if DEBUG
			if (gotoKeyword == null)
				throw new ArgumentNullException(nameof(gotoKeyword));
			switch (gotoKeyword.Kind)
			{
				case SyntaxKind.GotoKeyword:
					break;
				default:
					throw new ArgumentException(nameof(gotoKeyword));
			}
			if (caseOrDefaultKeyword != null)
			{
				switch (caseOrDefaultKeyword.Kind)
				{
					case SyntaxKind.CaseKeyword:
					case SyntaxKind.DefaultKeyword:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(caseOrDefaultKeyword));
				}
			}
			if (semicolonToken == null)
				throw new ArgumentNullException(nameof(semicolonToken));
			switch (semicolonToken.Kind)
			{
				case SyntaxKind.SemicolonToken:
					break;
				default:
					throw new ArgumentException(nameof(semicolonToken));
			}
#endif

			return new GotoStatementSyntax(kind, gotoKeyword, caseOrDefaultKeyword, expression, semicolonToken, this.context);
		}

		public BreakStatementSyntax BreakStatement(SyntaxToken breakKeyword, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (breakKeyword == null)
				throw new ArgumentNullException(nameof(breakKeyword));
			switch (breakKeyword.Kind)
			{
				case SyntaxKind.BreakKeyword:
					break;
				default:
					throw new ArgumentException(nameof(breakKeyword));
			}
			if (semicolonToken == null)
				throw new ArgumentNullException(nameof(semicolonToken));
			switch (semicolonToken.Kind)
			{
				case SyntaxKind.SemicolonToken:
					break;
				default:
					throw new ArgumentException(nameof(semicolonToken));
			}
#endif

			var result = new BreakStatementSyntax(SyntaxKind.BreakStatement, breakKeyword, semicolonToken, this.context);
			return result;
		}

		public ContinueStatementSyntax ContinueStatement(SyntaxToken continueKeyword, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (continueKeyword == null)
				throw new ArgumentNullException(nameof(continueKeyword));
			switch (continueKeyword.Kind)
			{
				case SyntaxKind.ContinueKeyword:
					break;
				default:
					throw new ArgumentException(nameof(continueKeyword));
			}
			if (semicolonToken == null)
				throw new ArgumentNullException(nameof(semicolonToken));
			switch (semicolonToken.Kind)
			{
				case SyntaxKind.SemicolonToken:
					break;
				default:
					throw new ArgumentException(nameof(semicolonToken));
			}
#endif
			var result = new ContinueStatementSyntax(SyntaxKind.ContinueStatement, continueKeyword, semicolonToken, this.context);
			return result;
		}

		public ReturnStatementSyntax ReturnStatement(SyntaxToken returnKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (returnKeyword == null)
				throw new ArgumentNullException(nameof(returnKeyword));
			switch (returnKeyword.Kind)
			{
				case SyntaxKind.ReturnKeyword:
					break;
				default:
					throw new ArgumentException(nameof(returnKeyword));
			}
			if (semicolonToken == null)
				throw new ArgumentNullException(nameof(semicolonToken));
			switch (semicolonToken.Kind)
			{
				case SyntaxKind.SemicolonToken:
					break;
				default:
					throw new ArgumentException(nameof(semicolonToken));
			}
#endif
			var result = new ReturnStatementSyntax(SyntaxKind.ReturnStatement, returnKeyword, expression, semicolonToken, this.context);

			return result;
		}

		public ThrowStatementSyntax ThrowStatement(SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (throwKeyword == null)
				throw new ArgumentNullException(nameof(throwKeyword));
			switch (throwKeyword.Kind)
			{
				case SyntaxKind.ThrowKeyword:
					break;
				default:
					throw new ArgumentException(nameof(throwKeyword));
			}
			if (semicolonToken == null)
				throw new ArgumentNullException(nameof(semicolonToken));
			switch (semicolonToken.Kind)
			{
				case SyntaxKind.SemicolonToken:
					break;
				default:
					throw new ArgumentException(nameof(semicolonToken));
			}
#endif

			var result = new ThrowStatementSyntax(SyntaxKind.ThrowStatement, throwKeyword, expression, semicolonToken, this.context);

			return result;
		}

		public YieldStatementSyntax YieldStatement(SyntaxKind kind, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
		{
			switch (kind)
			{
				case SyntaxKind.YieldReturnStatement:
				case SyntaxKind.YieldBreakStatement:
					break;
				default:
					throw new ArgumentException(nameof(kind));
			}
#if DEBUG
			if (yieldKeyword == null)
				throw new ArgumentNullException(nameof(yieldKeyword));
			switch (yieldKeyword.Kind)
			{
				case SyntaxKind.YieldKeyword:
					break;
				default:
					throw new ArgumentException(nameof(yieldKeyword));
			}
			if (returnOrBreakKeyword == null)
				throw new ArgumentNullException(nameof(returnOrBreakKeyword));
			switch (returnOrBreakKeyword.Kind)
			{
				case SyntaxKind.ReturnKeyword:
				case SyntaxKind.BreakKeyword:
					break;
				default:
					throw new ArgumentException(nameof(returnOrBreakKeyword));
			}
			if (semicolonToken == null)
				throw new ArgumentNullException(nameof(semicolonToken));
			switch (semicolonToken.Kind)
			{
				case SyntaxKind.SemicolonToken:
					break;
				default:
					throw new ArgumentException(nameof(semicolonToken));
			}
#endif

			return new YieldStatementSyntax(kind, yieldKeyword, returnOrBreakKeyword, expression, semicolonToken, this.context);
		}

		public WhileStatementSyntax WhileStatement(SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement)
		{
#if DEBUG
			if (whileKeyword == null)
				throw new ArgumentNullException(nameof(whileKeyword));
			switch (whileKeyword.Kind)
			{
				case SyntaxKind.WhileKeyword:
					break;
				default:
					throw new ArgumentException(nameof(whileKeyword));
			}
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (condition == null)
				throw new ArgumentNullException(nameof(condition));
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
			if (statement == null)
				throw new ArgumentNullException(nameof(statement));
#endif

			return new WhileStatementSyntax(SyntaxKind.WhileStatement, whileKeyword, openParenToken, condition, closeParenToken, statement, this.context);
		}

		public DoStatementSyntax DoStatement(SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (doKeyword == null)
				throw new ArgumentNullException(nameof(doKeyword));
			switch (doKeyword.Kind)
			{
				case SyntaxKind.DoKeyword:
					break;
				default:
					throw new ArgumentException(nameof(doKeyword));
			}
			if (statement == null)
				throw new ArgumentNullException(nameof(statement));
			if (whileKeyword == null)
				throw new ArgumentNullException(nameof(whileKeyword));
			switch (whileKeyword.Kind)
			{
				case SyntaxKind.WhileKeyword:
					break;
				default:
					throw new ArgumentException(nameof(whileKeyword));
			}
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (condition == null)
				throw new ArgumentNullException(nameof(condition));
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
			if (semicolonToken == null)
				throw new ArgumentNullException(nameof(semicolonToken));
			switch (semicolonToken.Kind)
			{
				case SyntaxKind.SemicolonToken:
					break;
				default:
					throw new ArgumentException(nameof(semicolonToken));
			}
#endif

			return new DoStatementSyntax(SyntaxKind.DoStatement, doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken, this.context);
		}

		public ForStatementSyntax ForStatement(SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SeparatedSyntaxList<ExpressionSyntax> initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax condition, SyntaxToken secondSemicolonToken, SeparatedSyntaxList<ExpressionSyntax> incrementors, SyntaxToken closeParenToken, StatementSyntax statement)
		{
#if DEBUG
			if (forKeyword == null)
				throw new ArgumentNullException(nameof(forKeyword));
			switch (forKeyword.Kind)
			{
				case SyntaxKind.ForKeyword:
					break;
				default:
					throw new ArgumentException(nameof(forKeyword));
			}
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (firstSemicolonToken == null)
				throw new ArgumentNullException(nameof(firstSemicolonToken));
			switch (firstSemicolonToken.Kind)
			{
				case SyntaxKind.SemicolonToken:
					break;
				default:
					throw new ArgumentException(nameof(firstSemicolonToken));
			}
			if (secondSemicolonToken == null)
				throw new ArgumentNullException(nameof(secondSemicolonToken));
			switch (secondSemicolonToken.Kind)
			{
				case SyntaxKind.SemicolonToken:
					break;
				default:
					throw new ArgumentException(nameof(secondSemicolonToken));
			}
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
			if (statement == null)
				throw new ArgumentNullException(nameof(statement));
#endif

			return new ForStatementSyntax(SyntaxKind.ForStatement, forKeyword, openParenToken, declaration, initializers.Node, firstSemicolonToken, condition, secondSemicolonToken, incrementors.Node, closeParenToken, statement, this.context);
		}

		public ForEachStatementSyntax ForEachStatement(SyntaxToken awaitKeyword, SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
		{
#if DEBUG
			if (awaitKeyword != null)
			{
				switch (awaitKeyword.Kind)
				{
					case SyntaxKind.AwaitKeyword:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(awaitKeyword));
				}
			}
			if (forEachKeyword == null)
				throw new ArgumentNullException(nameof(forEachKeyword));
			switch (forEachKeyword.Kind)
			{
				case SyntaxKind.ForEachKeyword:
					break;
				default:
					throw new ArgumentException(nameof(forEachKeyword));
			}
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (type == null)
				throw new ArgumentNullException(nameof(type));
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
			if (inKeyword == null)
				throw new ArgumentNullException(nameof(inKeyword));
			switch (inKeyword.Kind)
			{
				case SyntaxKind.InKeyword:
					break;
				default:
					throw new ArgumentException(nameof(inKeyword));
			}
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
			if (statement == null)
				throw new ArgumentNullException(nameof(statement));
#endif

			return new ForEachStatementSyntax(SyntaxKind.ForEachStatement, awaitKeyword, forEachKeyword, openParenToken, type, identifier, inKeyword, expression, closeParenToken, statement, this.context);
		}

		public ForEachVariableStatementSyntax ForEachVariableStatement(SyntaxToken awaitKeyword, SyntaxToken forEachKeyword, SyntaxToken openParenToken, ExpressionSyntax variable, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
		{
#if DEBUG
			if (awaitKeyword != null)
			{
				switch (awaitKeyword.Kind)
				{
					case SyntaxKind.AwaitKeyword:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(awaitKeyword));
				}
			}
			if (forEachKeyword == null)
				throw new ArgumentNullException(nameof(forEachKeyword));
			switch (forEachKeyword.Kind)
			{
				case SyntaxKind.ForEachKeyword:
					break;
				default:
					throw new ArgumentException(nameof(forEachKeyword));
			}
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (variable == null)
				throw new ArgumentNullException(nameof(variable));
			if (inKeyword == null)
				throw new ArgumentNullException(nameof(inKeyword));
			switch (inKeyword.Kind)
			{
				case SyntaxKind.InKeyword:
					break;
				default:
					throw new ArgumentException(nameof(inKeyword));
			}
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
			if (statement == null)
				throw new ArgumentNullException(nameof(statement));
#endif

			return new ForEachVariableStatementSyntax(SyntaxKind.ForEachVariableStatement, awaitKeyword, forEachKeyword, openParenToken, variable, inKeyword, expression, closeParenToken, statement, this.context);
		}

		public UsingStatementSyntax UsingStatement(SyntaxToken awaitKeyword, SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
		{
#if DEBUG
			if (awaitKeyword != null)
			{
				switch (awaitKeyword.Kind)
				{
					case SyntaxKind.AwaitKeyword:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(awaitKeyword));
				}
			}
			if (usingKeyword == null)
				throw new ArgumentNullException(nameof(usingKeyword));
			switch (usingKeyword.Kind)
			{
				case SyntaxKind.UsingKeyword:
					break;
				default:
					throw new ArgumentException(nameof(usingKeyword));
			}
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
			if (statement == null)
				throw new ArgumentNullException(nameof(statement));
#endif

			return new UsingStatementSyntax(SyntaxKind.UsingStatement, awaitKeyword, usingKeyword, openParenToken, declaration, expression, closeParenToken, statement, this.context);
		}

		public FixedStatementSyntax FixedStatement(SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement)
		{
#if DEBUG
			if (fixedKeyword == null)
				throw new ArgumentNullException(nameof(fixedKeyword));
			switch (fixedKeyword.Kind)
			{
				case SyntaxKind.FixedKeyword:
					break;
				default:
					throw new ArgumentException(nameof(fixedKeyword));
			}
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (declaration == null)
				throw new ArgumentNullException(nameof(declaration));
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
			if (statement == null)
				throw new ArgumentNullException(nameof(statement));
#endif

			return new FixedStatementSyntax(SyntaxKind.FixedStatement, fixedKeyword, openParenToken, declaration, closeParenToken, statement, this.context);
		}

		public CheckedStatementSyntax CheckedStatement(SyntaxKind kind, SyntaxToken keyword, BlockSyntax block)
		{
			switch (kind)
			{
				case SyntaxKind.CheckedStatement:
				case SyntaxKind.UncheckedStatement:
					break;
				default:
					throw new ArgumentException(nameof(kind));
			}
#if DEBUG
			if (keyword == null)
				throw new ArgumentNullException(nameof(keyword));
			switch (keyword.Kind)
			{
				case SyntaxKind.CheckedKeyword:
				case SyntaxKind.UncheckedKeyword:
					break;
				default:
					throw new ArgumentException(nameof(keyword));
			}
			if (block == null)
				throw new ArgumentNullException(nameof(block));
#endif
			var result = new CheckedStatementSyntax(kind, keyword, block, this.context);

			return result;
		}

		public UnsafeStatementSyntax UnsafeStatement(SyntaxToken unsafeKeyword, BlockSyntax block)
		{
#if DEBUG
			if (unsafeKeyword == null)
				throw new ArgumentNullException(nameof(unsafeKeyword));
			switch (unsafeKeyword.Kind)
			{
				case SyntaxKind.UnsafeKeyword:
					break;
				default:
					throw new ArgumentException(nameof(unsafeKeyword));
			}
			if (block == null)
				throw new ArgumentNullException(nameof(block));
#endif
			var result = new UnsafeStatementSyntax(SyntaxKind.UnsafeStatement, unsafeKeyword, block, this.context);

			return result;
		}

		public LockStatementSyntax LockStatement(SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
		{
#if DEBUG
			if (lockKeyword == null)
				throw new ArgumentNullException(nameof(lockKeyword));
			switch (lockKeyword.Kind)
			{
				case SyntaxKind.LockKeyword:
					break;
				default:
					throw new ArgumentException(nameof(lockKeyword));
			}
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
			if (statement == null)
				throw new ArgumentNullException(nameof(statement));
#endif

			return new LockStatementSyntax(SyntaxKind.LockStatement, lockKeyword, openParenToken, expression, closeParenToken, statement, this.context);
		}

		public IfStatementSyntax IfStatement(SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax @else)
		{
#if DEBUG
			if (ifKeyword == null)
				throw new ArgumentNullException(nameof(ifKeyword));
			switch (ifKeyword.Kind)
			{
				case SyntaxKind.IfKeyword:
					break;
				default:
					throw new ArgumentException(nameof(ifKeyword));
			}
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (condition == null)
				throw new ArgumentNullException(nameof(condition));
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
			if (statement == null)
				throw new ArgumentNullException(nameof(statement));
#endif

			return new IfStatementSyntax(SyntaxKind.IfStatement, ifKeyword, openParenToken, condition, closeParenToken, statement, @else, this.context);
		}

		public ElseClauseSyntax ElseClause(SyntaxToken elseKeyword, StatementSyntax statement)
		{
#if DEBUG
			if (elseKeyword == null)
				throw new ArgumentNullException(nameof(elseKeyword));
			switch (elseKeyword.Kind)
			{
				case SyntaxKind.ElseKeyword:
					break;
				default:
					throw new ArgumentException(nameof(elseKeyword));
			}
			if (statement == null)
				throw new ArgumentNullException(nameof(statement));
#endif
			var result = new ElseClauseSyntax(SyntaxKind.ElseClause, elseKeyword, statement, this.context);

			return result;
		}

		public SwitchStatementSyntax SwitchStatement(SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, SyntaxList<SwitchSectionSyntax> sections, SyntaxToken closeBraceToken)
		{
#if DEBUG
			if (switchKeyword == null)
				throw new ArgumentNullException(nameof(switchKeyword));
			switch (switchKeyword.Kind)
			{
				case SyntaxKind.SwitchKeyword:
					break;
				default:
					throw new ArgumentException(nameof(switchKeyword));
			}
			if (openParenToken != null)
			{
				switch (openParenToken.Kind)
				{
					case SyntaxKind.OpenParenToken:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(openParenToken));
				}
			}
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
			if (closeParenToken != null)
			{
				switch (closeParenToken.Kind)
				{
					case SyntaxKind.CloseParenToken:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(closeParenToken));
				}
			}
			if (openBraceToken == null)
				throw new ArgumentNullException(nameof(openBraceToken));
			switch (openBraceToken.Kind)
			{
				case SyntaxKind.OpenBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(openBraceToken));
			}
			if (closeBraceToken == null)
				throw new ArgumentNullException(nameof(closeBraceToken));
			switch (closeBraceToken.Kind)
			{
				case SyntaxKind.CloseBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(closeBraceToken));
			}
#endif

			return new SwitchStatementSyntax(SyntaxKind.SwitchStatement, switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, sections.Node, closeBraceToken, this.context);
		}

		public SwitchSectionSyntax SwitchSection(SyntaxList<SwitchLabelSyntax> labels, SyntaxList<StatementSyntax> statements)
		{
#if DEBUG
#endif

			var result = new SwitchSectionSyntax(SyntaxKind.SwitchSection, labels.Node, statements.Node, this.context);
			return result;
		}

		public CasePatternSwitchLabelSyntax CasePatternSwitchLabel(SyntaxToken keyword, PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken colonToken)
		{
#if DEBUG
			if (keyword == null)
				throw new ArgumentNullException(nameof(keyword));
			switch (keyword.Kind)
			{
				case SyntaxKind.CaseKeyword:
					break;
				default:
					throw new ArgumentException(nameof(keyword));
			}
			if (pattern == null)
				throw new ArgumentNullException(nameof(pattern));
			if (colonToken == null)
				throw new ArgumentNullException(nameof(colonToken));
#endif

			return new CasePatternSwitchLabelSyntax(SyntaxKind.CasePatternSwitchLabel, keyword, pattern, whenClause, colonToken, this.context);
		}

		public CaseSwitchLabelSyntax CaseSwitchLabel(SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken)
		{
#if DEBUG
			if (keyword == null)
				throw new ArgumentNullException(nameof(keyword));
			switch (keyword.Kind)
			{
				case SyntaxKind.CaseKeyword:
					break;
				default:
					throw new ArgumentException(nameof(keyword));
			}
			if (value == null)
				throw new ArgumentNullException(nameof(value));
			if (colonToken == null)
				throw new ArgumentNullException(nameof(colonToken));
#endif

			var result = new CaseSwitchLabelSyntax(SyntaxKind.CaseSwitchLabel, keyword, value, colonToken, this.context);

			return result;
		}

		public DefaultSwitchLabelSyntax DefaultSwitchLabel(SyntaxToken keyword, SyntaxToken colonToken)
		{
#if DEBUG
			if (keyword == null)
				throw new ArgumentNullException(nameof(keyword));
			switch (keyword.Kind)
			{
				case SyntaxKind.DefaultKeyword:
					break;
				default:
					throw new ArgumentException(nameof(keyword));
			}
			if (colonToken == null)
				throw new ArgumentNullException(nameof(colonToken));
#endif

			var result = new DefaultSwitchLabelSyntax(SyntaxKind.DefaultSwitchLabel, keyword, colonToken, this.context);

			return result;
		}

		public SwitchExpressionSyntax SwitchExpression(ExpressionSyntax governingExpression, SyntaxToken switchKeyword, SyntaxToken openBraceToken, SeparatedSyntaxList<SwitchExpressionArmSyntax> arms, SyntaxToken closeBraceToken)
		{
#if DEBUG
			if (governingExpression == null)
				throw new ArgumentNullException(nameof(governingExpression));
			if (switchKeyword == null)
				throw new ArgumentNullException(nameof(switchKeyword));
			switch (switchKeyword.Kind)
			{
				case SyntaxKind.SwitchKeyword:
					break;
				default:
					throw new ArgumentException(nameof(switchKeyword));
			}
			if (openBraceToken == null)
				throw new ArgumentNullException(nameof(openBraceToken));
			switch (openBraceToken.Kind)
			{
				case SyntaxKind.OpenBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(openBraceToken));
			}
			if (closeBraceToken == null)
				throw new ArgumentNullException(nameof(closeBraceToken));
			switch (closeBraceToken.Kind)
			{
				case SyntaxKind.CloseBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(closeBraceToken));
			}
#endif

			return new SwitchExpressionSyntax(SyntaxKind.SwitchExpression, governingExpression, switchKeyword, openBraceToken, arms.Node, closeBraceToken, this.context);
		}

		public SwitchExpressionArmSyntax SwitchExpressionArm(PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken equalsGreaterThanToken, ExpressionSyntax expression)
		{
#if DEBUG
			if (pattern == null)
				throw new ArgumentNullException(nameof(pattern));
			if (equalsGreaterThanToken == null)
				throw new ArgumentNullException(nameof(equalsGreaterThanToken));
			switch (equalsGreaterThanToken.Kind)
			{
				case SyntaxKind.EqualsGreaterThanToken:
					break;
				default:
					throw new ArgumentException(nameof(equalsGreaterThanToken));
			}
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
#endif

			return new SwitchExpressionArmSyntax(SyntaxKind.SwitchExpressionArm, pattern, whenClause, equalsGreaterThanToken, expression, this.context);
		}

		public TryStatementSyntax TryStatement(SyntaxToken tryKeyword, BlockSyntax block, SyntaxList<CatchClauseSyntax> catches, FinallyClauseSyntax @finally)
		{
#if DEBUG
			if (tryKeyword == null)
				throw new ArgumentNullException(nameof(tryKeyword));
			switch (tryKeyword.Kind)
			{
				case SyntaxKind.TryKeyword:
					break;
				default:
					throw new ArgumentException(nameof(tryKeyword));
			}
			if (block == null)
				throw new ArgumentNullException(nameof(block));
#endif

			return new TryStatementSyntax(SyntaxKind.TryStatement, tryKeyword, block, catches.Node, @finally, this.context);
		}

		public CatchClauseSyntax CatchClause(SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block)
		{
#if DEBUG
			if (catchKeyword == null)
				throw new ArgumentNullException(nameof(catchKeyword));
			switch (catchKeyword.Kind)
			{
				case SyntaxKind.CatchKeyword:
					break;
				default:
					throw new ArgumentException(nameof(catchKeyword));
			}
			if (block == null)
				throw new ArgumentNullException(nameof(block));
#endif

			return new CatchClauseSyntax(SyntaxKind.CatchClause, catchKeyword, declaration, filter, block, this.context);
		}

		public CatchDeclarationSyntax CatchDeclaration(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken)
		{
#if DEBUG
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (type == null)
				throw new ArgumentNullException(nameof(type));
			if (identifier != null)
			{
				switch (identifier.Kind)
				{
					case SyntaxKind.IdentifierToken:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(identifier));
				}
			}
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
#endif

			return new CatchDeclarationSyntax(SyntaxKind.CatchDeclaration, openParenToken, type, identifier, closeParenToken, this.context);
		}

		public CatchFilterClauseSyntax CatchFilterClause(SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken)
		{
#if DEBUG
			if (whenKeyword == null)
				throw new ArgumentNullException(nameof(whenKeyword));
			switch (whenKeyword.Kind)
			{
				case SyntaxKind.WhenKeyword:
					break;
				default:
					throw new ArgumentException(nameof(whenKeyword));
			}
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (filterExpression == null)
				throw new ArgumentNullException(nameof(filterExpression));
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
#endif

			return new CatchFilterClauseSyntax(SyntaxKind.CatchFilterClause, whenKeyword, openParenToken, filterExpression, closeParenToken, this.context);
		}

		public FinallyClauseSyntax FinallyClause(SyntaxToken finallyKeyword, BlockSyntax block)
		{
#if DEBUG
			if (finallyKeyword == null)
				throw new ArgumentNullException(nameof(finallyKeyword));
			switch (finallyKeyword.Kind)
			{
				case SyntaxKind.FinallyKeyword:
					break;
				default:
					throw new ArgumentException(nameof(finallyKeyword));
			}
			if (block == null)
				throw new ArgumentNullException(nameof(block));
#endif

			var result = new FinallyClauseSyntax(SyntaxKind.FinallyClause, finallyKeyword, block, this.context);

			return result;
		}

		public CompilationUnitSyntax CompilationUnit(SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken endOfFileToken)
		{
#if DEBUG
			if (endOfFileToken == null)
				throw new ArgumentNullException(nameof(endOfFileToken));
			switch (endOfFileToken.Kind)
			{
				case SyntaxKind.EndOfFileToken:
					break;
				default:
					throw new ArgumentException(nameof(endOfFileToken));
			}
#endif

			return new CompilationUnitSyntax(SyntaxKind.CompilationUnit, externs.Node, usings.Node, attributeLists.Node, members.Node, endOfFileToken, this.context);
		}

		public ExternAliasDirectiveSyntax ExternAliasDirective(SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (externKeyword == null)
				throw new ArgumentNullException(nameof(externKeyword));
			switch (externKeyword.Kind)
			{
				case SyntaxKind.ExternKeyword:
					break;
				default:
					throw new ArgumentException(nameof(externKeyword));
			}
			if (aliasKeyword == null)
				throw new ArgumentNullException(nameof(aliasKeyword));
			switch (aliasKeyword.Kind)
			{
				case SyntaxKind.AliasKeyword:
					break;
				default:
					throw new ArgumentException(nameof(aliasKeyword));
			}
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
			if (semicolonToken == null)
				throw new ArgumentNullException(nameof(semicolonToken));
			switch (semicolonToken.Kind)
			{
				case SyntaxKind.SemicolonToken:
					break;
				default:
					throw new ArgumentException(nameof(semicolonToken));
			}
#endif

			return new ExternAliasDirectiveSyntax(SyntaxKind.ExternAliasDirective, externKeyword, aliasKeyword, identifier, semicolonToken, this.context);
		}

		public UsingDirectiveSyntax UsingDirective(SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (usingKeyword == null)
				throw new ArgumentNullException(nameof(usingKeyword));
			switch (usingKeyword.Kind)
			{
				case SyntaxKind.UsingKeyword:
					break;
				default:
					throw new ArgumentException(nameof(usingKeyword));
			}
			if (name == null)
				throw new ArgumentNullException(nameof(name));
			if (semicolonToken == null)
				throw new ArgumentNullException(nameof(semicolonToken));
			switch (semicolonToken.Kind)
			{
				case SyntaxKind.SemicolonToken:
					break;
				default:
					throw new ArgumentException(nameof(semicolonToken));
			}
#endif

			return new UsingDirectiveSyntax(SyntaxKind.UsingDirective, usingKeyword, staticKeyword, alias, name, semicolonToken, this.context);
		}

		public NamespaceDeclarationSyntax NamespaceDeclaration(SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (namespaceKeyword == null)
				throw new ArgumentNullException(nameof(namespaceKeyword));
			switch (namespaceKeyword.Kind)
			{
				case SyntaxKind.NamespaceKeyword:
					break;
				default:
					throw new ArgumentException(nameof(namespaceKeyword));
			}
			if (name == null)
				throw new ArgumentNullException(nameof(name));
			if (openBraceToken == null)
				throw new ArgumentNullException(nameof(openBraceToken));
			switch (openBraceToken.Kind)
			{
				case SyntaxKind.OpenBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(openBraceToken));
			}
			if (closeBraceToken == null)
				throw new ArgumentNullException(nameof(closeBraceToken));
			switch (closeBraceToken.Kind)
			{
				case SyntaxKind.CloseBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(closeBraceToken));
			}
			if (semicolonToken != null)
			{
				switch (semicolonToken.Kind)
				{
					case SyntaxKind.SemicolonToken:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(semicolonToken));
				}
			}
#endif

			return new NamespaceDeclarationSyntax(SyntaxKind.NamespaceDeclaration, namespaceKeyword, name, openBraceToken, externs.Node, usings.Node, members.Node, closeBraceToken, semicolonToken, this.context);
		}

		public AttributeListSyntax AttributeList(SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax target, SeparatedSyntaxList<AttributeSyntax> attributes, SyntaxToken closeBracketToken)
		{
#if DEBUG
			if (openBracketToken == null)
				throw new ArgumentNullException(nameof(openBracketToken));
			switch (openBracketToken.Kind)
			{
				case SyntaxKind.OpenBracketToken:
					break;
				default:
					throw new ArgumentException(nameof(openBracketToken));
			}
			if (closeBracketToken == null)
				throw new ArgumentNullException(nameof(closeBracketToken));
			switch (closeBracketToken.Kind)
			{
				case SyntaxKind.CloseBracketToken:
					break;
				default:
					throw new ArgumentException(nameof(closeBracketToken));
			}
#endif

			return new AttributeListSyntax(SyntaxKind.AttributeList, openBracketToken, target, attributes.Node, closeBracketToken, this.context);
		}

		public AttributeTargetSpecifierSyntax AttributeTargetSpecifier(SyntaxToken identifier, SyntaxToken colonToken)
		{
#if DEBUG
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			if (colonToken == null)
				throw new ArgumentNullException(nameof(colonToken));
			switch (colonToken.Kind)
			{
				case SyntaxKind.ColonToken:
					break;
				default:
					throw new ArgumentException(nameof(colonToken));
			}
#endif

			var result = new AttributeTargetSpecifierSyntax(SyntaxKind.AttributeTargetSpecifier, identifier, colonToken, this.context);
			return result;
		}

		public AttributeSyntax Attribute(NameSyntax name, AttributeArgumentListSyntax argumentList)
		{
#if DEBUG
			if (name == null)
				throw new ArgumentNullException(nameof(name));
#endif

			var result = new AttributeSyntax(SyntaxKind.Attribute, name, argumentList, this.context);
			return result;
		}

		public AttributeArgumentListSyntax AttributeArgumentList(SyntaxToken openParenToken, SeparatedSyntaxList<AttributeArgumentSyntax> arguments, SyntaxToken closeParenToken)
		{
#if DEBUG
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
#endif

			var result = new AttributeArgumentListSyntax(SyntaxKind.AttributeArgumentList, openParenToken, arguments.Node, closeParenToken, this.context);
			return result;
		}

		public AttributeArgumentSyntax AttributeArgument(NameEqualsSyntax nameEquals, NameColonSyntax nameColon, ExpressionSyntax expression)
		{
#if DEBUG
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
#endif

			var result = new AttributeArgumentSyntax(SyntaxKind.AttributeArgument, nameEquals, nameColon, expression, this.context);
			return result;
		}

		public NameEqualsSyntax NameEquals(IdentifierNameSyntax name, SyntaxToken equalsToken)
		{
#if DEBUG
			if (name == null)
				throw new ArgumentNullException(nameof(name));
			if (equalsToken == null)
				throw new ArgumentNullException(nameof(equalsToken));
			switch (equalsToken.Kind)
			{
				case SyntaxKind.EqualsToken:
					break;
				default:
					throw new ArgumentException(nameof(equalsToken));
			}
#endif

			var result = new NameEqualsSyntax(SyntaxKind.NameEquals, name, equalsToken, this.context);
			return result;
		}

		public TypeParameterListSyntax TypeParameterList(SyntaxToken lessThanToken, SeparatedSyntaxList<TypeParameterSyntax> parameters, SyntaxToken greaterThanToken)
		{
#if DEBUG
			if (lessThanToken == null)
				throw new ArgumentNullException(nameof(lessThanToken));
			switch (lessThanToken.Kind)
			{
				case SyntaxKind.LessThanToken:
					break;
				default:
					throw new ArgumentException(nameof(lessThanToken));
			}
			if (greaterThanToken == null)
				throw new ArgumentNullException(nameof(greaterThanToken));
			switch (greaterThanToken.Kind)
			{
				case SyntaxKind.GreaterThanToken:
					break;
				default:
					throw new ArgumentException(nameof(greaterThanToken));
			}
#endif

			var result = new TypeParameterListSyntax(SyntaxKind.TypeParameterList, lessThanToken, parameters.Node, greaterThanToken, this.context);
			return result;
		}

		public TypeParameterSyntax TypeParameter(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken varianceKeyword, SyntaxToken identifier)
		{
#if DEBUG
			if (varianceKeyword != null)
			{
				switch (varianceKeyword.Kind)
				{
					case SyntaxKind.InKeyword:
					case SyntaxKind.OutKeyword:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(varianceKeyword));
				}
			}
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
#endif

			var result = new TypeParameterSyntax(SyntaxKind.TypeParameter, attributeLists.Node, varianceKeyword, identifier, this.context);
			return result;
		}

		public ClassDeclarationSyntax ClassDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (keyword == null)
				throw new ArgumentNullException(nameof(keyword));
			switch (keyword.Kind)
			{
				case SyntaxKind.ClassKeyword:
					break;
				default:
					throw new ArgumentException(nameof(keyword));
			}
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
			if (openBraceToken == null)
				throw new ArgumentNullException(nameof(openBraceToken));
			switch (openBraceToken.Kind)
			{
				case SyntaxKind.OpenBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(openBraceToken));
			}
			if (closeBraceToken == null)
				throw new ArgumentNullException(nameof(closeBraceToken));
			switch (closeBraceToken.Kind)
			{
				case SyntaxKind.CloseBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(closeBraceToken));
			}
			if (semicolonToken != null)
			{
				switch (semicolonToken.Kind)
				{
					case SyntaxKind.SemicolonToken:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(semicolonToken));
				}
			}
#endif

			return new ClassDeclarationSyntax(SyntaxKind.ClassDeclaration, attributeLists.Node, modifiers.Node, keyword, identifier, typeParameterList, baseList, constraintClauses.Node, openBraceToken, members.Node, closeBraceToken, semicolonToken, this.context);
		}

		public StructDeclarationSyntax StructDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (keyword == null)
				throw new ArgumentNullException(nameof(keyword));
			switch (keyword.Kind)
			{
				case SyntaxKind.StructKeyword:
					break;
				default:
					throw new ArgumentException(nameof(keyword));
			}
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
			if (openBraceToken == null)
				throw new ArgumentNullException(nameof(openBraceToken));
			switch (openBraceToken.Kind)
			{
				case SyntaxKind.OpenBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(openBraceToken));
			}
			if (closeBraceToken == null)
				throw new ArgumentNullException(nameof(closeBraceToken));
			switch (closeBraceToken.Kind)
			{
				case SyntaxKind.CloseBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(closeBraceToken));
			}
			if (semicolonToken != null)
			{
				switch (semicolonToken.Kind)
				{
					case SyntaxKind.SemicolonToken:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(semicolonToken));
				}
			}
#endif

			return new StructDeclarationSyntax(SyntaxKind.StructDeclaration, attributeLists.Node, modifiers.Node, keyword, identifier, typeParameterList, baseList, constraintClauses.Node, openBraceToken, members.Node, closeBraceToken, semicolonToken, this.context);
		}

		public InterfaceDeclarationSyntax InterfaceDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (keyword == null)
				throw new ArgumentNullException(nameof(keyword));
			switch (keyword.Kind)
			{
				case SyntaxKind.InterfaceKeyword:
					break;
				default:
					throw new ArgumentException(nameof(keyword));
			}
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
			if (openBraceToken == null)
				throw new ArgumentNullException(nameof(openBraceToken));
			switch (openBraceToken.Kind)
			{
				case SyntaxKind.OpenBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(openBraceToken));
			}
			if (closeBraceToken == null)
				throw new ArgumentNullException(nameof(closeBraceToken));
			switch (closeBraceToken.Kind)
			{
				case SyntaxKind.CloseBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(closeBraceToken));
			}
			if (semicolonToken != null)
			{
				switch (semicolonToken.Kind)
				{
					case SyntaxKind.SemicolonToken:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(semicolonToken));
				}
			}
#endif

			return new InterfaceDeclarationSyntax(SyntaxKind.InterfaceDeclaration, attributeLists.Node, modifiers.Node, keyword, identifier, typeParameterList, baseList, constraintClauses.Node, openBraceToken, members.Node, closeBraceToken, semicolonToken, this.context);
		}

		public EnumDeclarationSyntax EnumDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax baseList, SyntaxToken openBraceToken, SeparatedSyntaxList<EnumMemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (enumKeyword == null)
				throw new ArgumentNullException(nameof(enumKeyword));
			switch (enumKeyword.Kind)
			{
				case SyntaxKind.EnumKeyword:
					break;
				default:
					throw new ArgumentException(nameof(enumKeyword));
			}
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
			if (openBraceToken == null)
				throw new ArgumentNullException(nameof(openBraceToken));
			switch (openBraceToken.Kind)
			{
				case SyntaxKind.OpenBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(openBraceToken));
			}
			if (closeBraceToken == null)
				throw new ArgumentNullException(nameof(closeBraceToken));
			switch (closeBraceToken.Kind)
			{
				case SyntaxKind.CloseBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(closeBraceToken));
			}
			if (semicolonToken != null)
			{
				switch (semicolonToken.Kind)
				{
					case SyntaxKind.SemicolonToken:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(semicolonToken));
				}
			}
#endif

			return new EnumDeclarationSyntax(SyntaxKind.EnumDeclaration, attributeLists.Node, modifiers.Node, enumKeyword, identifier, baseList, openBraceToken, members.Node, closeBraceToken, semicolonToken, this.context);
		}

		public DelegateDeclarationSyntax DelegateDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (delegateKeyword == null)
				throw new ArgumentNullException(nameof(delegateKeyword));
			switch (delegateKeyword.Kind)
			{
				case SyntaxKind.DelegateKeyword:
					break;
				default:
					throw new ArgumentException(nameof(delegateKeyword));
			}
			if (returnType == null)
				throw new ArgumentNullException(nameof(returnType));
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
			if (parameterList == null)
				throw new ArgumentNullException(nameof(parameterList));
			if (semicolonToken == null)
				throw new ArgumentNullException(nameof(semicolonToken));
			switch (semicolonToken.Kind)
			{
				case SyntaxKind.SemicolonToken:
					break;
				default:
					throw new ArgumentException(nameof(semicolonToken));
			}
#endif

			return new DelegateDeclarationSyntax(SyntaxKind.DelegateDeclaration, attributeLists.Node, modifiers.Node, delegateKeyword, returnType, identifier, typeParameterList, parameterList, constraintClauses.Node, semicolonToken, this.context);
		}

		public EnumMemberDeclarationSyntax EnumMemberDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue)
		{
#if DEBUG
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
#endif
			var result = new EnumMemberDeclarationSyntax(SyntaxKind.EnumMemberDeclaration, attributeLists.Node, identifier, equalsValue, this.context);

			return result;
		}

		public BaseListSyntax BaseList(SyntaxToken colonToken, SeparatedSyntaxList<BaseTypeSyntax> types)
		{
#if DEBUG
			if (colonToken == null)
				throw new ArgumentNullException(nameof(colonToken));
			switch (colonToken.Kind)
			{
				case SyntaxKind.ColonToken:
					break;
				default:
					throw new ArgumentException(nameof(colonToken));
			}
#endif
			var result = new BaseListSyntax(SyntaxKind.BaseList, colonToken, types.Node, this.context);
			return result;
		}

		public SimpleBaseTypeSyntax SimpleBaseType(TypeSyntax type)
		{
#if DEBUG
			if (type == null)
				throw new ArgumentNullException(nameof(type));
#endif

			var result = new SimpleBaseTypeSyntax(SyntaxKind.SimpleBaseType, type, this.context);

			return result;
		}

		public TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, SeparatedSyntaxList<TypeParameterConstraintSyntax> constraints)
		{
#if DEBUG
			if (whereKeyword == null)
				throw new ArgumentNullException(nameof(whereKeyword));
			switch (whereKeyword.Kind)
			{
				case SyntaxKind.WhereKeyword:
					break;
				default:
					throw new ArgumentException(nameof(whereKeyword));
			}
			if (name == null)
				throw new ArgumentNullException(nameof(name));
			if (colonToken == null)
				throw new ArgumentNullException(nameof(colonToken));
			switch (colonToken.Kind)
			{
				case SyntaxKind.ColonToken:
					break;
				default:
					throw new ArgumentException(nameof(colonToken));
			}
#endif

			return new TypeParameterConstraintClauseSyntax(SyntaxKind.TypeParameterConstraintClause, whereKeyword, name, colonToken, constraints.Node, this.context);
		}

		public ConstructorConstraintSyntax ConstructorConstraint(SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken)
		{
#if DEBUG
			if (newKeyword == null)
				throw new ArgumentNullException(nameof(newKeyword));
			switch (newKeyword.Kind)
			{
				case SyntaxKind.NewKeyword:
					break;
				default:
					throw new ArgumentException(nameof(newKeyword));
			}
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
#endif
			var result = new ConstructorConstraintSyntax(SyntaxKind.ConstructorConstraint, newKeyword, openParenToken, closeParenToken, this.context);

			return result;
		}

		public ClassOrStructConstraintSyntax ClassOrStructConstraint(SyntaxKind kind, SyntaxToken classOrStructKeyword, SyntaxToken questionToken)
		{
			switch (kind)
			{
				case SyntaxKind.ClassConstraint:
				case SyntaxKind.StructConstraint:
					break;
				default:
					throw new ArgumentException(nameof(kind));
			}
#if DEBUG
			if (classOrStructKeyword == null)
				throw new ArgumentNullException(nameof(classOrStructKeyword));
			switch (classOrStructKeyword.Kind)
			{
				case SyntaxKind.ClassKeyword:
				case SyntaxKind.StructKeyword:
					break;
				default:
					throw new ArgumentException(nameof(classOrStructKeyword));
			}
			if (questionToken != null)
			{
				switch (questionToken.Kind)
				{
					case SyntaxKind.QuestionToken:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(questionToken));
				}
			}
#endif

			var result = new ClassOrStructConstraintSyntax(kind, classOrStructKeyword, questionToken, this.context);

			return result;
		}

		public TypeConstraintSyntax TypeConstraint(TypeSyntax type)
		{
#if DEBUG
			if (type == null)
				throw new ArgumentNullException(nameof(type));
#endif

			var result = new TypeConstraintSyntax(SyntaxKind.TypeConstraint, type, this.context);

			return result;
		}

		public FieldDeclarationSyntax FieldDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (declaration == null)
				throw new ArgumentNullException(nameof(declaration));
			if (semicolonToken == null)
				throw new ArgumentNullException(nameof(semicolonToken));
			switch (semicolonToken.Kind)
			{
				case SyntaxKind.SemicolonToken:
					break;
				default:
					throw new ArgumentException(nameof(semicolonToken));
			}
#endif

			return new FieldDeclarationSyntax(SyntaxKind.FieldDeclaration, attributeLists.Node, modifiers.Node, declaration, semicolonToken, this.context);
		}

		public EventFieldDeclarationSyntax EventFieldDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (eventKeyword == null)
				throw new ArgumentNullException(nameof(eventKeyword));
			switch (eventKeyword.Kind)
			{
				case SyntaxKind.EventKeyword:
					break;
				default:
					throw new ArgumentException(nameof(eventKeyword));
			}
			if (declaration == null)
				throw new ArgumentNullException(nameof(declaration));
			if (semicolonToken == null)
				throw new ArgumentNullException(nameof(semicolonToken));
			switch (semicolonToken.Kind)
			{
				case SyntaxKind.SemicolonToken:
					break;
				default:
					throw new ArgumentException(nameof(semicolonToken));
			}
#endif

			return new EventFieldDeclarationSyntax(SyntaxKind.EventFieldDeclaration, attributeLists.Node, modifiers.Node, eventKeyword, declaration, semicolonToken, this.context);
		}

		public ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier(NameSyntax name, SyntaxToken dotToken)
		{
#if DEBUG
			if (name == null)
				throw new ArgumentNullException(nameof(name));
			if (dotToken == null)
				throw new ArgumentNullException(nameof(dotToken));
			switch (dotToken.Kind)
			{
				case SyntaxKind.DotToken:
					break;
				default:
					throw new ArgumentException(nameof(dotToken));
			}
#endif

			var result = new ExplicitInterfaceSpecifierSyntax(SyntaxKind.ExplicitInterfaceSpecifier, name, dotToken, this.context);

			return result;
		}

		public MethodDeclarationSyntax MethodDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (returnType == null)
				throw new ArgumentNullException(nameof(returnType));
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
			if (parameterList == null)
				throw new ArgumentNullException(nameof(parameterList));
			if (semicolonToken != null)
			{
				switch (semicolonToken.Kind)
				{
					case SyntaxKind.SemicolonToken:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(semicolonToken));
				}
			}
#endif

			return new MethodDeclarationSyntax(SyntaxKind.MethodDeclaration, attributeLists.Node, modifiers.Node, returnType, explicitInterfaceSpecifier, identifier, typeParameterList, parameterList, constraintClauses.Node, body, expressionBody, semicolonToken, this.context);
		}

		public OperatorDeclarationSyntax OperatorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (returnType == null)
				throw new ArgumentNullException(nameof(returnType));
			if (operatorKeyword == null)
				throw new ArgumentNullException(nameof(operatorKeyword));
			switch (operatorKeyword.Kind)
			{
				case SyntaxKind.OperatorKeyword:
					break;
				default:
					throw new ArgumentException(nameof(operatorKeyword));
			}
			if (operatorToken == null)
				throw new ArgumentNullException(nameof(operatorToken));
			switch (operatorToken.Kind)
			{
				case SyntaxKind.PlusToken:
				case SyntaxKind.MinusToken:
				case SyntaxKind.ExclamationToken:
				case SyntaxKind.TildeToken:
				case SyntaxKind.PlusPlusToken:
				case SyntaxKind.MinusMinusToken:
				case SyntaxKind.AsteriskToken:
				case SyntaxKind.SlashToken:
				case SyntaxKind.PercentToken:
				case SyntaxKind.LessThanLessThanToken:
				case SyntaxKind.GreaterThanGreaterThanToken:
				case SyntaxKind.BarToken:
				case SyntaxKind.AmpersandToken:
				case SyntaxKind.CaretToken:
				case SyntaxKind.EqualsEqualsToken:
				case SyntaxKind.ExclamationEqualsToken:
				case SyntaxKind.LessThanToken:
				case SyntaxKind.LessThanEqualsToken:
				case SyntaxKind.GreaterThanToken:
				case SyntaxKind.GreaterThanEqualsToken:
				case SyntaxKind.FalseKeyword:
				case SyntaxKind.TrueKeyword:
				case SyntaxKind.IsKeyword:
					break;
				default:
					throw new ArgumentException(nameof(operatorToken));
			}
			if (parameterList == null)
				throw new ArgumentNullException(nameof(parameterList));
			if (semicolonToken != null)
			{
				switch (semicolonToken.Kind)
				{
					case SyntaxKind.SemicolonToken:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(semicolonToken));
				}
			}
#endif

			return new OperatorDeclarationSyntax(SyntaxKind.OperatorDeclaration, attributeLists.Node, modifiers.Node, returnType, operatorKeyword, operatorToken, parameterList, body, expressionBody, semicolonToken, this.context);
		}

		public ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (implicitOrExplicitKeyword == null)
				throw new ArgumentNullException(nameof(implicitOrExplicitKeyword));
			switch (implicitOrExplicitKeyword.Kind)
			{
				case SyntaxKind.ImplicitKeyword:
				case SyntaxKind.ExplicitKeyword:
					break;
				default:
					throw new ArgumentException(nameof(implicitOrExplicitKeyword));
			}
			if (operatorKeyword == null)
				throw new ArgumentNullException(nameof(operatorKeyword));
			switch (operatorKeyword.Kind)
			{
				case SyntaxKind.OperatorKeyword:
					break;
				default:
					throw new ArgumentException(nameof(operatorKeyword));
			}
			if (type == null)
				throw new ArgumentNullException(nameof(type));
			if (parameterList == null)
				throw new ArgumentNullException(nameof(parameterList));
			if (semicolonToken != null)
			{
				switch (semicolonToken.Kind)
				{
					case SyntaxKind.SemicolonToken:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(semicolonToken));
				}
			}
#endif

			return new ConversionOperatorDeclarationSyntax(SyntaxKind.ConversionOperatorDeclaration, attributeLists.Node, modifiers.Node, implicitOrExplicitKeyword, operatorKeyword, type, parameterList, body, expressionBody, semicolonToken, this.context);
		}

		public ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
			if (parameterList == null)
				throw new ArgumentNullException(nameof(parameterList));
			if (semicolonToken != null)
			{
				switch (semicolonToken.Kind)
				{
					case SyntaxKind.SemicolonToken:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(semicolonToken));
				}
			}
#endif

			return new ConstructorDeclarationSyntax(SyntaxKind.ConstructorDeclaration, attributeLists.Node, modifiers.Node, identifier, parameterList, initializer, body, expressionBody, semicolonToken, this.context);
		}

		public ConstructorInitializerSyntax ConstructorInitializer(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList)
		{
			switch (kind)
			{
				case SyntaxKind.BaseConstructorInitializer:
				case SyntaxKind.ThisConstructorInitializer:
					break;
				default:
					throw new ArgumentException(nameof(kind));
			}
#if DEBUG
			if (colonToken == null)
				throw new ArgumentNullException(nameof(colonToken));
			switch (colonToken.Kind)
			{
				case SyntaxKind.ColonToken:
					break;
				default:
					throw new ArgumentException(nameof(colonToken));
			}
			if (thisOrBaseKeyword == null)
				throw new ArgumentNullException(nameof(thisOrBaseKeyword));
			switch (thisOrBaseKeyword.Kind)
			{
				case SyntaxKind.BaseKeyword:
				case SyntaxKind.ThisKeyword:
					break;
				default:
					throw new ArgumentException(nameof(thisOrBaseKeyword));
			}
			if (argumentList == null)
				throw new ArgumentNullException(nameof(argumentList));
#endif

			var result = new ConstructorInitializerSyntax(kind, colonToken, thisOrBaseKeyword, argumentList, this.context);
			return result;
		}

		public DestructorDeclarationSyntax DestructorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (tildeToken == null)
				throw new ArgumentNullException(nameof(tildeToken));
			switch (tildeToken.Kind)
			{
				case SyntaxKind.TildeToken:
					break;
				default:
					throw new ArgumentException(nameof(tildeToken));
			}
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
			if (parameterList == null)
				throw new ArgumentNullException(nameof(parameterList));
			if (semicolonToken != null)
			{
				switch (semicolonToken.Kind)
				{
					case SyntaxKind.SemicolonToken:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(semicolonToken));
				}
			}
#endif

			return new DestructorDeclarationSyntax(SyntaxKind.DestructorDeclaration, attributeLists.Node, modifiers.Node, tildeToken, identifier, parameterList, body, expressionBody, semicolonToken, this.context);
		}

		public PropertyDeclarationSyntax PropertyDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (type == null)
				throw new ArgumentNullException(nameof(type));
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
			if (semicolonToken != null)
			{
				switch (semicolonToken.Kind)
				{
					case SyntaxKind.SemicolonToken:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(semicolonToken));
				}
			}
#endif

			return new PropertyDeclarationSyntax(SyntaxKind.PropertyDeclaration, attributeLists.Node, modifiers.Node, type, explicitInterfaceSpecifier, identifier, accessorList, expressionBody, initializer, semicolonToken, this.context);
		}

		public ArrowExpressionClauseSyntax ArrowExpressionClause(SyntaxToken arrowToken, ExpressionSyntax expression)
		{
#if DEBUG
			if (arrowToken == null)
				throw new ArgumentNullException(nameof(arrowToken));
			switch (arrowToken.Kind)
			{
				case SyntaxKind.EqualsGreaterThanToken:
					break;
				default:
					throw new ArgumentException(nameof(arrowToken));
			}
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
#endif

			var result = new ArrowExpressionClauseSyntax(SyntaxKind.ArrowExpressionClause, arrowToken, expression, this.context);

			return result;
		}

		public EventDeclarationSyntax EventDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList)
		{
#if DEBUG
			if (eventKeyword == null)
				throw new ArgumentNullException(nameof(eventKeyword));
			switch (eventKeyword.Kind)
			{
				case SyntaxKind.EventKeyword:
					break;
				default:
					throw new ArgumentException(nameof(eventKeyword));
			}
			if (type == null)
				throw new ArgumentNullException(nameof(type));
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
			if (accessorList == null)
				throw new ArgumentNullException(nameof(accessorList));
#endif

			return new EventDeclarationSyntax(SyntaxKind.EventDeclaration, attributeLists.Node, modifiers.Node, eventKeyword, type, explicitInterfaceSpecifier, identifier, accessorList, this.context);
		}

		public IndexerDeclarationSyntax IndexerDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (type == null)
				throw new ArgumentNullException(nameof(type));
			if (thisKeyword == null)
				throw new ArgumentNullException(nameof(thisKeyword));
			switch (thisKeyword.Kind)
			{
				case SyntaxKind.ThisKeyword:
					break;
				default:
					throw new ArgumentException(nameof(thisKeyword));
			}
			if (parameterList == null)
				throw new ArgumentNullException(nameof(parameterList));
			if (semicolonToken != null)
			{
				switch (semicolonToken.Kind)
				{
					case SyntaxKind.SemicolonToken:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(semicolonToken));
				}
			}
#endif

			return new IndexerDeclarationSyntax(SyntaxKind.IndexerDeclaration, attributeLists.Node, modifiers.Node, type, explicitInterfaceSpecifier, thisKeyword, parameterList, accessorList, expressionBody, semicolonToken, this.context);
		}

		public AccessorListSyntax AccessorList(SyntaxToken openBraceToken, SyntaxList<AccessorDeclarationSyntax> accessors, SyntaxToken closeBraceToken)
		{
#if DEBUG
			if (openBraceToken == null)
				throw new ArgumentNullException(nameof(openBraceToken));
			switch (openBraceToken.Kind)
			{
				case SyntaxKind.OpenBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(openBraceToken));
			}
			if (closeBraceToken == null)
				throw new ArgumentNullException(nameof(closeBraceToken));
			switch (closeBraceToken.Kind)
			{
				case SyntaxKind.CloseBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(closeBraceToken));
			}
#endif
			var result = new AccessorListSyntax(SyntaxKind.AccessorList, openBraceToken, accessors.Node, closeBraceToken, this.context);
			return result;
		}

		public AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
		{
			switch (kind)
			{
				case SyntaxKind.GetAccessorDeclaration:
				case SyntaxKind.SetAccessorDeclaration:
				case SyntaxKind.AddAccessorDeclaration:
				case SyntaxKind.RemoveAccessorDeclaration:
				case SyntaxKind.UnknownAccessorDeclaration:
					break;
				default:
					throw new ArgumentException(nameof(kind));
			}
#if DEBUG
			if (keyword == null)
				throw new ArgumentNullException(nameof(keyword));
			switch (keyword.Kind)
			{
				case SyntaxKind.GetKeyword:
				case SyntaxKind.SetKeyword:
				case SyntaxKind.AddKeyword:
				case SyntaxKind.RemoveKeyword:
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(keyword));
			}
			if (semicolonToken != null)
			{
				switch (semicolonToken.Kind)
				{
					case SyntaxKind.SemicolonToken:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(semicolonToken));
				}
			}
#endif

			return new AccessorDeclarationSyntax(kind, attributeLists.Node, modifiers.Node, keyword, body, expressionBody, semicolonToken, this.context);
		}

		public ParameterListSyntax ParameterList(SyntaxToken openParenToken, SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeParenToken)
		{
#if DEBUG
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
#endif

			var result = new ParameterListSyntax(SyntaxKind.ParameterList, openParenToken, parameters.Node, closeParenToken, this.context);

			return result;
		}

		public BracketedParameterListSyntax BracketedParameterList(SyntaxToken openBracketToken, SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeBracketToken)
		{
#if DEBUG
			if (openBracketToken == null)
				throw new ArgumentNullException(nameof(openBracketToken));
			switch (openBracketToken.Kind)
			{
				case SyntaxKind.OpenBracketToken:
					break;
				default:
					throw new ArgumentException(nameof(openBracketToken));
			}
			if (closeBracketToken == null)
				throw new ArgumentNullException(nameof(closeBracketToken));
			switch (closeBracketToken.Kind)
			{
				case SyntaxKind.CloseBracketToken:
					break;
				default:
					throw new ArgumentException(nameof(closeBracketToken));
			}
#endif
			var result = new BracketedParameterListSyntax(SyntaxKind.BracketedParameterList, openBracketToken, parameters.Node, closeBracketToken, this.context);

			return result;
		}

		public ParameterSyntax Parameter(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax @default)
		{
#if DEBUG
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
				case SyntaxKind.ArgListKeyword:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
#endif

			return new ParameterSyntax(SyntaxKind.Parameter, attributeLists.Node, modifiers.Node, type, identifier, @default, this.context);
		}

		public IncompleteMemberSyntax IncompleteMember(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, TypeSyntax type)
		{
#if DEBUG
#endif

			return new IncompleteMemberSyntax(SyntaxKind.IncompleteMember, attributeLists.Node, modifiers.Node, type, this.context);
		}

		public SkippedTokensTriviaSyntax SkippedTokensTrivia(SyntaxList<SyntaxToken> tokens)
		{
#if DEBUG
#endif

			return new SkippedTokensTriviaSyntax(SyntaxKind.SkippedTokensTrivia, tokens.Node, this.context);
		}

		public TypeCrefSyntax TypeCref(TypeSyntax type)
		{
#if DEBUG
			if (type == null)
				throw new ArgumentNullException(nameof(type));
#endif
			var result = new TypeCrefSyntax(SyntaxKind.TypeCref, type, this.context);

			return result;
		}

		public QualifiedCrefSyntax QualifiedCref(TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member)
		{
#if DEBUG
			if (container == null)
				throw new ArgumentNullException(nameof(container));
			if (dotToken == null)
				throw new ArgumentNullException(nameof(dotToken));
			switch (dotToken.Kind)
			{
				case SyntaxKind.DotToken:
					break;
				default:
					throw new ArgumentException(nameof(dotToken));
			}
			if (member == null)
				throw new ArgumentNullException(nameof(member));
#endif
			var result = new QualifiedCrefSyntax(SyntaxKind.QualifiedCref, container, dotToken, member, this.context);

			return result;
		}

		public NameMemberCrefSyntax NameMemberCref(TypeSyntax name, CrefParameterListSyntax parameters)
		{
#if DEBUG
			if (name == null)
				throw new ArgumentNullException(nameof(name));
#endif
			var result = new NameMemberCrefSyntax(SyntaxKind.NameMemberCref, name, parameters, this.context);

			return result;
		}

		public IndexerMemberCrefSyntax IndexerMemberCref(SyntaxToken thisKeyword, CrefBracketedParameterListSyntax parameters)
		{
#if DEBUG
			if (thisKeyword == null)
				throw new ArgumentNullException(nameof(thisKeyword));
			switch (thisKeyword.Kind)
			{
				case SyntaxKind.ThisKeyword:
					break;
				default:
					throw new ArgumentException(nameof(thisKeyword));
			}
#endif
			var result = new IndexerMemberCrefSyntax(SyntaxKind.IndexerMemberCref, thisKeyword, parameters, this.context);

			return result;
		}

		public OperatorMemberCrefSyntax OperatorMemberCref(SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax parameters)
		{
#if DEBUG
			if (operatorKeyword == null)
				throw new ArgumentNullException(nameof(operatorKeyword));
			switch (operatorKeyword.Kind)
			{
				case SyntaxKind.OperatorKeyword:
					break;
				default:
					throw new ArgumentException(nameof(operatorKeyword));
			}
			if (operatorToken == null)
				throw new ArgumentNullException(nameof(operatorToken));
			switch (operatorToken.Kind)
			{
				case SyntaxKind.PlusToken:
				case SyntaxKind.MinusToken:
				case SyntaxKind.ExclamationToken:
				case SyntaxKind.TildeToken:
				case SyntaxKind.PlusPlusToken:
				case SyntaxKind.MinusMinusToken:
				case SyntaxKind.AsteriskToken:
				case SyntaxKind.SlashToken:
				case SyntaxKind.PercentToken:
				case SyntaxKind.LessThanLessThanToken:
				case SyntaxKind.GreaterThanGreaterThanToken:
				case SyntaxKind.BarToken:
				case SyntaxKind.AmpersandToken:
				case SyntaxKind.CaretToken:
				case SyntaxKind.EqualsEqualsToken:
				case SyntaxKind.ExclamationEqualsToken:
				case SyntaxKind.LessThanToken:
				case SyntaxKind.LessThanEqualsToken:
				case SyntaxKind.GreaterThanToken:
				case SyntaxKind.GreaterThanEqualsToken:
				case SyntaxKind.FalseKeyword:
				case SyntaxKind.TrueKeyword:
					break;
				default:
					throw new ArgumentException(nameof(operatorToken));
			}
#endif

			var result = new OperatorMemberCrefSyntax(SyntaxKind.OperatorMemberCref, operatorKeyword, operatorToken, parameters, this.context);

			return result;
		}

		public ConversionOperatorMemberCrefSyntax ConversionOperatorMemberCref(SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax parameters)
		{
#if DEBUG
			if (implicitOrExplicitKeyword == null)
				throw new ArgumentNullException(nameof(implicitOrExplicitKeyword));
			switch (implicitOrExplicitKeyword.Kind)
			{
				case SyntaxKind.ImplicitKeyword:
				case SyntaxKind.ExplicitKeyword:
					break;
				default:
					throw new ArgumentException(nameof(implicitOrExplicitKeyword));
			}
			if (operatorKeyword == null)
				throw new ArgumentNullException(nameof(operatorKeyword));
			switch (operatorKeyword.Kind)
			{
				case SyntaxKind.OperatorKeyword:
					break;
				default:
					throw new ArgumentException(nameof(operatorKeyword));
			}
			if (type == null)
				throw new ArgumentNullException(nameof(type));
#endif

			return new ConversionOperatorMemberCrefSyntax(SyntaxKind.ConversionOperatorMemberCref, implicitOrExplicitKeyword, operatorKeyword, type, parameters, this.context);
		}

		public CrefParameterListSyntax CrefParameterList(SyntaxToken openParenToken, SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeParenToken)
		{
#if DEBUG
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
#endif
			var result = new CrefParameterListSyntax(SyntaxKind.CrefParameterList, openParenToken, parameters.Node, closeParenToken, this.context);
			return result;
		}

		public CrefBracketedParameterListSyntax CrefBracketedParameterList(SyntaxToken openBracketToken, SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeBracketToken)
		{
#if DEBUG
			if (openBracketToken == null)
				throw new ArgumentNullException(nameof(openBracketToken));
			switch (openBracketToken.Kind)
			{
				case SyntaxKind.OpenBracketToken:
					break;
				default:
					throw new ArgumentException(nameof(openBracketToken));
			}
			if (closeBracketToken == null)
				throw new ArgumentNullException(nameof(closeBracketToken));
			switch (closeBracketToken.Kind)
			{
				case SyntaxKind.CloseBracketToken:
					break;
				default:
					throw new ArgumentException(nameof(closeBracketToken));
			}
#endif
			var result = new CrefBracketedParameterListSyntax(SyntaxKind.CrefBracketedParameterList, openBracketToken, parameters.Node, closeBracketToken, this.context);

			return result;
		}

		public CrefParameterSyntax CrefParameter(SyntaxToken refKindKeyword, TypeSyntax type)
		{
#if DEBUG
			if (refKindKeyword != null)
			{
				switch (refKindKeyword.Kind)
				{
					case SyntaxKind.RefKeyword:
					case SyntaxKind.OutKeyword:
					case SyntaxKind.InKeyword:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(refKindKeyword));
				}
			}
			if (type == null)
				throw new ArgumentNullException(nameof(type));
#endif
			var result = new CrefParameterSyntax(SyntaxKind.CrefParameter, refKindKeyword, type, this.context);
			return result;
		}

		public IfDirectiveTriviaSyntax IfDirectiveTrivia(SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
		{
#if DEBUG
			if (hashToken == null)
				throw new ArgumentNullException(nameof(hashToken));
			switch (hashToken.Kind)
			{
				case SyntaxKind.HashToken:
					break;
				default:
					throw new ArgumentException(nameof(hashToken));
			}
			if (ifKeyword == null)
				throw new ArgumentNullException(nameof(ifKeyword));
			switch (ifKeyword.Kind)
			{
				case SyntaxKind.IfKeyword:
					break;
				default:
					throw new ArgumentException(nameof(ifKeyword));
			}
			if (condition == null)
				throw new ArgumentNullException(nameof(condition));
			if (endOfDirectiveToken == null)
				throw new ArgumentNullException(nameof(endOfDirectiveToken));
			switch (endOfDirectiveToken.Kind)
			{
				case SyntaxKind.EndOfDirectiveToken:
					break;
				default:
					throw new ArgumentException(nameof(endOfDirectiveToken));
			}
#endif

			return new IfDirectiveTriviaSyntax(SyntaxKind.IfDirectiveTrivia, hashToken, ifKeyword, condition, endOfDirectiveToken, isActive, branchTaken, conditionValue, this.context);
		}

		public ElifDirectiveTriviaSyntax ElifDirectiveTrivia(SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
		{
#if DEBUG
			if (hashToken == null)
				throw new ArgumentNullException(nameof(hashToken));
			switch (hashToken.Kind)
			{
				case SyntaxKind.HashToken:
					break;
				default:
					throw new ArgumentException(nameof(hashToken));
			}
			if (elifKeyword == null)
				throw new ArgumentNullException(nameof(elifKeyword));
			switch (elifKeyword.Kind)
			{
				case SyntaxKind.ElifKeyword:
					break;
				default:
					throw new ArgumentException(nameof(elifKeyword));
			}
			if (condition == null)
				throw new ArgumentNullException(nameof(condition));
			if (endOfDirectiveToken == null)
				throw new ArgumentNullException(nameof(endOfDirectiveToken));
			switch (endOfDirectiveToken.Kind)
			{
				case SyntaxKind.EndOfDirectiveToken:
					break;
				default:
					throw new ArgumentException(nameof(endOfDirectiveToken));
			}
#endif

			return new ElifDirectiveTriviaSyntax(SyntaxKind.ElifDirectiveTrivia, hashToken, elifKeyword, condition, endOfDirectiveToken, isActive, branchTaken, conditionValue, this.context);
		}

		public ElseDirectiveTriviaSyntax ElseDirectiveTrivia(SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken)
		{
#if DEBUG
			if (hashToken == null)
				throw new ArgumentNullException(nameof(hashToken));
			switch (hashToken.Kind)
			{
				case SyntaxKind.HashToken:
					break;
				default:
					throw new ArgumentException(nameof(hashToken));
			}
			if (elseKeyword == null)
				throw new ArgumentNullException(nameof(elseKeyword));
			switch (elseKeyword.Kind)
			{
				case SyntaxKind.ElseKeyword:
					break;
				default:
					throw new ArgumentException(nameof(elseKeyword));
			}
			if (endOfDirectiveToken == null)
				throw new ArgumentNullException(nameof(endOfDirectiveToken));
			switch (endOfDirectiveToken.Kind)
			{
				case SyntaxKind.EndOfDirectiveToken:
					break;
				default:
					throw new ArgumentException(nameof(endOfDirectiveToken));
			}
#endif

			return new ElseDirectiveTriviaSyntax(SyntaxKind.ElseDirectiveTrivia, hashToken, elseKeyword, endOfDirectiveToken, isActive, branchTaken, this.context);
		}

		public EndIfDirectiveTriviaSyntax EndIfDirectiveTrivia(SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
		{
#if DEBUG
			if (hashToken == null)
				throw new ArgumentNullException(nameof(hashToken));
			switch (hashToken.Kind)
			{
				case SyntaxKind.HashToken:
					break;
				default:
					throw new ArgumentException(nameof(hashToken));
			}
			if (endIfKeyword == null)
				throw new ArgumentNullException(nameof(endIfKeyword));
			switch (endIfKeyword.Kind)
			{
				case SyntaxKind.EndIfKeyword:
					break;
				default:
					throw new ArgumentException(nameof(endIfKeyword));
			}
			if (endOfDirectiveToken == null)
				throw new ArgumentNullException(nameof(endOfDirectiveToken));
			switch (endOfDirectiveToken.Kind)
			{
				case SyntaxKind.EndOfDirectiveToken:
					break;
				default:
					throw new ArgumentException(nameof(endOfDirectiveToken));
			}
#endif

			return new EndIfDirectiveTriviaSyntax(SyntaxKind.EndIfDirectiveTrivia, hashToken, endIfKeyword, endOfDirectiveToken, isActive, this.context);
		}

		public RegionDirectiveTriviaSyntax RegionDirectiveTrivia(SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
		{
#if DEBUG
			if (hashToken == null)
				throw new ArgumentNullException(nameof(hashToken));
			switch (hashToken.Kind)
			{
				case SyntaxKind.HashToken:
					break;
				default:
					throw new ArgumentException(nameof(hashToken));
			}
			if (regionKeyword == null)
				throw new ArgumentNullException(nameof(regionKeyword));
			switch (regionKeyword.Kind)
			{
				case SyntaxKind.RegionKeyword:
					break;
				default:
					throw new ArgumentException(nameof(regionKeyword));
			}
			if (endOfDirectiveToken == null)
				throw new ArgumentNullException(nameof(endOfDirectiveToken));
			switch (endOfDirectiveToken.Kind)
			{
				case SyntaxKind.EndOfDirectiveToken:
					break;
				default:
					throw new ArgumentException(nameof(endOfDirectiveToken));
			}
#endif

			return new RegionDirectiveTriviaSyntax(SyntaxKind.RegionDirectiveTrivia, hashToken, regionKeyword, endOfDirectiveToken, isActive, this.context);
		}

		public EndRegionDirectiveTriviaSyntax EndRegionDirectiveTrivia(SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
		{
#if DEBUG
			if (hashToken == null)
				throw new ArgumentNullException(nameof(hashToken));
			switch (hashToken.Kind)
			{
				case SyntaxKind.HashToken:
					break;
				default:
					throw new ArgumentException(nameof(hashToken));
			}
			if (endRegionKeyword == null)
				throw new ArgumentNullException(nameof(endRegionKeyword));
			switch (endRegionKeyword.Kind)
			{
				case SyntaxKind.EndRegionKeyword:
					break;
				default:
					throw new ArgumentException(nameof(endRegionKeyword));
			}
			if (endOfDirectiveToken == null)
				throw new ArgumentNullException(nameof(endOfDirectiveToken));
			switch (endOfDirectiveToken.Kind)
			{
				case SyntaxKind.EndOfDirectiveToken:
					break;
				default:
					throw new ArgumentException(nameof(endOfDirectiveToken));
			}
#endif

			return new EndRegionDirectiveTriviaSyntax(SyntaxKind.EndRegionDirectiveTrivia, hashToken, endRegionKeyword, endOfDirectiveToken, isActive, this.context);
		}

		public ErrorDirectiveTriviaSyntax ErrorDirectiveTrivia(SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
		{
#if DEBUG
			if (hashToken == null)
				throw new ArgumentNullException(nameof(hashToken));
			switch (hashToken.Kind)
			{
				case SyntaxKind.HashToken:
					break;
				default:
					throw new ArgumentException(nameof(hashToken));
			}
			if (errorKeyword == null)
				throw new ArgumentNullException(nameof(errorKeyword));
			switch (errorKeyword.Kind)
			{
				case SyntaxKind.ErrorKeyword:
					break;
				default:
					throw new ArgumentException(nameof(errorKeyword));
			}
			if (endOfDirectiveToken == null)
				throw new ArgumentNullException(nameof(endOfDirectiveToken));
			switch (endOfDirectiveToken.Kind)
			{
				case SyntaxKind.EndOfDirectiveToken:
					break;
				default:
					throw new ArgumentException(nameof(endOfDirectiveToken));
			}
#endif

			return new ErrorDirectiveTriviaSyntax(SyntaxKind.ErrorDirectiveTrivia, hashToken, errorKeyword, endOfDirectiveToken, isActive, this.context);
		}

		public WarningDirectiveTriviaSyntax WarningDirectiveTrivia(SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
		{
#if DEBUG
			if (hashToken == null)
				throw new ArgumentNullException(nameof(hashToken));
			switch (hashToken.Kind)
			{
				case SyntaxKind.HashToken:
					break;
				default:
					throw new ArgumentException(nameof(hashToken));
			}
			if (warningKeyword == null)
				throw new ArgumentNullException(nameof(warningKeyword));
			switch (warningKeyword.Kind)
			{
				case SyntaxKind.WarningKeyword:
					break;
				default:
					throw new ArgumentException(nameof(warningKeyword));
			}
			if (endOfDirectiveToken == null)
				throw new ArgumentNullException(nameof(endOfDirectiveToken));
			switch (endOfDirectiveToken.Kind)
			{
				case SyntaxKind.EndOfDirectiveToken:
					break;
				default:
					throw new ArgumentException(nameof(endOfDirectiveToken));
			}
#endif

			return new WarningDirectiveTriviaSyntax(SyntaxKind.WarningDirectiveTrivia, hashToken, warningKeyword, endOfDirectiveToken, isActive, this.context);
		}

		public BadDirectiveTriviaSyntax BadDirectiveTrivia(SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive)
		{
#if DEBUG
			if (hashToken == null)
				throw new ArgumentNullException(nameof(hashToken));
			switch (hashToken.Kind)
			{
				case SyntaxKind.HashToken:
					break;
				default:
					throw new ArgumentException(nameof(hashToken));
			}
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			if (endOfDirectiveToken == null)
				throw new ArgumentNullException(nameof(endOfDirectiveToken));
			switch (endOfDirectiveToken.Kind)
			{
				case SyntaxKind.EndOfDirectiveToken:
					break;
				default:
					throw new ArgumentException(nameof(endOfDirectiveToken));
			}
#endif

			return new BadDirectiveTriviaSyntax(SyntaxKind.BadDirectiveTrivia, hashToken, identifier, endOfDirectiveToken, isActive, this.context);
		}

		public DefineDirectiveTriviaSyntax DefineDirectiveTrivia(SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
		{
#if DEBUG
			if (hashToken == null)
				throw new ArgumentNullException(nameof(hashToken));
			switch (hashToken.Kind)
			{
				case SyntaxKind.HashToken:
					break;
				default:
					throw new ArgumentException(nameof(hashToken));
			}
			if (defineKeyword == null)
				throw new ArgumentNullException(nameof(defineKeyword));
			switch (defineKeyword.Kind)
			{
				case SyntaxKind.DefineKeyword:
					break;
				default:
					throw new ArgumentException(nameof(defineKeyword));
			}
			if (name == null)
				throw new ArgumentNullException(nameof(name));
			switch (name.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(name));
			}
			if (endOfDirectiveToken == null)
				throw new ArgumentNullException(nameof(endOfDirectiveToken));
			switch (endOfDirectiveToken.Kind)
			{
				case SyntaxKind.EndOfDirectiveToken:
					break;
				default:
					throw new ArgumentException(nameof(endOfDirectiveToken));
			}
#endif

			return new DefineDirectiveTriviaSyntax(SyntaxKind.DefineDirectiveTrivia, hashToken, defineKeyword, name, endOfDirectiveToken, isActive, this.context);
		}

		public UndefDirectiveTriviaSyntax UndefDirectiveTrivia(SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
		{
#if DEBUG
			if (hashToken == null)
				throw new ArgumentNullException(nameof(hashToken));
			switch (hashToken.Kind)
			{
				case SyntaxKind.HashToken:
					break;
				default:
					throw new ArgumentException(nameof(hashToken));
			}
			if (undefKeyword == null)
				throw new ArgumentNullException(nameof(undefKeyword));
			switch (undefKeyword.Kind)
			{
				case SyntaxKind.UndefKeyword:
					break;
				default:
					throw new ArgumentException(nameof(undefKeyword));
			}
			if (name == null)
				throw new ArgumentNullException(nameof(name));
			switch (name.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(name));
			}
			if (endOfDirectiveToken == null)
				throw new ArgumentNullException(nameof(endOfDirectiveToken));
			switch (endOfDirectiveToken.Kind)
			{
				case SyntaxKind.EndOfDirectiveToken:
					break;
				default:
					throw new ArgumentException(nameof(endOfDirectiveToken));
			}
#endif

			return new UndefDirectiveTriviaSyntax(SyntaxKind.UndefDirectiveTrivia, hashToken, undefKeyword, name, endOfDirectiveToken, isActive, this.context);
		}

		public LineDirectiveTriviaSyntax LineDirectiveTrivia(SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
		{
#if DEBUG
			if (hashToken == null)
				throw new ArgumentNullException(nameof(hashToken));
			switch (hashToken.Kind)
			{
				case SyntaxKind.HashToken:
					break;
				default:
					throw new ArgumentException(nameof(hashToken));
			}
			if (lineKeyword == null)
				throw new ArgumentNullException(nameof(lineKeyword));
			switch (lineKeyword.Kind)
			{
				case SyntaxKind.LineKeyword:
					break;
				default:
					throw new ArgumentException(nameof(lineKeyword));
			}
			if (line == null)
				throw new ArgumentNullException(nameof(line));
			switch (line.Kind)
			{
				case SyntaxKind.NumericLiteralToken:
				case SyntaxKind.DefaultKeyword:
				case SyntaxKind.HiddenKeyword:
					break;
				default:
					throw new ArgumentException(nameof(line));
			}
			if (file != null)
			{
				switch (file.Kind)
				{
					case SyntaxKind.StringLiteralToken:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(file));
				}
			}
			if (endOfDirectiveToken == null)
				throw new ArgumentNullException(nameof(endOfDirectiveToken));
			switch (endOfDirectiveToken.Kind)
			{
				case SyntaxKind.EndOfDirectiveToken:
					break;
				default:
					throw new ArgumentException(nameof(endOfDirectiveToken));
			}
#endif

			return new LineDirectiveTriviaSyntax(SyntaxKind.LineDirectiveTrivia, hashToken, lineKeyword, line, file, endOfDirectiveToken, isActive, this.context);
		}

		public PragmaWarningDirectiveTriviaSyntax PragmaWarningDirectiveTrivia(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, SyntaxToken nullableKeyword, SeparatedSyntaxList<ExpressionSyntax> errorCodes, SyntaxToken endOfDirectiveToken, bool isActive)
		{
#if DEBUG
			if (hashToken == null)
				throw new ArgumentNullException(nameof(hashToken));
			switch (hashToken.Kind)
			{
				case SyntaxKind.HashToken:
					break;
				default:
					throw new ArgumentException(nameof(hashToken));
			}
			if (pragmaKeyword == null)
				throw new ArgumentNullException(nameof(pragmaKeyword));
			switch (pragmaKeyword.Kind)
			{
				case SyntaxKind.PragmaKeyword:
					break;
				default:
					throw new ArgumentException(nameof(pragmaKeyword));
			}
			if (warningKeyword == null)
				throw new ArgumentNullException(nameof(warningKeyword));
			switch (warningKeyword.Kind)
			{
				case SyntaxKind.WarningKeyword:
					break;
				default:
					throw new ArgumentException(nameof(warningKeyword));
			}
			if (disableOrRestoreKeyword == null)
				throw new ArgumentNullException(nameof(disableOrRestoreKeyword));
			switch (disableOrRestoreKeyword.Kind)
			{
				case SyntaxKind.DisableKeyword:
				case SyntaxKind.RestoreKeyword:
				case SyntaxKind.EnableKeyword:
				case SyntaxKind.SafeOnlyKeyword:
					break;
				default:
					throw new ArgumentException(nameof(disableOrRestoreKeyword));
			}
			if (nullableKeyword != null)
			{
				switch (nullableKeyword.Kind)
				{
					case SyntaxKind.NullableKeyword:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(nullableKeyword));
				}
			}
			if (endOfDirectiveToken == null)
				throw new ArgumentNullException(nameof(endOfDirectiveToken));
			switch (endOfDirectiveToken.Kind)
			{
				case SyntaxKind.EndOfDirectiveToken:
					break;
				default:
					throw new ArgumentException(nameof(endOfDirectiveToken));
			}
#endif

			return new PragmaWarningDirectiveTriviaSyntax(SyntaxKind.PragmaWarningDirectiveTrivia, hashToken, pragmaKeyword, warningKeyword, disableOrRestoreKeyword, nullableKeyword, errorCodes.Node, endOfDirectiveToken, isActive, this.context);
		}

		public PragmaChecksumDirectiveTriviaSyntax PragmaChecksumDirectiveTrivia(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive)
		{
#if DEBUG
			if (hashToken == null)
				throw new ArgumentNullException(nameof(hashToken));
			switch (hashToken.Kind)
			{
				case SyntaxKind.HashToken:
					break;
				default:
					throw new ArgumentException(nameof(hashToken));
			}
			if (pragmaKeyword == null)
				throw new ArgumentNullException(nameof(pragmaKeyword));
			switch (pragmaKeyword.Kind)
			{
				case SyntaxKind.PragmaKeyword:
					break;
				default:
					throw new ArgumentException(nameof(pragmaKeyword));
			}
			if (checksumKeyword == null)
				throw new ArgumentNullException(nameof(checksumKeyword));
			switch (checksumKeyword.Kind)
			{
				case SyntaxKind.ChecksumKeyword:
					break;
				default:
					throw new ArgumentException(nameof(checksumKeyword));
			}
			if (file == null)
				throw new ArgumentNullException(nameof(file));
			switch (file.Kind)
			{
				case SyntaxKind.StringLiteralToken:
					break;
				default:
					throw new ArgumentException(nameof(file));
			}
			if (guid == null)
				throw new ArgumentNullException(nameof(guid));
			switch (guid.Kind)
			{
				case SyntaxKind.StringLiteralToken:
					break;
				default:
					throw new ArgumentException(nameof(guid));
			}
			if (bytes == null)
				throw new ArgumentNullException(nameof(bytes));
			switch (bytes.Kind)
			{
				case SyntaxKind.StringLiteralToken:
					break;
				default:
					throw new ArgumentException(nameof(bytes));
			}
			if (endOfDirectiveToken == null)
				throw new ArgumentNullException(nameof(endOfDirectiveToken));
			switch (endOfDirectiveToken.Kind)
			{
				case SyntaxKind.EndOfDirectiveToken:
					break;
				default:
					throw new ArgumentException(nameof(endOfDirectiveToken));
			}
#endif

			return new PragmaChecksumDirectiveTriviaSyntax(SyntaxKind.PragmaChecksumDirectiveTrivia, hashToken, pragmaKeyword, checksumKeyword, file, guid, bytes, endOfDirectiveToken, isActive, this.context);
		}

		public ReferenceDirectiveTriviaSyntax ReferenceDirectiveTrivia(SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
		{
#if DEBUG
			if (hashToken == null)
				throw new ArgumentNullException(nameof(hashToken));
			switch (hashToken.Kind)
			{
				case SyntaxKind.HashToken:
					break;
				default:
					throw new ArgumentException(nameof(hashToken));
			}
			if (referenceKeyword == null)
				throw new ArgumentNullException(nameof(referenceKeyword));
			switch (referenceKeyword.Kind)
			{
				case SyntaxKind.ReferenceKeyword:
					break;
				default:
					throw new ArgumentException(nameof(referenceKeyword));
			}
			if (file == null)
				throw new ArgumentNullException(nameof(file));
			switch (file.Kind)
			{
				case SyntaxKind.StringLiteralToken:
					break;
				default:
					throw new ArgumentException(nameof(file));
			}
			if (endOfDirectiveToken == null)
				throw new ArgumentNullException(nameof(endOfDirectiveToken));
			switch (endOfDirectiveToken.Kind)
			{
				case SyntaxKind.EndOfDirectiveToken:
					break;
				default:
					throw new ArgumentException(nameof(endOfDirectiveToken));
			}
#endif

			return new ReferenceDirectiveTriviaSyntax(SyntaxKind.ReferenceDirectiveTrivia, hashToken, referenceKeyword, file, endOfDirectiveToken, isActive, this.context);
		}

		public LoadDirectiveTriviaSyntax LoadDirectiveTrivia(SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
		{
#if DEBUG
			if (hashToken == null)
				throw new ArgumentNullException(nameof(hashToken));
			switch (hashToken.Kind)
			{
				case SyntaxKind.HashToken:
					break;
				default:
					throw new ArgumentException(nameof(hashToken));
			}
			if (loadKeyword == null)
				throw new ArgumentNullException(nameof(loadKeyword));
			switch (loadKeyword.Kind)
			{
				case SyntaxKind.LoadKeyword:
					break;
				default:
					throw new ArgumentException(nameof(loadKeyword));
			}
			if (file == null)
				throw new ArgumentNullException(nameof(file));
			switch (file.Kind)
			{
				case SyntaxKind.StringLiteralToken:
					break;
				default:
					throw new ArgumentException(nameof(file));
			}
			if (endOfDirectiveToken == null)
				throw new ArgumentNullException(nameof(endOfDirectiveToken));
			switch (endOfDirectiveToken.Kind)
			{
				case SyntaxKind.EndOfDirectiveToken:
					break;
				default:
					throw new ArgumentException(nameof(endOfDirectiveToken));
			}
#endif

			return new LoadDirectiveTriviaSyntax(SyntaxKind.LoadDirectiveTrivia, hashToken, loadKeyword, file, endOfDirectiveToken, isActive, this.context);
		}

		public ShebangDirectiveTriviaSyntax ShebangDirectiveTrivia(SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive)
		{
#if DEBUG
			if (hashToken == null)
				throw new ArgumentNullException(nameof(hashToken));
			switch (hashToken.Kind)
			{
				case SyntaxKind.HashToken:
					break;
				default:
					throw new ArgumentException(nameof(hashToken));
			}
			if (exclamationToken == null)
				throw new ArgumentNullException(nameof(exclamationToken));
			switch (exclamationToken.Kind)
			{
				case SyntaxKind.ExclamationToken:
					break;
				default:
					throw new ArgumentException(nameof(exclamationToken));
			}
			if (endOfDirectiveToken == null)
				throw new ArgumentNullException(nameof(endOfDirectiveToken));
			switch (endOfDirectiveToken.Kind)
			{
				case SyntaxKind.EndOfDirectiveToken:
					break;
				default:
					throw new ArgumentException(nameof(endOfDirectiveToken));
			}
#endif

			return new ShebangDirectiveTriviaSyntax(SyntaxKind.ShebangDirectiveTrivia, hashToken, exclamationToken, endOfDirectiveToken, isActive, this.context);
		}

		public NullableDirectiveTriviaSyntax NullableDirectiveTrivia(SyntaxToken hashToken, SyntaxToken nullableKeyword, SyntaxToken settingToken, SyntaxToken endOfDirectiveToken, bool isActive)
		{
#if DEBUG
			if (hashToken == null)
				throw new ArgumentNullException(nameof(hashToken));
			switch (hashToken.Kind)
			{
				case SyntaxKind.HashToken:
					break;
				default:
					throw new ArgumentException(nameof(hashToken));
			}
			if (nullableKeyword == null)
				throw new ArgumentNullException(nameof(nullableKeyword));
			switch (nullableKeyword.Kind)
			{
				case SyntaxKind.NullableKeyword:
					break;
				default:
					throw new ArgumentException(nameof(nullableKeyword));
			}
			if (settingToken == null)
				throw new ArgumentNullException(nameof(settingToken));
			switch (settingToken.Kind)
			{
				case SyntaxKind.EnableKeyword:
				case SyntaxKind.DisableKeyword:
				case SyntaxKind.RestoreKeyword:
				case SyntaxKind.SafeOnlyKeyword:
					break;
				default:
					throw new ArgumentException(nameof(settingToken));
			}
			if (endOfDirectiveToken == null)
				throw new ArgumentNullException(nameof(endOfDirectiveToken));
			switch (endOfDirectiveToken.Kind)
			{
				case SyntaxKind.EndOfDirectiveToken:
					break;
				default:
					throw new ArgumentException(nameof(endOfDirectiveToken));
			}
#endif

			return new NullableDirectiveTriviaSyntax(SyntaxKind.NullableDirectiveTrivia, hashToken, nullableKeyword, settingToken, endOfDirectiveToken, isActive, this.context);
		}
	}

	public static partial class SyntaxFactory
	{
		public static IdentifierNameSyntax IdentifierName(SyntaxToken identifier)
		{
#if DEBUG
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
				case SyntaxKind.GlobalKeyword:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
#endif

			var result = new IdentifierNameSyntax(SyntaxKind.IdentifierName, identifier);

			return result;
		}

		public static QualifiedNameSyntax QualifiedName(NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right)
		{
#if DEBUG
			if (left == null)
				throw new ArgumentNullException(nameof(left));
			if (dotToken == null)
				throw new ArgumentNullException(nameof(dotToken));
			switch (dotToken.Kind)
			{
				case SyntaxKind.DotToken:
					break;
				default:
					throw new ArgumentException(nameof(dotToken));
			}
			if (right == null)
				throw new ArgumentNullException(nameof(right));
#endif
			var result = new QualifiedNameSyntax(SyntaxKind.QualifiedName, left, dotToken, right);

			return result;
		}

		public static GenericNameSyntax GenericName(SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList)
		{
#if DEBUG
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
			if (typeArgumentList == null)
				throw new ArgumentNullException(nameof(typeArgumentList));
#endif
			var result = new GenericNameSyntax(SyntaxKind.GenericName, identifier, typeArgumentList);
			return result;
		}

		public static TypeArgumentListSyntax TypeArgumentList(SyntaxToken lessThanToken, SeparatedSyntaxList<TypeSyntax> arguments, SyntaxToken greaterThanToken)
		{
#if DEBUG
			if (lessThanToken == null)
				throw new ArgumentNullException(nameof(lessThanToken));
			switch (lessThanToken.Kind)
			{
				case SyntaxKind.LessThanToken:
					break;
				default:
					throw new ArgumentException(nameof(lessThanToken));
			}
			if (greaterThanToken == null)
				throw new ArgumentNullException(nameof(greaterThanToken));
			switch (greaterThanToken.Kind)
			{
				case SyntaxKind.GreaterThanToken:
					break;
				default:
					throw new ArgumentException(nameof(greaterThanToken));
			}
#endif
			var result = new TypeArgumentListSyntax(SyntaxKind.TypeArgumentList, lessThanToken, arguments.Node, greaterThanToken);
			return result;
		}

		public static AliasQualifiedNameSyntax AliasQualifiedName(IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name)
		{
#if DEBUG
			if (alias == null)
				throw new ArgumentNullException(nameof(alias));
			if (colonColonToken == null)
				throw new ArgumentNullException(nameof(colonColonToken));
			switch (colonColonToken.Kind)
			{
				case SyntaxKind.ColonColonToken:
					break;
				default:
					throw new ArgumentException(nameof(colonColonToken));
			}
			if (name == null)
				throw new ArgumentNullException(nameof(name));
#endif
			var result = new AliasQualifiedNameSyntax(SyntaxKind.AliasQualifiedName, alias, colonColonToken, name);

			return result;
		}

		public static PredefinedTypeSyntax PredefinedType(SyntaxToken keyword)
		{
#if DEBUG
			if (keyword == null)
				throw new ArgumentNullException(nameof(keyword));
			switch (keyword.Kind)
			{
				case SyntaxKind.BoolKeyword:
				case SyntaxKind.ByteKeyword:
				case SyntaxKind.SByteKeyword:
				case SyntaxKind.IntKeyword:
				case SyntaxKind.UIntKeyword:
				case SyntaxKind.ShortKeyword:
				case SyntaxKind.UShortKeyword:
				case SyntaxKind.LongKeyword:
				case SyntaxKind.ULongKeyword:
				case SyntaxKind.FloatKeyword:
				case SyntaxKind.DoubleKeyword:
				case SyntaxKind.DecimalKeyword:
				case SyntaxKind.StringKeyword:
				case SyntaxKind.CharKeyword:
				case SyntaxKind.ObjectKeyword:
				case SyntaxKind.VoidKeyword:
					break;
				default:
					throw new ArgumentException(nameof(keyword));
			}
#endif
			var result = new PredefinedTypeSyntax(SyntaxKind.PredefinedType, keyword);
			return result;
		}

		public static ArrayTypeSyntax ArrayType(TypeSyntax elementType, SyntaxList<ArrayRankSpecifierSyntax> rankSpecifiers)
		{
#if DEBUG
			if (elementType == null)
				throw new ArgumentNullException(nameof(elementType));
#endif
			var result = new ArrayTypeSyntax(SyntaxKind.ArrayType, elementType, rankSpecifiers.Node);

			return result;
		}

		public static ArrayRankSpecifierSyntax ArrayRankSpecifier(SyntaxToken openBracketToken, SeparatedSyntaxList<ExpressionSyntax> sizes, SyntaxToken closeBracketToken)
		{
#if DEBUG
			if (openBracketToken == null)
				throw new ArgumentNullException(nameof(openBracketToken));
			switch (openBracketToken.Kind)
			{
				case SyntaxKind.OpenBracketToken:
					break;
				default:
					throw new ArgumentException(nameof(openBracketToken));
			}
			if (closeBracketToken == null)
				throw new ArgumentNullException(nameof(closeBracketToken));
			switch (closeBracketToken.Kind)
			{
				case SyntaxKind.CloseBracketToken:
					break;
				default:
					throw new ArgumentException(nameof(closeBracketToken));
			}
#endif
			var result = new ArrayRankSpecifierSyntax(SyntaxKind.ArrayRankSpecifier, openBracketToken, sizes.Node, closeBracketToken);

			return result;
		}

		public static PointerTypeSyntax PointerType(TypeSyntax elementType, SyntaxToken asteriskToken)
		{
#if DEBUG
			if (elementType == null)
				throw new ArgumentNullException(nameof(elementType));
			if (asteriskToken == null)
				throw new ArgumentNullException(nameof(asteriskToken));
			switch (asteriskToken.Kind)
			{
				case SyntaxKind.AsteriskToken:
					break;
				default:
					throw new ArgumentException(nameof(asteriskToken));
			}
#endif
			var result = new PointerTypeSyntax(SyntaxKind.PointerType, elementType, asteriskToken);
			return result;
		}

		public static NullableTypeSyntax NullableType(TypeSyntax elementType, SyntaxToken questionToken)
		{
#if DEBUG
			if (elementType == null)
				throw new ArgumentNullException(nameof(elementType));
			if (questionToken == null)
				throw new ArgumentNullException(nameof(questionToken));
			switch (questionToken.Kind)
			{
				case SyntaxKind.QuestionToken:
					break;
				default:
					throw new ArgumentException(nameof(questionToken));
			}
#endif
			var result = new NullableTypeSyntax(SyntaxKind.NullableType, elementType, questionToken);
			return result;
		}

		public static TupleTypeSyntax TupleType(SyntaxToken openParenToken, SeparatedSyntaxList<TupleElementSyntax> elements, SyntaxToken closeParenToken)
		{
#if DEBUG
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
#endif
			var result = new TupleTypeSyntax(SyntaxKind.TupleType, openParenToken, elements.Node, closeParenToken);

			return result;
		}

		public static TupleElementSyntax TupleElement(TypeSyntax type, SyntaxToken identifier)
		{
#if DEBUG
			if (type == null)
				throw new ArgumentNullException(nameof(type));
			if (identifier != null)
			{
				switch (identifier.Kind)
				{
					case SyntaxKind.IdentifierToken:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(identifier));
				}
			}
#endif
			var result = new TupleElementSyntax(SyntaxKind.TupleElement, type, identifier);
			return result;
		}

		public static OmittedTypeArgumentSyntax OmittedTypeArgument(SyntaxToken omittedTypeArgumentToken)
		{
#if DEBUG
			if (omittedTypeArgumentToken == null)
				throw new ArgumentNullException(nameof(omittedTypeArgumentToken));
			switch (omittedTypeArgumentToken.Kind)
			{
				case SyntaxKind.OmittedTypeArgumentToken:
					break;
				default:
					throw new ArgumentException(nameof(omittedTypeArgumentToken));
			}
#endif

			var result = new OmittedTypeArgumentSyntax(SyntaxKind.OmittedTypeArgument, omittedTypeArgumentToken);

			return result;
		}

		public static RefTypeSyntax RefType(SyntaxToken refKeyword, SyntaxToken readOnlyKeyword, TypeSyntax type)
		{
#if DEBUG
			if (refKeyword == null)
				throw new ArgumentNullException(nameof(refKeyword));
			switch (refKeyword.Kind)
			{
				case SyntaxKind.RefKeyword:
					break;
				default:
					throw new ArgumentException(nameof(refKeyword));
			}
			if (readOnlyKeyword != null)
			{
				switch (readOnlyKeyword.Kind)
				{
					case SyntaxKind.ReadOnlyKeyword:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(readOnlyKeyword));
				}
			}
			if (type == null)
				throw new ArgumentNullException(nameof(type));
#endif
			var result = new RefTypeSyntax(SyntaxKind.RefType, refKeyword, readOnlyKeyword, type);

			return result;
		}

		public static ParenthesizedExpressionSyntax ParenthesizedExpression(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
		{
#if DEBUG
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
#endif
			var result = new ParenthesizedExpressionSyntax(SyntaxKind.ParenthesizedExpression, openParenToken, expression, closeParenToken);

			return result;
		}

		public static TupleExpressionSyntax TupleExpression(SyntaxToken openParenToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
		{
#if DEBUG
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
#endif
			var result = new TupleExpressionSyntax(SyntaxKind.TupleExpression, openParenToken, arguments.Node, closeParenToken);
			return result;
		}

		public static PrefixUnaryExpressionSyntax PrefixUnaryExpression(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand)
		{
			switch (kind)
			{
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.BitwiseNotExpression:
				case SyntaxKind.LogicalNotExpression:
				case SyntaxKind.PreIncrementExpression:
				case SyntaxKind.PreDecrementExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.PointerIndirectionExpression:
				case SyntaxKind.IndexExpression:
					break;
				default:
					throw new ArgumentException(nameof(kind));
			}
#if DEBUG
			if (operatorToken == null)
				throw new ArgumentNullException(nameof(operatorToken));
			switch (operatorToken.Kind)
			{
				case SyntaxKind.PlusToken:
				case SyntaxKind.MinusToken:
				case SyntaxKind.TildeToken:
				case SyntaxKind.ExclamationToken:
				case SyntaxKind.PlusPlusToken:
				case SyntaxKind.MinusMinusToken:
				case SyntaxKind.AmpersandToken:
				case SyntaxKind.AsteriskToken:
				case SyntaxKind.CaretToken:
					break;
				default:
					throw new ArgumentException(nameof(operatorToken));
			}
			if (operand == null)
				throw new ArgumentNullException(nameof(operand));
#endif

			var result = new PrefixUnaryExpressionSyntax(kind, operatorToken, operand);

			return result;
		}

		public static AwaitExpressionSyntax AwaitExpression(SyntaxToken awaitKeyword, ExpressionSyntax expression)
		{
#if DEBUG
			if (awaitKeyword == null)
				throw new ArgumentNullException(nameof(awaitKeyword));
			switch (awaitKeyword.Kind)
			{
				case SyntaxKind.AwaitKeyword:
					break;
				default:
					throw new ArgumentException(nameof(awaitKeyword));
			}
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
#endif

			var result = new AwaitExpressionSyntax(SyntaxKind.AwaitExpression, awaitKeyword, expression);
			return result;
		}

		public static PostfixUnaryExpressionSyntax PostfixUnaryExpression(SyntaxKind kind, ExpressionSyntax operand, SyntaxToken operatorToken)
		{
			switch (kind)
			{
				case SyntaxKind.PostIncrementExpression:
				case SyntaxKind.PostDecrementExpression:
				case SyntaxKind.SuppressNullableWarningExpression:
					break;
				default:
					throw new ArgumentException(nameof(kind));
			}
#if DEBUG
			if (operand == null)
				throw new ArgumentNullException(nameof(operand));
			if (operatorToken == null)
				throw new ArgumentNullException(nameof(operatorToken));
			switch (operatorToken.Kind)
			{
				case SyntaxKind.PlusPlusToken:
				case SyntaxKind.MinusMinusToken:
				case SyntaxKind.ExclamationToken:
					break;
				default:
					throw new ArgumentException(nameof(operatorToken));
			}
#endif

			var result = new PostfixUnaryExpressionSyntax(kind, operand, operatorToken);

			return result;
		}

		public static MemberAccessExpressionSyntax MemberAccessExpression(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name)
		{
			switch (kind)
			{
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.PointerMemberAccessExpression:
					break;
				default:
					throw new ArgumentException(nameof(kind));
			}
#if DEBUG
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
			if (operatorToken == null)
				throw new ArgumentNullException(nameof(operatorToken));
			switch (operatorToken.Kind)
			{
				case SyntaxKind.DotToken:
				case SyntaxKind.MinusGreaterThanToken:
					break;
				default:
					throw new ArgumentException(nameof(operatorToken));
			}
			if (name == null)
				throw new ArgumentNullException(nameof(name));
#endif

			var result = new MemberAccessExpressionSyntax(kind, expression, operatorToken, name);
			return result;
		}

		public static ConditionalAccessExpressionSyntax ConditionalAccessExpression(ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull)
		{
#if DEBUG
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
			if (operatorToken == null)
				throw new ArgumentNullException(nameof(operatorToken));
			switch (operatorToken.Kind)
			{
				case SyntaxKind.QuestionToken:
					break;
				default:
					throw new ArgumentException(nameof(operatorToken));
			}
			if (whenNotNull == null)
				throw new ArgumentNullException(nameof(whenNotNull));
#endif

			var result = new ConditionalAccessExpressionSyntax(SyntaxKind.ConditionalAccessExpression, expression, operatorToken, whenNotNull);
			return result;
		}

		public static MemberBindingExpressionSyntax MemberBindingExpression(SyntaxToken operatorToken, SimpleNameSyntax name)
		{
#if DEBUG
			if (operatorToken == null)
				throw new ArgumentNullException(nameof(operatorToken));
			switch (operatorToken.Kind)
			{
				case SyntaxKind.DotToken:
					break;
				default:
					throw new ArgumentException(nameof(operatorToken));
			}
			if (name == null)
				throw new ArgumentNullException(nameof(name));
#endif

			var result = new MemberBindingExpressionSyntax(SyntaxKind.MemberBindingExpression, operatorToken, name);

			return result;
		}

		public static ElementBindingExpressionSyntax ElementBindingExpression(BracketedArgumentListSyntax argumentList)
		{
#if DEBUG
			if (argumentList == null)
				throw new ArgumentNullException(nameof(argumentList));
#endif
			var result = new ElementBindingExpressionSyntax(SyntaxKind.ElementBindingExpression, argumentList);
			return result;
		}

		public static RangeExpressionSyntax RangeExpression(ExpressionSyntax leftOperand, SyntaxToken operatorToken, ExpressionSyntax rightOperand)
		{
#if DEBUG
			if (operatorToken == null)
				throw new ArgumentNullException(nameof(operatorToken));
			switch (operatorToken.Kind)
			{
				case SyntaxKind.DotDotToken:
					break;
				default:
					throw new ArgumentException(nameof(operatorToken));
			}
#endif
			var result = new RangeExpressionSyntax(SyntaxKind.RangeExpression, leftOperand, operatorToken, rightOperand);
			return result;
		}

		public static ImplicitElementAccessSyntax ImplicitElementAccess(BracketedArgumentListSyntax argumentList)
		{
#if DEBUG
			if (argumentList == null)
				throw new ArgumentNullException(nameof(argumentList));
#endif
			var result = new ImplicitElementAccessSyntax(SyntaxKind.ImplicitElementAccess, argumentList);
			return result;
		}

		public static BinaryExpressionSyntax BinaryExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
		{
			switch (kind)
			{
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.LogicalOrExpression:
				case SyntaxKind.LogicalAndExpression:
				case SyntaxKind.BitwiseOrExpression:
				case SyntaxKind.BitwiseAndExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.AsExpression:
				case SyntaxKind.CoalesceExpression:
					break;
				default:
					throw new ArgumentException(nameof(kind));
			}
#if DEBUG
			if (left == null)
				throw new ArgumentNullException(nameof(left));
			if (operatorToken == null)
				throw new ArgumentNullException(nameof(operatorToken));
			switch (operatorToken.Kind)
			{
				case SyntaxKind.PlusToken:
				case SyntaxKind.MinusToken:
				case SyntaxKind.AsteriskToken:
				case SyntaxKind.SlashToken:
				case SyntaxKind.PercentToken:
				case SyntaxKind.LessThanLessThanToken:
				case SyntaxKind.GreaterThanGreaterThanToken:
				case SyntaxKind.BarBarToken:
				case SyntaxKind.AmpersandAmpersandToken:
				case SyntaxKind.BarToken:
				case SyntaxKind.AmpersandToken:
				case SyntaxKind.CaretToken:
				case SyntaxKind.EqualsEqualsToken:
				case SyntaxKind.ExclamationEqualsToken:
				case SyntaxKind.LessThanToken:
				case SyntaxKind.LessThanEqualsToken:
				case SyntaxKind.GreaterThanToken:
				case SyntaxKind.GreaterThanEqualsToken:
				case SyntaxKind.IsKeyword:
				case SyntaxKind.AsKeyword:
				case SyntaxKind.QuestionQuestionToken:
					break;
				default:
					throw new ArgumentException(nameof(operatorToken));
			}
			if (right == null)
				throw new ArgumentNullException(nameof(right));
#endif
			var result = new BinaryExpressionSyntax(kind, left, operatorToken, right);
			return result;
		}

		public static AssignmentExpressionSyntax AssignmentExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
		{
			switch (kind)
			{
				case SyntaxKind.SimpleAssignmentExpression:
				case SyntaxKind.AddAssignmentExpression:
				case SyntaxKind.SubtractAssignmentExpression:
				case SyntaxKind.MultiplyAssignmentExpression:
				case SyntaxKind.DivideAssignmentExpression:
				case SyntaxKind.ModuloAssignmentExpression:
				case SyntaxKind.AndAssignmentExpression:
				case SyntaxKind.ExclusiveOrAssignmentExpression:
				case SyntaxKind.OrAssignmentExpression:
				case SyntaxKind.LeftShiftAssignmentExpression:
				case SyntaxKind.RightShiftAssignmentExpression:
				case SyntaxKind.CoalesceAssignmentExpression:
					break;
				default:
					throw new ArgumentException(nameof(kind));
			}
#if DEBUG
			if (left == null)
				throw new ArgumentNullException(nameof(left));
			if (operatorToken == null)
				throw new ArgumentNullException(nameof(operatorToken));
			switch (operatorToken.Kind)
			{
				case SyntaxKind.EqualsToken:
				case SyntaxKind.PlusEqualsToken:
				case SyntaxKind.MinusEqualsToken:
				case SyntaxKind.AsteriskEqualsToken:
				case SyntaxKind.SlashEqualsToken:
				case SyntaxKind.PercentEqualsToken:
				case SyntaxKind.AmpersandEqualsToken:
				case SyntaxKind.CaretEqualsToken:
				case SyntaxKind.BarEqualsToken:
				case SyntaxKind.LessThanLessThanEqualsToken:
				case SyntaxKind.GreaterThanGreaterThanEqualsToken:
				case SyntaxKind.QuestionQuestionEqualsToken:
					break;
				default:
					throw new ArgumentException(nameof(operatorToken));
			}
			if (right == null)
				throw new ArgumentNullException(nameof(right));
#endif
			var result = new AssignmentExpressionSyntax(kind, left, operatorToken, right);
			return result;
		}

		public static ConditionalExpressionSyntax ConditionalExpression(ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse)
		{
#if DEBUG
			if (condition == null)
				throw new ArgumentNullException(nameof(condition));
			if (questionToken == null)
				throw new ArgumentNullException(nameof(questionToken));
			switch (questionToken.Kind)
			{
				case SyntaxKind.QuestionToken:
					break;
				default:
					throw new ArgumentException(nameof(questionToken));
			}
			if (whenTrue == null)
				throw new ArgumentNullException(nameof(whenTrue));
			if (colonToken == null)
				throw new ArgumentNullException(nameof(colonToken));
			switch (colonToken.Kind)
			{
				case SyntaxKind.ColonToken:
					break;
				default:
					throw new ArgumentException(nameof(colonToken));
			}
			if (whenFalse == null)
				throw new ArgumentNullException(nameof(whenFalse));
#endif

			return new ConditionalExpressionSyntax(SyntaxKind.ConditionalExpression, condition, questionToken, whenTrue, colonToken, whenFalse);
		}

		public static ThisExpressionSyntax ThisExpression(SyntaxToken token)
		{
#if DEBUG
			if (token == null)
				throw new ArgumentNullException(nameof(token));
			switch (token.Kind)
			{
				case SyntaxKind.ThisKeyword:
					break;
				default:
					throw new ArgumentException(nameof(token));
			}
#endif
			var result = new ThisExpressionSyntax(SyntaxKind.ThisExpression, token);
			return result;
		}

		public static BaseExpressionSyntax BaseExpression(SyntaxToken token)
		{
#if DEBUG
			if (token == null)
				throw new ArgumentNullException(nameof(token));
			switch (token.Kind)
			{
				case SyntaxKind.BaseKeyword:
					break;
				default:
					throw new ArgumentException(nameof(token));
			}
#endif
			var result = new BaseExpressionSyntax(SyntaxKind.BaseExpression, token);

			return result;
		}

		public static LiteralExpressionSyntax LiteralExpression(SyntaxKind kind, SyntaxToken token)
		{
			switch (kind)
			{
				case SyntaxKind.ArgListExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NullLiteralExpression:
				case SyntaxKind.DefaultLiteralExpression:
					break;
				default:
					throw new ArgumentException(nameof(kind));
			}
#if DEBUG
			if (token == null)
				throw new ArgumentNullException(nameof(token));
			switch (token.Kind)
			{
				case SyntaxKind.ArgListKeyword:
				case SyntaxKind.NumericLiteralToken:
				case SyntaxKind.StringLiteralToken:
				case SyntaxKind.CharacterLiteralToken:
				case SyntaxKind.TrueKeyword:
				case SyntaxKind.FalseKeyword:
				case SyntaxKind.NullKeyword:
				case SyntaxKind.DefaultKeyword:
					break;
				default:
					throw new ArgumentException(nameof(token));
			}
#endif

			var result = new LiteralExpressionSyntax(kind, token);
			return result;
		}

		public static MakeRefExpressionSyntax MakeRefExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
		{
#if DEBUG
			if (keyword == null)
				throw new ArgumentNullException(nameof(keyword));
			switch (keyword.Kind)
			{
				case SyntaxKind.MakeRefKeyword:
					break;
				default:
					throw new ArgumentException(nameof(keyword));
			}
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
#endif

			return new MakeRefExpressionSyntax(SyntaxKind.MakeRefExpression, keyword, openParenToken, expression, closeParenToken);
		}

		public static RefTypeExpressionSyntax RefTypeExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
		{
#if DEBUG
			if (keyword == null)
				throw new ArgumentNullException(nameof(keyword));
			switch (keyword.Kind)
			{
				case SyntaxKind.RefTypeKeyword:
					break;
				default:
					throw new ArgumentException(nameof(keyword));
			}
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
#endif

			return new RefTypeExpressionSyntax(SyntaxKind.RefTypeExpression, keyword, openParenToken, expression, closeParenToken);
		}

		public static RefValueExpressionSyntax RefValueExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken)
		{
#if DEBUG
			if (keyword == null)
				throw new ArgumentNullException(nameof(keyword));
			switch (keyword.Kind)
			{
				case SyntaxKind.RefValueKeyword:
					break;
				default:
					throw new ArgumentException(nameof(keyword));
			}
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
			if (comma == null)
				throw new ArgumentNullException(nameof(comma));
			switch (comma.Kind)
			{
				case SyntaxKind.CommaToken:
					break;
				default:
					throw new ArgumentException(nameof(comma));
			}
			if (type == null)
				throw new ArgumentNullException(nameof(type));
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
#endif

			return new RefValueExpressionSyntax(SyntaxKind.RefValueExpression, keyword, openParenToken, expression, comma, type, closeParenToken);
		}

		public static CheckedExpressionSyntax CheckedExpression(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
		{
			switch (kind)
			{
				case SyntaxKind.CheckedExpression:
				case SyntaxKind.UncheckedExpression:
					break;
				default:
					throw new ArgumentException(nameof(kind));
			}
#if DEBUG
			if (keyword == null)
				throw new ArgumentNullException(nameof(keyword));
			switch (keyword.Kind)
			{
				case SyntaxKind.CheckedKeyword:
				case SyntaxKind.UncheckedKeyword:
					break;
				default:
					throw new ArgumentException(nameof(keyword));
			}
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
#endif

			return new CheckedExpressionSyntax(kind, keyword, openParenToken, expression, closeParenToken);
		}

		public static DefaultExpressionSyntax DefaultExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
		{
#if DEBUG
			if (keyword == null)
				throw new ArgumentNullException(nameof(keyword));
			switch (keyword.Kind)
			{
				case SyntaxKind.DefaultKeyword:
					break;
				default:
					throw new ArgumentException(nameof(keyword));
			}
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (type == null)
				throw new ArgumentNullException(nameof(type));
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
#endif

			return new DefaultExpressionSyntax(SyntaxKind.DefaultExpression, keyword, openParenToken, type, closeParenToken);
		}

		public static TypeOfExpressionSyntax TypeOfExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
		{
#if DEBUG
			if (keyword == null)
				throw new ArgumentNullException(nameof(keyword));
			switch (keyword.Kind)
			{
				case SyntaxKind.TypeOfKeyword:
					break;
				default:
					throw new ArgumentException(nameof(keyword));
			}
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (type == null)
				throw new ArgumentNullException(nameof(type));
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
#endif

			return new TypeOfExpressionSyntax(SyntaxKind.TypeOfExpression, keyword, openParenToken, type, closeParenToken);
		}

		public static SizeOfExpressionSyntax SizeOfExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
		{
#if DEBUG
			if (keyword == null)
				throw new ArgumentNullException(nameof(keyword));
			switch (keyword.Kind)
			{
				case SyntaxKind.SizeOfKeyword:
					break;
				default:
					throw new ArgumentException(nameof(keyword));
			}
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (type == null)
				throw new ArgumentNullException(nameof(type));
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
#endif

			return new SizeOfExpressionSyntax(SyntaxKind.SizeOfExpression, keyword, openParenToken, type, closeParenToken);
		}

		public static InvocationExpressionSyntax InvocationExpression(ExpressionSyntax expression, ArgumentListSyntax argumentList)
		{
#if DEBUG
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
			if (argumentList == null)
				throw new ArgumentNullException(nameof(argumentList));
#endif
			var result = new InvocationExpressionSyntax(SyntaxKind.InvocationExpression, expression, argumentList);
			return result;
		}

		public static ElementAccessExpressionSyntax ElementAccessExpression(ExpressionSyntax expression, BracketedArgumentListSyntax argumentList)
		{
#if DEBUG
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
			if (argumentList == null)
				throw new ArgumentNullException(nameof(argumentList));
#endif
			var result = new ElementAccessExpressionSyntax(SyntaxKind.ElementAccessExpression, expression, argumentList);

			return result;
		}

		public static ArgumentListSyntax ArgumentList(SyntaxToken openParenToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
		{
#if DEBUG
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
#endif
			var result = new ArgumentListSyntax(SyntaxKind.ArgumentList, openParenToken, arguments.Node, closeParenToken);
			return result;
		}

		public static BracketedArgumentListSyntax BracketedArgumentList(SyntaxToken openBracketToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeBracketToken)
		{
#if DEBUG
			if (openBracketToken == null)
				throw new ArgumentNullException(nameof(openBracketToken));
			switch (openBracketToken.Kind)
			{
				case SyntaxKind.OpenBracketToken:
					break;
				default:
					throw new ArgumentException(nameof(openBracketToken));
			}
			if (closeBracketToken == null)
				throw new ArgumentNullException(nameof(closeBracketToken));
			switch (closeBracketToken.Kind)
			{
				case SyntaxKind.CloseBracketToken:
					break;
				default:
					throw new ArgumentException(nameof(closeBracketToken));
			}
#endif

			var result = new BracketedArgumentListSyntax(SyntaxKind.BracketedArgumentList, openBracketToken, arguments.Node, closeBracketToken);
			return result;
		}

		public static ArgumentSyntax Argument(NameColonSyntax nameColon, SyntaxToken refKindKeyword, ExpressionSyntax expression)
		{
#if DEBUG
			if (refKindKeyword != null)
			{
				switch (refKindKeyword.Kind)
				{
					case SyntaxKind.RefKeyword:
					case SyntaxKind.OutKeyword:
					case SyntaxKind.InKeyword:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(refKindKeyword));
				}
			}
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
#endif

			var result = new ArgumentSyntax(SyntaxKind.Argument, nameColon, refKindKeyword, expression);

			return result;
		}

		public static NameColonSyntax NameColon(IdentifierNameSyntax name, SyntaxToken colonToken)
		{
#if DEBUG
			if (name == null)
				throw new ArgumentNullException(nameof(name));
			if (colonToken == null)
				throw new ArgumentNullException(nameof(colonToken));
			switch (colonToken.Kind)
			{
				case SyntaxKind.ColonToken:
					break;
				default:
					throw new ArgumentException(nameof(colonToken));
			}
#endif

			var result = new NameColonSyntax(SyntaxKind.NameColon, name, colonToken);

			return result;
		}

		public static DeclarationExpressionSyntax DeclarationExpression(TypeSyntax type, VariableDesignationSyntax designation)
		{
#if DEBUG
			if (type == null)
				throw new ArgumentNullException(nameof(type));
			if (designation == null)
				throw new ArgumentNullException(nameof(designation));
#endif

			var result = new DeclarationExpressionSyntax(SyntaxKind.DeclarationExpression, type, designation);
			return result;
		}

		public static CastExpressionSyntax CastExpression(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression)
		{
#if DEBUG
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (type == null)
				throw new ArgumentNullException(nameof(type));
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
#endif

			return new CastExpressionSyntax(SyntaxKind.CastExpression, openParenToken, type, closeParenToken, expression);
		}

		public static AnonymousMethodExpressionSyntax AnonymousMethodExpression(SyntaxToken asyncKeyword, SyntaxToken delegateKeyword, ParameterListSyntax parameterList, LeeSyntaxNode body)
		{
#if DEBUG
			if (asyncKeyword != null)
			{
				switch (asyncKeyword.Kind)
				{
					case SyntaxKind.AsyncKeyword:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(asyncKeyword));
				}
			}
			if (delegateKeyword == null)
				throw new ArgumentNullException(nameof(delegateKeyword));
			switch (delegateKeyword.Kind)
			{
				case SyntaxKind.DelegateKeyword:
					break;
				default:
					throw new ArgumentException(nameof(delegateKeyword));
			}
			if (body == null)
				throw new ArgumentNullException(nameof(body));
#endif

			return new AnonymousMethodExpressionSyntax(SyntaxKind.AnonymousMethodExpression, asyncKeyword, delegateKeyword, parameterList, body);
		}

		public static SimpleLambdaExpressionSyntax SimpleLambdaExpression(SyntaxToken asyncKeyword, ParameterSyntax parameter, SyntaxToken arrowToken, LeeSyntaxNode body)
		{
#if DEBUG
			if (asyncKeyword != null)
			{
				switch (asyncKeyword.Kind)
				{
					case SyntaxKind.AsyncKeyword:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(asyncKeyword));
				}
			}
			if (parameter == null)
				throw new ArgumentNullException(nameof(parameter));
			if (arrowToken == null)
				throw new ArgumentNullException(nameof(arrowToken));
			switch (arrowToken.Kind)
			{
				case SyntaxKind.EqualsGreaterThanToken:
					break;
				default:
					throw new ArgumentException(nameof(arrowToken));
			}
			if (body == null)
				throw new ArgumentNullException(nameof(body));
#endif

			return new SimpleLambdaExpressionSyntax(SyntaxKind.SimpleLambdaExpression, asyncKeyword, parameter, arrowToken, body);
		}

		public static RefExpressionSyntax RefExpression(SyntaxToken refKeyword, ExpressionSyntax expression)
		{
#if DEBUG
			if (refKeyword == null)
				throw new ArgumentNullException(nameof(refKeyword));
			switch (refKeyword.Kind)
			{
				case SyntaxKind.RefKeyword:
					break;
				default:
					throw new ArgumentException(nameof(refKeyword));
			}
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
#endif
			var result = new RefExpressionSyntax(SyntaxKind.RefExpression, refKeyword, expression);
			return result;
		}

		public static ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(SyntaxToken asyncKeyword, ParameterListSyntax parameterList, SyntaxToken arrowToken, LeeSyntaxNode body)
		{
#if DEBUG
			if (asyncKeyword != null)
			{
				switch (asyncKeyword.Kind)
				{
					case SyntaxKind.AsyncKeyword:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(asyncKeyword));
				}
			}
			if (parameterList == null)
				throw new ArgumentNullException(nameof(parameterList));
			if (arrowToken == null)
				throw new ArgumentNullException(nameof(arrowToken));
			switch (arrowToken.Kind)
			{
				case SyntaxKind.EqualsGreaterThanToken:
					break;
				default:
					throw new ArgumentException(nameof(arrowToken));
			}
			if (body == null)
				throw new ArgumentNullException(nameof(body));
#endif

			return new ParenthesizedLambdaExpressionSyntax(SyntaxKind.ParenthesizedLambdaExpression, asyncKeyword, parameterList, arrowToken, body);
		}

		public static InitializerExpressionSyntax InitializerExpression(SyntaxKind kind, SyntaxToken openBraceToken, SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken closeBraceToken)
		{
			switch (kind)
			{
				case SyntaxKind.ObjectInitializerExpression:
				case SyntaxKind.CollectionInitializerExpression:
				case SyntaxKind.ArrayInitializerExpression:
				case SyntaxKind.ComplexElementInitializerExpression:
					break;
				default:
					throw new ArgumentException(nameof(kind));
			}
#if DEBUG
			if (openBraceToken == null)
				throw new ArgumentNullException(nameof(openBraceToken));
			switch (openBraceToken.Kind)
			{
				case SyntaxKind.OpenBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(openBraceToken));
			}
			if (closeBraceToken == null)
				throw new ArgumentNullException(nameof(closeBraceToken));
			switch (closeBraceToken.Kind)
			{
				case SyntaxKind.CloseBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(closeBraceToken));
			}
#endif
			var result = new InitializerExpressionSyntax(kind, openBraceToken, expressions.Node, closeBraceToken);
			return result;
		}

		public static ObjectCreationExpressionSyntax ObjectCreationExpression(SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer)
		{
#if DEBUG
			if (newKeyword == null)
				throw new ArgumentNullException(nameof(newKeyword));
			switch (newKeyword.Kind)
			{
				case SyntaxKind.NewKeyword:
					break;
				default:
					throw new ArgumentException(nameof(newKeyword));
			}
			if (type == null)
				throw new ArgumentNullException(nameof(type));
#endif

			return new ObjectCreationExpressionSyntax(SyntaxKind.ObjectCreationExpression, newKeyword, type, argumentList, initializer);
		}

		public static AnonymousObjectMemberDeclaratorSyntax AnonymousObjectMemberDeclarator(NameEqualsSyntax nameEquals, ExpressionSyntax expression)
		{
#if DEBUG
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
#endif

			var result = new AnonymousObjectMemberDeclaratorSyntax(SyntaxKind.AnonymousObjectMemberDeclarator, nameEquals, expression);

			return result;
		}

		public static AnonymousObjectCreationExpressionSyntax AnonymousObjectCreationExpression(SyntaxToken newKeyword, SyntaxToken openBraceToken, SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> initializers, SyntaxToken closeBraceToken)
		{
#if DEBUG
			if (newKeyword == null)
				throw new ArgumentNullException(nameof(newKeyword));
			switch (newKeyword.Kind)
			{
				case SyntaxKind.NewKeyword:
					break;
				default:
					throw new ArgumentException(nameof(newKeyword));
			}
			if (openBraceToken == null)
				throw new ArgumentNullException(nameof(openBraceToken));
			switch (openBraceToken.Kind)
			{
				case SyntaxKind.OpenBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(openBraceToken));
			}
			if (closeBraceToken == null)
				throw new ArgumentNullException(nameof(closeBraceToken));
			switch (closeBraceToken.Kind)
			{
				case SyntaxKind.CloseBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(closeBraceToken));
			}
#endif

			return new AnonymousObjectCreationExpressionSyntax(SyntaxKind.AnonymousObjectCreationExpression, newKeyword, openBraceToken, initializers.Node, closeBraceToken);
		}

		public static ArrayCreationExpressionSyntax ArrayCreationExpression(SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax initializer)
		{
#if DEBUG
			if (newKeyword == null)
				throw new ArgumentNullException(nameof(newKeyword));
			switch (newKeyword.Kind)
			{
				case SyntaxKind.NewKeyword:
					break;
				default:
					throw new ArgumentException(nameof(newKeyword));
			}
			if (type == null)
				throw new ArgumentNullException(nameof(type));
#endif

			var result = new ArrayCreationExpressionSyntax(SyntaxKind.ArrayCreationExpression, newKeyword, type, initializer);

			return result;
		}

		public static ImplicitArrayCreationExpressionSyntax ImplicitArrayCreationExpression(SyntaxToken newKeyword, SyntaxToken openBracketToken, SyntaxList<SyntaxToken> commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer)
		{
#if DEBUG
			if (newKeyword == null)
				throw new ArgumentNullException(nameof(newKeyword));
			switch (newKeyword.Kind)
			{
				case SyntaxKind.NewKeyword:
					break;
				default:
					throw new ArgumentException(nameof(newKeyword));
			}
			if (openBracketToken == null)
				throw new ArgumentNullException(nameof(openBracketToken));
			switch (openBracketToken.Kind)
			{
				case SyntaxKind.OpenBracketToken:
					break;
				default:
					throw new ArgumentException(nameof(openBracketToken));
			}
			if (closeBracketToken == null)
				throw new ArgumentNullException(nameof(closeBracketToken));
			switch (closeBracketToken.Kind)
			{
				case SyntaxKind.CloseBracketToken:
					break;
				default:
					throw new ArgumentException(nameof(closeBracketToken));
			}
			if (initializer == null)
				throw new ArgumentNullException(nameof(initializer));
#endif

			return new ImplicitArrayCreationExpressionSyntax(SyntaxKind.ImplicitArrayCreationExpression, newKeyword, openBracketToken, commas.Node, closeBracketToken, initializer);
		}

		public static StackAllocArrayCreationExpressionSyntax StackAllocArrayCreationExpression(SyntaxToken stackAllocKeyword, TypeSyntax type, InitializerExpressionSyntax initializer)
		{
#if DEBUG
			if (stackAllocKeyword == null)
				throw new ArgumentNullException(nameof(stackAllocKeyword));
			switch (stackAllocKeyword.Kind)
			{
				case SyntaxKind.StackAllocKeyword:
					break;
				default:
					throw new ArgumentException(nameof(stackAllocKeyword));
			}
			if (type == null)
				throw new ArgumentNullException(nameof(type));
#endif

			var result = new StackAllocArrayCreationExpressionSyntax(SyntaxKind.StackAllocArrayCreationExpression, stackAllocKeyword, type, initializer);
			return result;
		}

		public static ImplicitStackAllocArrayCreationExpressionSyntax ImplicitStackAllocArrayCreationExpression(SyntaxToken stackAllocKeyword, SyntaxToken openBracketToken, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer)
		{
#if DEBUG
			if (stackAllocKeyword == null)
				throw new ArgumentNullException(nameof(stackAllocKeyword));
			switch (stackAllocKeyword.Kind)
			{
				case SyntaxKind.StackAllocKeyword:
					break;
				default:
					throw new ArgumentException(nameof(stackAllocKeyword));
			}
			if (openBracketToken == null)
				throw new ArgumentNullException(nameof(openBracketToken));
			switch (openBracketToken.Kind)
			{
				case SyntaxKind.OpenBracketToken:
					break;
				default:
					throw new ArgumentException(nameof(openBracketToken));
			}
			if (closeBracketToken == null)
				throw new ArgumentNullException(nameof(closeBracketToken));
			switch (closeBracketToken.Kind)
			{
				case SyntaxKind.CloseBracketToken:
					break;
				default:
					throw new ArgumentException(nameof(closeBracketToken));
			}
			if (initializer == null)
				throw new ArgumentNullException(nameof(initializer));
#endif

			return new ImplicitStackAllocArrayCreationExpressionSyntax(SyntaxKind.ImplicitStackAllocArrayCreationExpression, stackAllocKeyword, openBracketToken, closeBracketToken, initializer);
		}

		public static QueryExpressionSyntax QueryExpression(FromClauseSyntax fromClause, QueryBodySyntax body)
		{
#if DEBUG
			if (fromClause == null)
				throw new ArgumentNullException(nameof(fromClause));
			if (body == null)
				throw new ArgumentNullException(nameof(body));
#endif

			var result = new QueryExpressionSyntax(SyntaxKind.QueryExpression, fromClause, body);
			return result;
		}

		public static QueryBodySyntax QueryBody(SyntaxList<QueryClauseSyntax> clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax continuation)
		{
#if DEBUG
			if (selectOrGroup == null)
				throw new ArgumentNullException(nameof(selectOrGroup));
#endif

			var result = new QueryBodySyntax(SyntaxKind.QueryBody, clauses.Node, selectOrGroup, continuation);
			return result;
		}

		public static FromClauseSyntax FromClause(SyntaxToken fromKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression)
		{
#if DEBUG
			if (fromKeyword == null)
				throw new ArgumentNullException(nameof(fromKeyword));
			switch (fromKeyword.Kind)
			{
				case SyntaxKind.FromKeyword:
					break;
				default:
					throw new ArgumentException(nameof(fromKeyword));
			}
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
			if (inKeyword == null)
				throw new ArgumentNullException(nameof(inKeyword));
			switch (inKeyword.Kind)
			{
				case SyntaxKind.InKeyword:
					break;
				default:
					throw new ArgumentException(nameof(inKeyword));
			}
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
#endif

			return new FromClauseSyntax(SyntaxKind.FromClause, fromKeyword, type, identifier, inKeyword, expression);
		}

		public static LetClauseSyntax LetClause(SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression)
		{
#if DEBUG
			if (letKeyword == null)
				throw new ArgumentNullException(nameof(letKeyword));
			switch (letKeyword.Kind)
			{
				case SyntaxKind.LetKeyword:
					break;
				default:
					throw new ArgumentException(nameof(letKeyword));
			}
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
			if (equalsToken == null)
				throw new ArgumentNullException(nameof(equalsToken));
			switch (equalsToken.Kind)
			{
				case SyntaxKind.EqualsToken:
					break;
				default:
					throw new ArgumentException(nameof(equalsToken));
			}
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
#endif

			return new LetClauseSyntax(SyntaxKind.LetClause, letKeyword, identifier, equalsToken, expression);
		}

		public static JoinClauseSyntax JoinClause(SyntaxToken joinKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into)
		{
#if DEBUG
			if (joinKeyword == null)
				throw new ArgumentNullException(nameof(joinKeyword));
			switch (joinKeyword.Kind)
			{
				case SyntaxKind.JoinKeyword:
					break;
				default:
					throw new ArgumentException(nameof(joinKeyword));
			}
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
			if (inKeyword == null)
				throw new ArgumentNullException(nameof(inKeyword));
			switch (inKeyword.Kind)
			{
				case SyntaxKind.InKeyword:
					break;
				default:
					throw new ArgumentException(nameof(inKeyword));
			}
			if (inExpression == null)
				throw new ArgumentNullException(nameof(inExpression));
			if (onKeyword == null)
				throw new ArgumentNullException(nameof(onKeyword));
			switch (onKeyword.Kind)
			{
				case SyntaxKind.OnKeyword:
					break;
				default:
					throw new ArgumentException(nameof(onKeyword));
			}
			if (leftExpression == null)
				throw new ArgumentNullException(nameof(leftExpression));
			if (equalsKeyword == null)
				throw new ArgumentNullException(nameof(equalsKeyword));
			switch (equalsKeyword.Kind)
			{
				case SyntaxKind.EqualsKeyword:
					break;
				default:
					throw new ArgumentException(nameof(equalsKeyword));
			}
			if (rightExpression == null)
				throw new ArgumentNullException(nameof(rightExpression));
#endif

			return new JoinClauseSyntax(SyntaxKind.JoinClause, joinKeyword, type, identifier, inKeyword, inExpression, onKeyword, leftExpression, equalsKeyword, rightExpression, into);
		}

		public static JoinIntoClauseSyntax JoinIntoClause(SyntaxToken intoKeyword, SyntaxToken identifier)
		{
#if DEBUG
			if (intoKeyword == null)
				throw new ArgumentNullException(nameof(intoKeyword));
			switch (intoKeyword.Kind)
			{
				case SyntaxKind.IntoKeyword:
					break;
				default:
					throw new ArgumentException(nameof(intoKeyword));
			}
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
#endif

			var result = new JoinIntoClauseSyntax(SyntaxKind.JoinIntoClause, intoKeyword, identifier);
			return result;
		}

		public static WhereClauseSyntax WhereClause(SyntaxToken whereKeyword, ExpressionSyntax condition)
		{
#if DEBUG
			if (whereKeyword == null)
				throw new ArgumentNullException(nameof(whereKeyword));
			switch (whereKeyword.Kind)
			{
				case SyntaxKind.WhereKeyword:
					break;
				default:
					throw new ArgumentException(nameof(whereKeyword));
			}
			if (condition == null)
				throw new ArgumentNullException(nameof(condition));
#endif
			var result = new WhereClauseSyntax(SyntaxKind.WhereClause, whereKeyword, condition);
			return result;
		}

		public static OrderByClauseSyntax OrderByClause(SyntaxToken orderByKeyword, SeparatedSyntaxList<OrderingSyntax> orderings)
		{
#if DEBUG
			if (orderByKeyword == null)
				throw new ArgumentNullException(nameof(orderByKeyword));
			switch (orderByKeyword.Kind)
			{
				case SyntaxKind.OrderByKeyword:
					break;
				default:
					throw new ArgumentException(nameof(orderByKeyword));
			}
#endif
			var result = new OrderByClauseSyntax(SyntaxKind.OrderByClause, orderByKeyword, orderings.Node);

			return result;
		}

		public static OrderingSyntax Ordering(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword)
		{
			switch (kind)
			{
				case SyntaxKind.AscendingOrdering:
				case SyntaxKind.DescendingOrdering:
					break;
				default:
					throw new ArgumentException(nameof(kind));
			}
#if DEBUG
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
			if (ascendingOrDescendingKeyword != null)
			{
				switch (ascendingOrDescendingKeyword.Kind)
				{
					case SyntaxKind.AscendingKeyword:
					case SyntaxKind.DescendingKeyword:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(ascendingOrDescendingKeyword));
				}
			}
#endif
			var result = new OrderingSyntax(kind, expression, ascendingOrDescendingKeyword);

			return result;
		}

		public static SelectClauseSyntax SelectClause(SyntaxToken selectKeyword, ExpressionSyntax expression)
		{
#if DEBUG
			if (selectKeyword == null)
				throw new ArgumentNullException(nameof(selectKeyword));
			switch (selectKeyword.Kind)
			{
				case SyntaxKind.SelectKeyword:
					break;
				default:
					throw new ArgumentException(nameof(selectKeyword));
			}
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
#endif
			var result = new SelectClauseSyntax(SyntaxKind.SelectClause, selectKeyword, expression);
			return result;
		}

		public static GroupClauseSyntax GroupClause(SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression)
		{
#if DEBUG
			if (groupKeyword == null)
				throw new ArgumentNullException(nameof(groupKeyword));
			switch (groupKeyword.Kind)
			{
				case SyntaxKind.GroupKeyword:
					break;
				default:
					throw new ArgumentException(nameof(groupKeyword));
			}
			if (groupExpression == null)
				throw new ArgumentNullException(nameof(groupExpression));
			if (byKeyword == null)
				throw new ArgumentNullException(nameof(byKeyword));
			switch (byKeyword.Kind)
			{
				case SyntaxKind.ByKeyword:
					break;
				default:
					throw new ArgumentException(nameof(byKeyword));
			}
			if (byExpression == null)
				throw new ArgumentNullException(nameof(byExpression));
#endif

			return new GroupClauseSyntax(SyntaxKind.GroupClause, groupKeyword, groupExpression, byKeyword, byExpression);
		}

		public static QueryContinuationSyntax QueryContinuation(SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body)
		{
#if DEBUG
			if (intoKeyword == null)
				throw new ArgumentNullException(nameof(intoKeyword));
			switch (intoKeyword.Kind)
			{
				case SyntaxKind.IntoKeyword:
					break;
				default:
					throw new ArgumentException(nameof(intoKeyword));
			}
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
			if (body == null)
				throw new ArgumentNullException(nameof(body));
#endif

			var result = new QueryContinuationSyntax(SyntaxKind.QueryContinuation, intoKeyword, identifier, body);

			return result;
		}

		public static OmittedArraySizeExpressionSyntax OmittedArraySizeExpression(SyntaxToken omittedArraySizeExpressionToken)
		{
#if DEBUG
			if (omittedArraySizeExpressionToken == null)
				throw new ArgumentNullException(nameof(omittedArraySizeExpressionToken));
			switch (omittedArraySizeExpressionToken.Kind)
			{
				case SyntaxKind.OmittedArraySizeExpressionToken:
					break;
				default:
					throw new ArgumentException(nameof(omittedArraySizeExpressionToken));
			}
#endif

			var result = new OmittedArraySizeExpressionSyntax(SyntaxKind.OmittedArraySizeExpression, omittedArraySizeExpressionToken);
			return result;
		}

		public static InterpolatedStringExpressionSyntax InterpolatedStringExpression(SyntaxToken stringStartToken, SyntaxList<InterpolatedStringContentSyntax> contents, SyntaxToken stringEndToken)
		{
#if DEBUG
			if (stringStartToken == null)
				throw new ArgumentNullException(nameof(stringStartToken));
			switch (stringStartToken.Kind)
			{
				case SyntaxKind.InterpolatedStringStartToken:
				case SyntaxKind.InterpolatedVerbatimStringStartToken:
					break;
				default:
					throw new ArgumentException(nameof(stringStartToken));
			}
			if (stringEndToken == null)
				throw new ArgumentNullException(nameof(stringEndToken));
			switch (stringEndToken.Kind)
			{
				case SyntaxKind.InterpolatedStringEndToken:
					break;
				default:
					throw new ArgumentException(nameof(stringEndToken));
			}
#endif
			var result = new InterpolatedStringExpressionSyntax(SyntaxKind.InterpolatedStringExpression, stringStartToken, contents.Node, stringEndToken);

			return result;
		}

		public static IsPatternExpressionSyntax IsPatternExpression(ExpressionSyntax expression, SyntaxToken isKeyword, PatternSyntax pattern)
		{
#if DEBUG
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
			if (isKeyword == null)
				throw new ArgumentNullException(nameof(isKeyword));
			switch (isKeyword.Kind)
			{
				case SyntaxKind.IsKeyword:
					break;
				default:
					throw new ArgumentException(nameof(isKeyword));
			}
			if (pattern == null)
				throw new ArgumentNullException(nameof(pattern));
#endif
			var result = new IsPatternExpressionSyntax(SyntaxKind.IsPatternExpression, expression, isKeyword, pattern);
			return result;
		}

		public static ThrowExpressionSyntax ThrowExpression(SyntaxToken throwKeyword, ExpressionSyntax expression)
		{
#if DEBUG
			if (throwKeyword == null)
				throw new ArgumentNullException(nameof(throwKeyword));
			switch (throwKeyword.Kind)
			{
				case SyntaxKind.ThrowKeyword:
					break;
				default:
					throw new ArgumentException(nameof(throwKeyword));
			}
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
#endif
			var result = new ThrowExpressionSyntax(SyntaxKind.ThrowExpression, throwKeyword, expression);
			return result;
		}

		public static WhenClauseSyntax WhenClause(SyntaxToken whenKeyword, ExpressionSyntax condition)
		{
#if DEBUG
			if (whenKeyword == null)
				throw new ArgumentNullException(nameof(whenKeyword));
			switch (whenKeyword.Kind)
			{
				case SyntaxKind.WhenKeyword:
					break;
				default:
					throw new ArgumentException(nameof(whenKeyword));
			}
			if (condition == null)
				throw new ArgumentNullException(nameof(condition));
#endif

			var result = new WhenClauseSyntax(SyntaxKind.WhenClause, whenKeyword, condition);
			return result;
		}

		public static DiscardPatternSyntax DiscardPattern(SyntaxToken underscoreToken)
		{
#if DEBUG
			if (underscoreToken == null)
				throw new ArgumentNullException(nameof(underscoreToken));
			switch (underscoreToken.Kind)
			{
				case SyntaxKind.UnderscoreToken:
					break;
				default:
					throw new ArgumentException(nameof(underscoreToken));
			}
#endif

			var result = new DiscardPatternSyntax(SyntaxKind.DiscardPattern, underscoreToken);

			return result;
		}

		public static DeclarationPatternSyntax DeclarationPattern(TypeSyntax type, VariableDesignationSyntax designation)
		{
#if DEBUG
			if (type == null)
				throw new ArgumentNullException(nameof(type));
			if (designation == null)
				throw new ArgumentNullException(nameof(designation));
#endif

			var result = new DeclarationPatternSyntax(SyntaxKind.DeclarationPattern, type, designation);
			return result;
		}

		public static VarPatternSyntax VarPattern(SyntaxToken varKeyword, VariableDesignationSyntax designation)
		{
#if DEBUG
			if (varKeyword == null)
				throw new ArgumentNullException(nameof(varKeyword));
			switch (varKeyword.Kind)
			{
				case SyntaxKind.VarKeyword:
					break;
				default:
					throw new ArgumentException(nameof(varKeyword));
			}
			if (designation == null)
				throw new ArgumentNullException(nameof(designation));
#endif
			var result = new VarPatternSyntax(SyntaxKind.VarPattern, varKeyword, designation);
			return result;
		}

		public static RecursivePatternSyntax RecursivePattern(TypeSyntax type, PositionalPatternClauseSyntax positionalPatternClause, PropertyPatternClauseSyntax propertyPatternClause, VariableDesignationSyntax designation)
		{
#if DEBUG
#endif

			return new RecursivePatternSyntax(SyntaxKind.RecursivePattern, type, positionalPatternClause, propertyPatternClause, designation);
		}

		public static PositionalPatternClauseSyntax PositionalPatternClause(SyntaxToken openParenToken, SeparatedSyntaxList<SubpatternSyntax> subpatterns, SyntaxToken closeParenToken)
		{
#if DEBUG
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
#endif

			var result = new PositionalPatternClauseSyntax(SyntaxKind.PositionalPatternClause, openParenToken, subpatterns.Node, closeParenToken);
			return result;
		}

		public static PropertyPatternClauseSyntax PropertyPatternClause(SyntaxToken openBraceToken, SeparatedSyntaxList<SubpatternSyntax> subpatterns, SyntaxToken closeBraceToken)
		{
#if DEBUG
			if (openBraceToken == null)
				throw new ArgumentNullException(nameof(openBraceToken));
			switch (openBraceToken.Kind)
			{
				case SyntaxKind.OpenBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(openBraceToken));
			}
			if (closeBraceToken == null)
				throw new ArgumentNullException(nameof(closeBraceToken));
			switch (closeBraceToken.Kind)
			{
				case SyntaxKind.CloseBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(closeBraceToken));
			}
#endif

			var result = new PropertyPatternClauseSyntax(SyntaxKind.PropertyPatternClause, openBraceToken, subpatterns.Node, closeBraceToken);
			return result;
		}

		public static SubpatternSyntax Subpattern(NameColonSyntax nameColon, PatternSyntax pattern)
		{
#if DEBUG
			if (pattern == null)
				throw new ArgumentNullException(nameof(pattern));
#endif

			var result = new SubpatternSyntax(SyntaxKind.Subpattern, nameColon, pattern);
			return result;
		}

		public static ConstantPatternSyntax ConstantPattern(ExpressionSyntax expression)
		{
#if DEBUG
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
#endif

			var result = new ConstantPatternSyntax(SyntaxKind.ConstantPattern, expression);
			return result;
		}

		public static InterpolatedStringTextSyntax InterpolatedStringText(SyntaxToken textToken)
		{
#if DEBUG
			if (textToken == null)
				throw new ArgumentNullException(nameof(textToken));
			switch (textToken.Kind)
			{
				case SyntaxKind.InterpolatedStringTextToken:
					break;
				default:
					throw new ArgumentException(nameof(textToken));
			}
#endif

			var result = new InterpolatedStringTextSyntax(SyntaxKind.InterpolatedStringText, textToken);
			return result;
		}

		public static InterpolationSyntax Interpolation(SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, SyntaxToken closeBraceToken)
		{
#if DEBUG
			if (openBraceToken == null)
				throw new ArgumentNullException(nameof(openBraceToken));
			switch (openBraceToken.Kind)
			{
				case SyntaxKind.OpenBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(openBraceToken));
			}
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
			if (closeBraceToken == null)
				throw new ArgumentNullException(nameof(closeBraceToken));
			switch (closeBraceToken.Kind)
			{
				case SyntaxKind.CloseBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(closeBraceToken));
			}
#endif

			return new InterpolationSyntax(SyntaxKind.Interpolation, openBraceToken, expression, alignmentClause, formatClause, closeBraceToken);
		}

		public static InterpolationAlignmentClauseSyntax InterpolationAlignmentClause(SyntaxToken commaToken, ExpressionSyntax value)
		{
#if DEBUG
			if (commaToken == null)
				throw new ArgumentNullException(nameof(commaToken));
			if (value == null)
				throw new ArgumentNullException(nameof(value));
#endif

			var result = new InterpolationAlignmentClauseSyntax(SyntaxKind.InterpolationAlignmentClause, commaToken, value);
			return result;
		}

		public static InterpolationFormatClauseSyntax InterpolationFormatClause(SyntaxToken colonToken, SyntaxToken formatStringToken)
		{
#if DEBUG
			if (colonToken == null)
				throw new ArgumentNullException(nameof(colonToken));
			if (formatStringToken == null)
				throw new ArgumentNullException(nameof(formatStringToken));
			switch (formatStringToken.Kind)
			{
				case SyntaxKind.InterpolatedStringTextToken:
					break;
				default:
					throw new ArgumentException(nameof(formatStringToken));
			}
#endif
			var result = new InterpolationFormatClauseSyntax(SyntaxKind.InterpolationFormatClause, colonToken, formatStringToken);
			return result;
		}

		public static GlobalStatementSyntax GlobalStatement(StatementSyntax statement)
		{
#if DEBUG
			if (statement == null)
				throw new ArgumentNullException(nameof(statement));
#endif
			var result = new GlobalStatementSyntax(SyntaxKind.GlobalStatement, statement);
			return result;
		}

		public static BlockSyntax Block(SyntaxToken openBraceToken, SyntaxList<StatementSyntax> statements, SyntaxToken closeBraceToken)
		{
#if DEBUG
			if (openBraceToken == null)
				throw new ArgumentNullException(nameof(openBraceToken));
			switch (openBraceToken.Kind)
			{
				case SyntaxKind.OpenBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(openBraceToken));
			}
			if (closeBraceToken == null)
				throw new ArgumentNullException(nameof(closeBraceToken));
			switch (closeBraceToken.Kind)
			{
				case SyntaxKind.CloseBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(closeBraceToken));
			}
#endif
			var result = new BlockSyntax(SyntaxKind.Block, openBraceToken, statements.Node, closeBraceToken);
			return result;
		}

		public static LocalFunctionStatementSyntax LocalFunctionStatement(SyntaxList<SyntaxToken> modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (returnType == null)
				throw new ArgumentNullException(nameof(returnType));
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
			if (parameterList == null)
				throw new ArgumentNullException(nameof(parameterList));
			if (semicolonToken != null)
			{
				switch (semicolonToken.Kind)
				{
					case SyntaxKind.SemicolonToken:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(semicolonToken));
				}
			}
#endif

			return new LocalFunctionStatementSyntax(SyntaxKind.LocalFunctionStatement, modifiers.Node, returnType, identifier, typeParameterList, parameterList, constraintClauses.Node, body, expressionBody, semicolonToken);
		}

		public static LocalDeclarationStatementSyntax LocalDeclarationStatement(SyntaxToken awaitKeyword, SyntaxToken usingKeyword, SyntaxList<SyntaxToken> modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (awaitKeyword != null)
			{
				switch (awaitKeyword.Kind)
				{
					case SyntaxKind.AwaitKeyword:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(awaitKeyword));
				}
			}
			if (usingKeyword != null)
			{
				switch (usingKeyword.Kind)
				{
					case SyntaxKind.UsingKeyword:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(usingKeyword));
				}
			}
			if (declaration == null)
				throw new ArgumentNullException(nameof(declaration));
			if (semicolonToken == null)
				throw new ArgumentNullException(nameof(semicolonToken));
			switch (semicolonToken.Kind)
			{
				case SyntaxKind.SemicolonToken:
					break;
				default:
					throw new ArgumentException(nameof(semicolonToken));
			}
#endif

			return new LocalDeclarationStatementSyntax(SyntaxKind.LocalDeclarationStatement, awaitKeyword, usingKeyword, modifiers.Node, declaration, semicolonToken);
		}

		public static VariableDeclarationSyntax VariableDeclaration(TypeSyntax type, SeparatedSyntaxList<VariableDeclaratorSyntax> variables)
		{
#if DEBUG
			if (type == null)
				throw new ArgumentNullException(nameof(type));
#endif
			var result = new VariableDeclarationSyntax(SyntaxKind.VariableDeclaration, type, variables.Node);
			return result;
		}

		public static VariableDeclaratorSyntax VariableDeclarator(SyntaxToken identifier, BracketedArgumentListSyntax argumentList, EqualsValueClauseSyntax initializer)
		{
#if DEBUG
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
#endif

			var result = new VariableDeclaratorSyntax(SyntaxKind.VariableDeclarator, identifier, argumentList, initializer);

			return result;
		}

		public static EqualsValueClauseSyntax EqualsValueClause(SyntaxToken equalsToken, ExpressionSyntax value)
		{
#if DEBUG
			if (equalsToken == null)
				throw new ArgumentNullException(nameof(equalsToken));
			switch (equalsToken.Kind)
			{
				case SyntaxKind.EqualsToken:
					break;
				default:
					throw new ArgumentException(nameof(equalsToken));
			}
			if (value == null)
				throw new ArgumentNullException(nameof(value));
#endif
			var result = new EqualsValueClauseSyntax(SyntaxKind.EqualsValueClause, equalsToken, value);
			return result;
		}

		public static SingleVariableDesignationSyntax SingleVariableDesignation(SyntaxToken identifier)
		{
#if DEBUG
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
#endif

			var result = new SingleVariableDesignationSyntax(SyntaxKind.SingleVariableDesignation, identifier);
			return result;
		}

		public static DiscardDesignationSyntax DiscardDesignation(SyntaxToken underscoreToken)
		{
#if DEBUG
			if (underscoreToken == null)
				throw new ArgumentNullException(nameof(underscoreToken));
			switch (underscoreToken.Kind)
			{
				case SyntaxKind.UnderscoreToken:
					break;
				default:
					throw new ArgumentException(nameof(underscoreToken));
			}
#endif
			var result = new DiscardDesignationSyntax(SyntaxKind.DiscardDesignation, underscoreToken);
			return result;
		}

		public static ParenthesizedVariableDesignationSyntax ParenthesizedVariableDesignation(SyntaxToken openParenToken, SeparatedSyntaxList<VariableDesignationSyntax> variables, SyntaxToken closeParenToken)
		{
#if DEBUG
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
#endif

			var result = new ParenthesizedVariableDesignationSyntax(SyntaxKind.ParenthesizedVariableDesignation, openParenToken, variables.Node, closeParenToken);

			return result;
		}

		public static ExpressionStatementSyntax ExpressionStatement(ExpressionSyntax expression, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
			if (semicolonToken == null)
				throw new ArgumentNullException(nameof(semicolonToken));
			switch (semicolonToken.Kind)
			{
				case SyntaxKind.SemicolonToken:
					break;
				default:
					throw new ArgumentException(nameof(semicolonToken));
			}
#endif

			var result = new ExpressionStatementSyntax(SyntaxKind.ExpressionStatement, expression, semicolonToken);

			return result;
		}

		public static EmptyStatementSyntax EmptyStatement(SyntaxToken semicolonToken)
		{
#if DEBUG
			if (semicolonToken == null)
				throw new ArgumentNullException(nameof(semicolonToken));
			switch (semicolonToken.Kind)
			{
				case SyntaxKind.SemicolonToken:
					break;
				default:
					throw new ArgumentException(nameof(semicolonToken));
			}
#endif

			var result = new EmptyStatementSyntax(SyntaxKind.EmptyStatement, semicolonToken);
			return result;
		}

		public static LabeledStatementSyntax LabeledStatement(SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement)
		{
#if DEBUG
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
			if (colonToken == null)
				throw new ArgumentNullException(nameof(colonToken));
			switch (colonToken.Kind)
			{
				case SyntaxKind.ColonToken:
					break;
				default:
					throw new ArgumentException(nameof(colonToken));
			}
			if (statement == null)
				throw new ArgumentNullException(nameof(statement));
#endif
			var result = new LabeledStatementSyntax(SyntaxKind.LabeledStatement, identifier, colonToken, statement);

			return result;
		}

		public static GotoStatementSyntax GotoStatement(SyntaxKind kind, SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
		{
			switch (kind)
			{
				case SyntaxKind.GotoStatement:
				case SyntaxKind.GotoCaseStatement:
				case SyntaxKind.GotoDefaultStatement:
					break;
				default:
					throw new ArgumentException(nameof(kind));
			}
#if DEBUG
			if (gotoKeyword == null)
				throw new ArgumentNullException(nameof(gotoKeyword));
			switch (gotoKeyword.Kind)
			{
				case SyntaxKind.GotoKeyword:
					break;
				default:
					throw new ArgumentException(nameof(gotoKeyword));
			}
			if (caseOrDefaultKeyword != null)
			{
				switch (caseOrDefaultKeyword.Kind)
				{
					case SyntaxKind.CaseKeyword:
					case SyntaxKind.DefaultKeyword:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(caseOrDefaultKeyword));
				}
			}
			if (semicolonToken == null)
				throw new ArgumentNullException(nameof(semicolonToken));
			switch (semicolonToken.Kind)
			{
				case SyntaxKind.SemicolonToken:
					break;
				default:
					throw new ArgumentException(nameof(semicolonToken));
			}
#endif

			return new GotoStatementSyntax(kind, gotoKeyword, caseOrDefaultKeyword, expression, semicolonToken);
		}

		public static BreakStatementSyntax BreakStatement(SyntaxToken breakKeyword, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (breakKeyword == null)
				throw new ArgumentNullException(nameof(breakKeyword));
			switch (breakKeyword.Kind)
			{
				case SyntaxKind.BreakKeyword:
					break;
				default:
					throw new ArgumentException(nameof(breakKeyword));
			}
			if (semicolonToken == null)
				throw new ArgumentNullException(nameof(semicolonToken));
			switch (semicolonToken.Kind)
			{
				case SyntaxKind.SemicolonToken:
					break;
				default:
					throw new ArgumentException(nameof(semicolonToken));
			}
#endif
			var result = new BreakStatementSyntax(SyntaxKind.BreakStatement, breakKeyword, semicolonToken);
			return result;
		}

		public static ContinueStatementSyntax ContinueStatement(SyntaxToken continueKeyword, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (continueKeyword == null)
				throw new ArgumentNullException(nameof(continueKeyword));
			switch (continueKeyword.Kind)
			{
				case SyntaxKind.ContinueKeyword:
					break;
				default:
					throw new ArgumentException(nameof(continueKeyword));
			}
			if (semicolonToken == null)
				throw new ArgumentNullException(nameof(semicolonToken));
			switch (semicolonToken.Kind)
			{
				case SyntaxKind.SemicolonToken:
					break;
				default:
					throw new ArgumentException(nameof(semicolonToken));
			}
#endif
			var result = new ContinueStatementSyntax(SyntaxKind.ContinueStatement, continueKeyword, semicolonToken);
			return result;
		}

		public static ReturnStatementSyntax ReturnStatement(SyntaxToken returnKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (returnKeyword == null)
				throw new ArgumentNullException(nameof(returnKeyword));
			switch (returnKeyword.Kind)
			{
				case SyntaxKind.ReturnKeyword:
					break;
				default:
					throw new ArgumentException(nameof(returnKeyword));
			}
			if (semicolonToken == null)
				throw new ArgumentNullException(nameof(semicolonToken));
			switch (semicolonToken.Kind)
			{
				case SyntaxKind.SemicolonToken:
					break;
				default:
					throw new ArgumentException(nameof(semicolonToken));
			}
#endif
			var result = new ReturnStatementSyntax(SyntaxKind.ReturnStatement, returnKeyword, expression, semicolonToken);
			return result;
		}

		public static ThrowStatementSyntax ThrowStatement(SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (throwKeyword == null)
				throw new ArgumentNullException(nameof(throwKeyword));
			switch (throwKeyword.Kind)
			{
				case SyntaxKind.ThrowKeyword:
					break;
				default:
					throw new ArgumentException(nameof(throwKeyword));
			}
			if (semicolonToken == null)
				throw new ArgumentNullException(nameof(semicolonToken));
			switch (semicolonToken.Kind)
			{
				case SyntaxKind.SemicolonToken:
					break;
				default:
					throw new ArgumentException(nameof(semicolonToken));
			}
#endif
			var result = new ThrowStatementSyntax(SyntaxKind.ThrowStatement, throwKeyword, expression, semicolonToken);
			return result;
		}

		public static YieldStatementSyntax YieldStatement(SyntaxKind kind, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
		{
			switch (kind)
			{
				case SyntaxKind.YieldReturnStatement:
				case SyntaxKind.YieldBreakStatement:
					break;
				default:
					throw new ArgumentException(nameof(kind));
			}
#if DEBUG
			if (yieldKeyword == null)
				throw new ArgumentNullException(nameof(yieldKeyword));
			switch (yieldKeyword.Kind)
			{
				case SyntaxKind.YieldKeyword:
					break;
				default:
					throw new ArgumentException(nameof(yieldKeyword));
			}
			if (returnOrBreakKeyword == null)
				throw new ArgumentNullException(nameof(returnOrBreakKeyword));
			switch (returnOrBreakKeyword.Kind)
			{
				case SyntaxKind.ReturnKeyword:
				case SyntaxKind.BreakKeyword:
					break;
				default:
					throw new ArgumentException(nameof(returnOrBreakKeyword));
			}
			if (semicolonToken == null)
				throw new ArgumentNullException(nameof(semicolonToken));
			switch (semicolonToken.Kind)
			{
				case SyntaxKind.SemicolonToken:
					break;
				default:
					throw new ArgumentException(nameof(semicolonToken));
			}
#endif

			return new YieldStatementSyntax(kind, yieldKeyword, returnOrBreakKeyword, expression, semicolonToken);
		}

		public static WhileStatementSyntax WhileStatement(SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement)
		{
#if DEBUG
			if (whileKeyword == null)
				throw new ArgumentNullException(nameof(whileKeyword));
			switch (whileKeyword.Kind)
			{
				case SyntaxKind.WhileKeyword:
					break;
				default:
					throw new ArgumentException(nameof(whileKeyword));
			}
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (condition == null)
				throw new ArgumentNullException(nameof(condition));
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
			if (statement == null)
				throw new ArgumentNullException(nameof(statement));
#endif

			return new WhileStatementSyntax(SyntaxKind.WhileStatement, whileKeyword, openParenToken, condition, closeParenToken, statement);
		}

		public static DoStatementSyntax DoStatement(SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (doKeyword == null)
				throw new ArgumentNullException(nameof(doKeyword));
			switch (doKeyword.Kind)
			{
				case SyntaxKind.DoKeyword:
					break;
				default:
					throw new ArgumentException(nameof(doKeyword));
			}
			if (statement == null)
				throw new ArgumentNullException(nameof(statement));
			if (whileKeyword == null)
				throw new ArgumentNullException(nameof(whileKeyword));
			switch (whileKeyword.Kind)
			{
				case SyntaxKind.WhileKeyword:
					break;
				default:
					throw new ArgumentException(nameof(whileKeyword));
			}
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (condition == null)
				throw new ArgumentNullException(nameof(condition));
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
			if (semicolonToken == null)
				throw new ArgumentNullException(nameof(semicolonToken));
			switch (semicolonToken.Kind)
			{
				case SyntaxKind.SemicolonToken:
					break;
				default:
					throw new ArgumentException(nameof(semicolonToken));
			}
#endif

			return new DoStatementSyntax(SyntaxKind.DoStatement, doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken);
		}

		public static ForStatementSyntax ForStatement(SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SeparatedSyntaxList<ExpressionSyntax> initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax condition, SyntaxToken secondSemicolonToken, SeparatedSyntaxList<ExpressionSyntax> incrementors, SyntaxToken closeParenToken, StatementSyntax statement)
		{
#if DEBUG
			if (forKeyword == null)
				throw new ArgumentNullException(nameof(forKeyword));
			switch (forKeyword.Kind)
			{
				case SyntaxKind.ForKeyword:
					break;
				default:
					throw new ArgumentException(nameof(forKeyword));
			}
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (firstSemicolonToken == null)
				throw new ArgumentNullException(nameof(firstSemicolonToken));
			switch (firstSemicolonToken.Kind)
			{
				case SyntaxKind.SemicolonToken:
					break;
				default:
					throw new ArgumentException(nameof(firstSemicolonToken));
			}
			if (secondSemicolonToken == null)
				throw new ArgumentNullException(nameof(secondSemicolonToken));
			switch (secondSemicolonToken.Kind)
			{
				case SyntaxKind.SemicolonToken:
					break;
				default:
					throw new ArgumentException(nameof(secondSemicolonToken));
			}
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
			if (statement == null)
				throw new ArgumentNullException(nameof(statement));
#endif

			return new ForStatementSyntax(SyntaxKind.ForStatement, forKeyword, openParenToken, declaration, initializers.Node, firstSemicolonToken, condition, secondSemicolonToken, incrementors.Node, closeParenToken, statement);
		}

		public static ForEachStatementSyntax ForEachStatement(SyntaxToken awaitKeyword, SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
		{
#if DEBUG
			if (awaitKeyword != null)
			{
				switch (awaitKeyword.Kind)
				{
					case SyntaxKind.AwaitKeyword:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(awaitKeyword));
				}
			}
			if (forEachKeyword == null)
				throw new ArgumentNullException(nameof(forEachKeyword));
			switch (forEachKeyword.Kind)
			{
				case SyntaxKind.ForEachKeyword:
					break;
				default:
					throw new ArgumentException(nameof(forEachKeyword));
			}
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (type == null)
				throw new ArgumentNullException(nameof(type));
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
			if (inKeyword == null)
				throw new ArgumentNullException(nameof(inKeyword));
			switch (inKeyword.Kind)
			{
				case SyntaxKind.InKeyword:
					break;
				default:
					throw new ArgumentException(nameof(inKeyword));
			}
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
			if (statement == null)
				throw new ArgumentNullException(nameof(statement));
#endif

			return new ForEachStatementSyntax(SyntaxKind.ForEachStatement, awaitKeyword, forEachKeyword, openParenToken, type, identifier, inKeyword, expression, closeParenToken, statement);
		}

		public static ForEachVariableStatementSyntax ForEachVariableStatement(SyntaxToken awaitKeyword, SyntaxToken forEachKeyword, SyntaxToken openParenToken, ExpressionSyntax variable, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
		{
#if DEBUG
			if (awaitKeyword != null)
			{
				switch (awaitKeyword.Kind)
				{
					case SyntaxKind.AwaitKeyword:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(awaitKeyword));
				}
			}
			if (forEachKeyword == null)
				throw new ArgumentNullException(nameof(forEachKeyword));
			switch (forEachKeyword.Kind)
			{
				case SyntaxKind.ForEachKeyword:
					break;
				default:
					throw new ArgumentException(nameof(forEachKeyword));
			}
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (variable == null)
				throw new ArgumentNullException(nameof(variable));
			if (inKeyword == null)
				throw new ArgumentNullException(nameof(inKeyword));
			switch (inKeyword.Kind)
			{
				case SyntaxKind.InKeyword:
					break;
				default:
					throw new ArgumentException(nameof(inKeyword));
			}
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
			if (statement == null)
				throw new ArgumentNullException(nameof(statement));
#endif

			return new ForEachVariableStatementSyntax(SyntaxKind.ForEachVariableStatement, awaitKeyword, forEachKeyword, openParenToken, variable, inKeyword, expression, closeParenToken, statement);
		}

		public static UsingStatementSyntax UsingStatement(SyntaxToken awaitKeyword, SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
		{
#if DEBUG
			if (awaitKeyword != null)
			{
				switch (awaitKeyword.Kind)
				{
					case SyntaxKind.AwaitKeyword:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(awaitKeyword));
				}
			}
			if (usingKeyword == null)
				throw new ArgumentNullException(nameof(usingKeyword));
			switch (usingKeyword.Kind)
			{
				case SyntaxKind.UsingKeyword:
					break;
				default:
					throw new ArgumentException(nameof(usingKeyword));
			}
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
			if (statement == null)
				throw new ArgumentNullException(nameof(statement));
#endif

			return new UsingStatementSyntax(SyntaxKind.UsingStatement, awaitKeyword, usingKeyword, openParenToken, declaration, expression, closeParenToken, statement);
		}

		public static FixedStatementSyntax FixedStatement(SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement)
		{
#if DEBUG
			if (fixedKeyword == null)
				throw new ArgumentNullException(nameof(fixedKeyword));
			switch (fixedKeyword.Kind)
			{
				case SyntaxKind.FixedKeyword:
					break;
				default:
					throw new ArgumentException(nameof(fixedKeyword));
			}
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (declaration == null)
				throw new ArgumentNullException(nameof(declaration));
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
			if (statement == null)
				throw new ArgumentNullException(nameof(statement));
#endif

			return new FixedStatementSyntax(SyntaxKind.FixedStatement, fixedKeyword, openParenToken, declaration, closeParenToken, statement);
		}

		public static CheckedStatementSyntax CheckedStatement(SyntaxKind kind, SyntaxToken keyword, BlockSyntax block)
		{
			switch (kind)
			{
				case SyntaxKind.CheckedStatement:
				case SyntaxKind.UncheckedStatement:
					break;
				default:
					throw new ArgumentException(nameof(kind));
			}
#if DEBUG
			if (keyword == null)
				throw new ArgumentNullException(nameof(keyword));
			switch (keyword.Kind)
			{
				case SyntaxKind.CheckedKeyword:
				case SyntaxKind.UncheckedKeyword:
					break;
				default:
					throw new ArgumentException(nameof(keyword));
			}
			if (block == null)
				throw new ArgumentNullException(nameof(block));
#endif
			var result = new CheckedStatementSyntax(kind, keyword, block);
			return result;
		}

		public static UnsafeStatementSyntax UnsafeStatement(SyntaxToken unsafeKeyword, BlockSyntax block)
		{
#if DEBUG
			if (unsafeKeyword == null)
				throw new ArgumentNullException(nameof(unsafeKeyword));
			switch (unsafeKeyword.Kind)
			{
				case SyntaxKind.UnsafeKeyword:
					break;
				default:
					throw new ArgumentException(nameof(unsafeKeyword));
			}
			if (block == null)
				throw new ArgumentNullException(nameof(block));
#endif
			var result = new UnsafeStatementSyntax(SyntaxKind.UnsafeStatement, unsafeKeyword, block);
			return result;
		}

		public static LockStatementSyntax LockStatement(SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
		{
#if DEBUG
			if (lockKeyword == null)
				throw new ArgumentNullException(nameof(lockKeyword));
			switch (lockKeyword.Kind)
			{
				case SyntaxKind.LockKeyword:
					break;
				default:
					throw new ArgumentException(nameof(lockKeyword));
			}
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
			if (statement == null)
				throw new ArgumentNullException(nameof(statement));
#endif

			return new LockStatementSyntax(SyntaxKind.LockStatement, lockKeyword, openParenToken, expression, closeParenToken, statement);
		}

		public static IfStatementSyntax IfStatement(SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax @else)
		{
#if DEBUG
			if (ifKeyword == null)
				throw new ArgumentNullException(nameof(ifKeyword));
			switch (ifKeyword.Kind)
			{
				case SyntaxKind.IfKeyword:
					break;
				default:
					throw new ArgumentException(nameof(ifKeyword));
			}
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (condition == null)
				throw new ArgumentNullException(nameof(condition));
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
			if (statement == null)
				throw new ArgumentNullException(nameof(statement));
#endif

			return new IfStatementSyntax(SyntaxKind.IfStatement, ifKeyword, openParenToken, condition, closeParenToken, statement, @else);
		}

		public static ElseClauseSyntax ElseClause(SyntaxToken elseKeyword, StatementSyntax statement)
		{
#if DEBUG
			if (elseKeyword == null)
				throw new ArgumentNullException(nameof(elseKeyword));
			switch (elseKeyword.Kind)
			{
				case SyntaxKind.ElseKeyword:
					break;
				default:
					throw new ArgumentException(nameof(elseKeyword));
			}
			if (statement == null)
				throw new ArgumentNullException(nameof(statement));
#endif
			var result = new ElseClauseSyntax(SyntaxKind.ElseClause, elseKeyword, statement);
			return result;
		}

		public static SwitchStatementSyntax SwitchStatement(SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, SyntaxList<SwitchSectionSyntax> sections, SyntaxToken closeBraceToken)
		{
#if DEBUG
			if (switchKeyword == null)
				throw new ArgumentNullException(nameof(switchKeyword));
			switch (switchKeyword.Kind)
			{
				case SyntaxKind.SwitchKeyword:
					break;
				default:
					throw new ArgumentException(nameof(switchKeyword));
			}
			if (openParenToken != null)
			{
				switch (openParenToken.Kind)
				{
					case SyntaxKind.OpenParenToken:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(openParenToken));
				}
			}
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
			if (closeParenToken != null)
			{
				switch (closeParenToken.Kind)
				{
					case SyntaxKind.CloseParenToken:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(closeParenToken));
				}
			}
			if (openBraceToken == null)
				throw new ArgumentNullException(nameof(openBraceToken));
			switch (openBraceToken.Kind)
			{
				case SyntaxKind.OpenBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(openBraceToken));
			}
			if (closeBraceToken == null)
				throw new ArgumentNullException(nameof(closeBraceToken));
			switch (closeBraceToken.Kind)
			{
				case SyntaxKind.CloseBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(closeBraceToken));
			}
#endif

			return new SwitchStatementSyntax(SyntaxKind.SwitchStatement, switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, sections.Node, closeBraceToken);
		}

		public static SwitchSectionSyntax SwitchSection(SyntaxList<SwitchLabelSyntax> labels, SyntaxList<StatementSyntax> statements)
		{
#if DEBUG
#endif
			var result = new SwitchSectionSyntax(SyntaxKind.SwitchSection, labels.Node, statements.Node);
			return result;
		}

		public static CasePatternSwitchLabelSyntax CasePatternSwitchLabel(SyntaxToken keyword, PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken colonToken)
		{
#if DEBUG
			if (keyword == null)
				throw new ArgumentNullException(nameof(keyword));
			switch (keyword.Kind)
			{
				case SyntaxKind.CaseKeyword:
					break;
				default:
					throw new ArgumentException(nameof(keyword));
			}
			if (pattern == null)
				throw new ArgumentNullException(nameof(pattern));
			if (colonToken == null)
				throw new ArgumentNullException(nameof(colonToken));
#endif

			return new CasePatternSwitchLabelSyntax(SyntaxKind.CasePatternSwitchLabel, keyword, pattern, whenClause, colonToken);
		}

		public static CaseSwitchLabelSyntax CaseSwitchLabel(SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken)
		{
#if DEBUG
			if (keyword == null)
				throw new ArgumentNullException(nameof(keyword));
			switch (keyword.Kind)
			{
				case SyntaxKind.CaseKeyword:
					break;
				default:
					throw new ArgumentException(nameof(keyword));
			}
			if (value == null)
				throw new ArgumentNullException(nameof(value));
			if (colonToken == null)
				throw new ArgumentNullException(nameof(colonToken));
#endif
			var result = new CaseSwitchLabelSyntax(SyntaxKind.CaseSwitchLabel, keyword, value, colonToken);
			return result;
		}

		public static DefaultSwitchLabelSyntax DefaultSwitchLabel(SyntaxToken keyword, SyntaxToken colonToken)
		{
#if DEBUG
			if (keyword == null)
				throw new ArgumentNullException(nameof(keyword));
			switch (keyword.Kind)
			{
				case SyntaxKind.DefaultKeyword:
					break;
				default:
					throw new ArgumentException(nameof(keyword));
			}
			if (colonToken == null)
				throw new ArgumentNullException(nameof(colonToken));
#endif
			var result = new DefaultSwitchLabelSyntax(SyntaxKind.DefaultSwitchLabel, keyword, colonToken);
			return result;
		}

		public static SwitchExpressionSyntax SwitchExpression(ExpressionSyntax governingExpression, SyntaxToken switchKeyword, SyntaxToken openBraceToken, SeparatedSyntaxList<SwitchExpressionArmSyntax> arms, SyntaxToken closeBraceToken)
		{
#if DEBUG
			if (governingExpression == null)
				throw new ArgumentNullException(nameof(governingExpression));
			if (switchKeyword == null)
				throw new ArgumentNullException(nameof(switchKeyword));
			switch (switchKeyword.Kind)
			{
				case SyntaxKind.SwitchKeyword:
					break;
				default:
					throw new ArgumentException(nameof(switchKeyword));
			}
			if (openBraceToken == null)
				throw new ArgumentNullException(nameof(openBraceToken));
			switch (openBraceToken.Kind)
			{
				case SyntaxKind.OpenBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(openBraceToken));
			}
			if (closeBraceToken == null)
				throw new ArgumentNullException(nameof(closeBraceToken));
			switch (closeBraceToken.Kind)
			{
				case SyntaxKind.CloseBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(closeBraceToken));
			}
#endif

			return new SwitchExpressionSyntax(SyntaxKind.SwitchExpression, governingExpression, switchKeyword, openBraceToken, arms.Node, closeBraceToken);
		}

		public static SwitchExpressionArmSyntax SwitchExpressionArm(PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken equalsGreaterThanToken, ExpressionSyntax expression)
		{
#if DEBUG
			if (pattern == null)
				throw new ArgumentNullException(nameof(pattern));
			if (equalsGreaterThanToken == null)
				throw new ArgumentNullException(nameof(equalsGreaterThanToken));
			switch (equalsGreaterThanToken.Kind)
			{
				case SyntaxKind.EqualsGreaterThanToken:
					break;
				default:
					throw new ArgumentException(nameof(equalsGreaterThanToken));
			}
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
#endif

			return new SwitchExpressionArmSyntax(SyntaxKind.SwitchExpressionArm, pattern, whenClause, equalsGreaterThanToken, expression);
		}

		public static TryStatementSyntax TryStatement(SyntaxToken tryKeyword, BlockSyntax block, SyntaxList<CatchClauseSyntax> catches, FinallyClauseSyntax @finally)
		{
#if DEBUG
			if (tryKeyword == null)
				throw new ArgumentNullException(nameof(tryKeyword));
			switch (tryKeyword.Kind)
			{
				case SyntaxKind.TryKeyword:
					break;
				default:
					throw new ArgumentException(nameof(tryKeyword));
			}
			if (block == null)
				throw new ArgumentNullException(nameof(block));
#endif

			return new TryStatementSyntax(SyntaxKind.TryStatement, tryKeyword, block, catches.Node, @finally);
		}

		public static CatchClauseSyntax CatchClause(SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block)
		{
#if DEBUG
			if (catchKeyword == null)
				throw new ArgumentNullException(nameof(catchKeyword));
			switch (catchKeyword.Kind)
			{
				case SyntaxKind.CatchKeyword:
					break;
				default:
					throw new ArgumentException(nameof(catchKeyword));
			}
			if (block == null)
				throw new ArgumentNullException(nameof(block));
#endif

			return new CatchClauseSyntax(SyntaxKind.CatchClause, catchKeyword, declaration, filter, block);
		}

		public static CatchDeclarationSyntax CatchDeclaration(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken)
		{
#if DEBUG
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (type == null)
				throw new ArgumentNullException(nameof(type));
			if (identifier != null)
			{
				switch (identifier.Kind)
				{
					case SyntaxKind.IdentifierToken:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(identifier));
				}
			}
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
#endif

			return new CatchDeclarationSyntax(SyntaxKind.CatchDeclaration, openParenToken, type, identifier, closeParenToken);
		}

		public static CatchFilterClauseSyntax CatchFilterClause(SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken)
		{
#if DEBUG
			if (whenKeyword == null)
				throw new ArgumentNullException(nameof(whenKeyword));
			switch (whenKeyword.Kind)
			{
				case SyntaxKind.WhenKeyword:
					break;
				default:
					throw new ArgumentException(nameof(whenKeyword));
			}
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (filterExpression == null)
				throw new ArgumentNullException(nameof(filterExpression));
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
#endif

			return new CatchFilterClauseSyntax(SyntaxKind.CatchFilterClause, whenKeyword, openParenToken, filterExpression, closeParenToken);
		}

		public static FinallyClauseSyntax FinallyClause(SyntaxToken finallyKeyword, BlockSyntax block)
		{
#if DEBUG
			if (finallyKeyword == null)
				throw new ArgumentNullException(nameof(finallyKeyword));
			switch (finallyKeyword.Kind)
			{
				case SyntaxKind.FinallyKeyword:
					break;
				default:
					throw new ArgumentException(nameof(finallyKeyword));
			}
			if (block == null)
				throw new ArgumentNullException(nameof(block));
#endif
			var result = new FinallyClauseSyntax(SyntaxKind.FinallyClause, finallyKeyword, block);
			return result;
		}

		public static CompilationUnitSyntax CompilationUnit(SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken endOfFileToken)
		{
#if DEBUG
			if (endOfFileToken == null)
				throw new ArgumentNullException(nameof(endOfFileToken));
			switch (endOfFileToken.Kind)
			{
				case SyntaxKind.EndOfFileToken:
					break;
				default:
					throw new ArgumentException(nameof(endOfFileToken));
			}
#endif

			return new CompilationUnitSyntax(SyntaxKind.CompilationUnit, externs.Node, usings.Node, attributeLists.Node, members.Node, endOfFileToken);
		}

		public static ExternAliasDirectiveSyntax ExternAliasDirective(SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (externKeyword == null)
				throw new ArgumentNullException(nameof(externKeyword));
			switch (externKeyword.Kind)
			{
				case SyntaxKind.ExternKeyword:
					break;
				default:
					throw new ArgumentException(nameof(externKeyword));
			}
			if (aliasKeyword == null)
				throw new ArgumentNullException(nameof(aliasKeyword));
			switch (aliasKeyword.Kind)
			{
				case SyntaxKind.AliasKeyword:
					break;
				default:
					throw new ArgumentException(nameof(aliasKeyword));
			}
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
			if (semicolonToken == null)
				throw new ArgumentNullException(nameof(semicolonToken));
			switch (semicolonToken.Kind)
			{
				case SyntaxKind.SemicolonToken:
					break;
				default:
					throw new ArgumentException(nameof(semicolonToken));
			}
#endif

			return new ExternAliasDirectiveSyntax(SyntaxKind.ExternAliasDirective, externKeyword, aliasKeyword, identifier, semicolonToken);
		}

		public static UsingDirectiveSyntax UsingDirective(SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (usingKeyword == null)
				throw new ArgumentNullException(nameof(usingKeyword));
			switch (usingKeyword.Kind)
			{
				case SyntaxKind.UsingKeyword:
					break;
				default:
					throw new ArgumentException(nameof(usingKeyword));
			}
			if (name == null)
				throw new ArgumentNullException(nameof(name));
			if (semicolonToken == null)
				throw new ArgumentNullException(nameof(semicolonToken));
			switch (semicolonToken.Kind)
			{
				case SyntaxKind.SemicolonToken:
					break;
				default:
					throw new ArgumentException(nameof(semicolonToken));
			}
#endif

			return new UsingDirectiveSyntax(SyntaxKind.UsingDirective, usingKeyword, staticKeyword, alias, name, semicolonToken);
		}

		public static NamespaceDeclarationSyntax NamespaceDeclaration(SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (namespaceKeyword == null)
				throw new ArgumentNullException(nameof(namespaceKeyword));
			switch (namespaceKeyword.Kind)
			{
				case SyntaxKind.NamespaceKeyword:
					break;
				default:
					throw new ArgumentException(nameof(namespaceKeyword));
			}
			if (name == null)
				throw new ArgumentNullException(nameof(name));
			if (openBraceToken == null)
				throw new ArgumentNullException(nameof(openBraceToken));
			switch (openBraceToken.Kind)
			{
				case SyntaxKind.OpenBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(openBraceToken));
			}
			if (closeBraceToken == null)
				throw new ArgumentNullException(nameof(closeBraceToken));
			switch (closeBraceToken.Kind)
			{
				case SyntaxKind.CloseBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(closeBraceToken));
			}
			if (semicolonToken != null)
			{
				switch (semicolonToken.Kind)
				{
					case SyntaxKind.SemicolonToken:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(semicolonToken));
				}
			}
#endif

			return new NamespaceDeclarationSyntax(SyntaxKind.NamespaceDeclaration, namespaceKeyword, name, openBraceToken, externs.Node, usings.Node, members.Node, closeBraceToken, semicolonToken);
		}

		public static AttributeListSyntax AttributeList(SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax target, SeparatedSyntaxList<AttributeSyntax> attributes, SyntaxToken closeBracketToken)
		{
#if DEBUG
			if (openBracketToken == null)
				throw new ArgumentNullException(nameof(openBracketToken));
			switch (openBracketToken.Kind)
			{
				case SyntaxKind.OpenBracketToken:
					break;
				default:
					throw new ArgumentException(nameof(openBracketToken));
			}
			if (closeBracketToken == null)
				throw new ArgumentNullException(nameof(closeBracketToken));
			switch (closeBracketToken.Kind)
			{
				case SyntaxKind.CloseBracketToken:
					break;
				default:
					throw new ArgumentException(nameof(closeBracketToken));
			}
#endif

			return new AttributeListSyntax(SyntaxKind.AttributeList, openBracketToken, target, attributes.Node, closeBracketToken);
		}

		public static AttributeTargetSpecifierSyntax AttributeTargetSpecifier(SyntaxToken identifier, SyntaxToken colonToken)
		{
#if DEBUG
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			if (colonToken == null)
				throw new ArgumentNullException(nameof(colonToken));
			switch (colonToken.Kind)
			{
				case SyntaxKind.ColonToken:
					break;
				default:
					throw new ArgumentException(nameof(colonToken));
			}
#endif
			var result = new AttributeTargetSpecifierSyntax(SyntaxKind.AttributeTargetSpecifier, identifier, colonToken);
			return result;
		}

		public static AttributeSyntax Attribute(NameSyntax name, AttributeArgumentListSyntax argumentList)
		{
#if DEBUG
			if (name == null)
				throw new ArgumentNullException(nameof(name));
#endif

			var result = new AttributeSyntax(SyntaxKind.Attribute, name, argumentList);

			return result;
		}

		public static AttributeArgumentListSyntax AttributeArgumentList(SyntaxToken openParenToken, SeparatedSyntaxList<AttributeArgumentSyntax> arguments, SyntaxToken closeParenToken)
		{
#if DEBUG
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
#endif

			var result = new AttributeArgumentListSyntax(SyntaxKind.AttributeArgumentList, openParenToken, arguments.Node, closeParenToken);
			return result;
		}

		public static AttributeArgumentSyntax AttributeArgument(NameEqualsSyntax nameEquals, NameColonSyntax nameColon, ExpressionSyntax expression)
		{
#if DEBUG
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
#endif
			var result = new AttributeArgumentSyntax(SyntaxKind.AttributeArgument, nameEquals, nameColon, expression);

			return result;
		}

		public static NameEqualsSyntax NameEquals(IdentifierNameSyntax name, SyntaxToken equalsToken)
		{
#if DEBUG
			if (name == null)
				throw new ArgumentNullException(nameof(name));
			if (equalsToken == null)
				throw new ArgumentNullException(nameof(equalsToken));
			switch (equalsToken.Kind)
			{
				case SyntaxKind.EqualsToken:
					break;
				default:
					throw new ArgumentException(nameof(equalsToken));
			}
#endif
			var result = new NameEqualsSyntax(SyntaxKind.NameEquals, name, equalsToken);
			return result;
		}

		public static TypeParameterListSyntax TypeParameterList(SyntaxToken lessThanToken, SeparatedSyntaxList<TypeParameterSyntax> parameters, SyntaxToken greaterThanToken)
		{
#if DEBUG
			if (lessThanToken == null)
				throw new ArgumentNullException(nameof(lessThanToken));
			switch (lessThanToken.Kind)
			{
				case SyntaxKind.LessThanToken:
					break;
				default:
					throw new ArgumentException(nameof(lessThanToken));
			}
			if (greaterThanToken == null)
				throw new ArgumentNullException(nameof(greaterThanToken));
			switch (greaterThanToken.Kind)
			{
				case SyntaxKind.GreaterThanToken:
					break;
				default:
					throw new ArgumentException(nameof(greaterThanToken));
			}
#endif

			var result = new TypeParameterListSyntax(SyntaxKind.TypeParameterList, lessThanToken, parameters.Node, greaterThanToken);

			return result;
		}

		public static TypeParameterSyntax TypeParameter(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken varianceKeyword, SyntaxToken identifier)
		{
#if DEBUG
			if (varianceKeyword != null)
			{
				switch (varianceKeyword.Kind)
				{
					case SyntaxKind.InKeyword:
					case SyntaxKind.OutKeyword:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(varianceKeyword));
				}
			}
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
#endif
			var result = new TypeParameterSyntax(SyntaxKind.TypeParameter, attributeLists.Node, varianceKeyword, identifier);
			return result;
		}

		public static ClassDeclarationSyntax ClassDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (keyword == null)
				throw new ArgumentNullException(nameof(keyword));
			switch (keyword.Kind)
			{
				case SyntaxKind.ClassKeyword:
					break;
				default:
					throw new ArgumentException(nameof(keyword));
			}
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
			if (openBraceToken == null)
				throw new ArgumentNullException(nameof(openBraceToken));
			switch (openBraceToken.Kind)
			{
				case SyntaxKind.OpenBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(openBraceToken));
			}
			if (closeBraceToken == null)
				throw new ArgumentNullException(nameof(closeBraceToken));
			switch (closeBraceToken.Kind)
			{
				case SyntaxKind.CloseBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(closeBraceToken));
			}
			if (semicolonToken != null)
			{
				switch (semicolonToken.Kind)
				{
					case SyntaxKind.SemicolonToken:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(semicolonToken));
				}
			}
#endif

			return new ClassDeclarationSyntax(SyntaxKind.ClassDeclaration, attributeLists.Node, modifiers.Node, keyword, identifier, typeParameterList, baseList, constraintClauses.Node, openBraceToken, members.Node, closeBraceToken, semicolonToken);
		}

		public static StructDeclarationSyntax StructDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (keyword == null)
				throw new ArgumentNullException(nameof(keyword));
			switch (keyword.Kind)
			{
				case SyntaxKind.StructKeyword:
					break;
				default:
					throw new ArgumentException(nameof(keyword));
			}
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
			if (openBraceToken == null)
				throw new ArgumentNullException(nameof(openBraceToken));
			switch (openBraceToken.Kind)
			{
				case SyntaxKind.OpenBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(openBraceToken));
			}
			if (closeBraceToken == null)
				throw new ArgumentNullException(nameof(closeBraceToken));
			switch (closeBraceToken.Kind)
			{
				case SyntaxKind.CloseBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(closeBraceToken));
			}
			if (semicolonToken != null)
			{
				switch (semicolonToken.Kind)
				{
					case SyntaxKind.SemicolonToken:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(semicolonToken));
				}
			}
#endif

			return new StructDeclarationSyntax(SyntaxKind.StructDeclaration, attributeLists.Node, modifiers.Node, keyword, identifier, typeParameterList, baseList, constraintClauses.Node, openBraceToken, members.Node, closeBraceToken, semicolonToken);
		}

		public static InterfaceDeclarationSyntax InterfaceDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (keyword == null)
				throw new ArgumentNullException(nameof(keyword));
			switch (keyword.Kind)
			{
				case SyntaxKind.InterfaceKeyword:
					break;
				default:
					throw new ArgumentException(nameof(keyword));
			}
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
			if (openBraceToken == null)
				throw new ArgumentNullException(nameof(openBraceToken));
			switch (openBraceToken.Kind)
			{
				case SyntaxKind.OpenBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(openBraceToken));
			}
			if (closeBraceToken == null)
				throw new ArgumentNullException(nameof(closeBraceToken));
			switch (closeBraceToken.Kind)
			{
				case SyntaxKind.CloseBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(closeBraceToken));
			}
			if (semicolonToken != null)
			{
				switch (semicolonToken.Kind)
				{
					case SyntaxKind.SemicolonToken:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(semicolonToken));
				}
			}
#endif

			return new InterfaceDeclarationSyntax(SyntaxKind.InterfaceDeclaration, attributeLists.Node, modifiers.Node, keyword, identifier, typeParameterList, baseList, constraintClauses.Node, openBraceToken, members.Node, closeBraceToken, semicolonToken);
		}

		public static EnumDeclarationSyntax EnumDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax baseList, SyntaxToken openBraceToken, SeparatedSyntaxList<EnumMemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (enumKeyword == null)
				throw new ArgumentNullException(nameof(enumKeyword));
			switch (enumKeyword.Kind)
			{
				case SyntaxKind.EnumKeyword:
					break;
				default:
					throw new ArgumentException(nameof(enumKeyword));
			}
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
			if (openBraceToken == null)
				throw new ArgumentNullException(nameof(openBraceToken));
			switch (openBraceToken.Kind)
			{
				case SyntaxKind.OpenBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(openBraceToken));
			}
			if (closeBraceToken == null)
				throw new ArgumentNullException(nameof(closeBraceToken));
			switch (closeBraceToken.Kind)
			{
				case SyntaxKind.CloseBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(closeBraceToken));
			}
			if (semicolonToken != null)
			{
				switch (semicolonToken.Kind)
				{
					case SyntaxKind.SemicolonToken:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(semicolonToken));
				}
			}
#endif

			return new EnumDeclarationSyntax(SyntaxKind.EnumDeclaration, attributeLists.Node, modifiers.Node, enumKeyword, identifier, baseList, openBraceToken, members.Node, closeBraceToken, semicolonToken);
		}

		public static DelegateDeclarationSyntax DelegateDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (delegateKeyword == null)
				throw new ArgumentNullException(nameof(delegateKeyword));
			switch (delegateKeyword.Kind)
			{
				case SyntaxKind.DelegateKeyword:
					break;
				default:
					throw new ArgumentException(nameof(delegateKeyword));
			}
			if (returnType == null)
				throw new ArgumentNullException(nameof(returnType));
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
			if (parameterList == null)
				throw new ArgumentNullException(nameof(parameterList));
			if (semicolonToken == null)
				throw new ArgumentNullException(nameof(semicolonToken));
			switch (semicolonToken.Kind)
			{
				case SyntaxKind.SemicolonToken:
					break;
				default:
					throw new ArgumentException(nameof(semicolonToken));
			}
#endif

			return new DelegateDeclarationSyntax(SyntaxKind.DelegateDeclaration, attributeLists.Node, modifiers.Node, delegateKeyword, returnType, identifier, typeParameterList, parameterList, constraintClauses.Node, semicolonToken);
		}

		public static EnumMemberDeclarationSyntax EnumMemberDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue)
		{
#if DEBUG
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
#endif
			var result = new EnumMemberDeclarationSyntax(SyntaxKind.EnumMemberDeclaration, attributeLists.Node, identifier, equalsValue);
			return result;
		}

		public static BaseListSyntax BaseList(SyntaxToken colonToken, SeparatedSyntaxList<BaseTypeSyntax> types)
		{
#if DEBUG
			if (colonToken == null)
				throw new ArgumentNullException(nameof(colonToken));
			switch (colonToken.Kind)
			{
				case SyntaxKind.ColonToken:
					break;
				default:
					throw new ArgumentException(nameof(colonToken));
			}
#endif

			var result = new BaseListSyntax(SyntaxKind.BaseList, colonToken, types.Node);
			return result;
		}

		public static SimpleBaseTypeSyntax SimpleBaseType(TypeSyntax type)
		{
#if DEBUG
			if (type == null)
				throw new ArgumentNullException(nameof(type));
#endif

			var result = new SimpleBaseTypeSyntax(SyntaxKind.SimpleBaseType, type);

			return result;
		}

		public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, SeparatedSyntaxList<TypeParameterConstraintSyntax> constraints)
		{
#if DEBUG
			if (whereKeyword == null)
				throw new ArgumentNullException(nameof(whereKeyword));
			switch (whereKeyword.Kind)
			{
				case SyntaxKind.WhereKeyword:
					break;
				default:
					throw new ArgumentException(nameof(whereKeyword));
			}
			if (name == null)
				throw new ArgumentNullException(nameof(name));
			if (colonToken == null)
				throw new ArgumentNullException(nameof(colonToken));
			switch (colonToken.Kind)
			{
				case SyntaxKind.ColonToken:
					break;
				default:
					throw new ArgumentException(nameof(colonToken));
			}
#endif

			return new TypeParameterConstraintClauseSyntax(SyntaxKind.TypeParameterConstraintClause, whereKeyword, name, colonToken, constraints.Node);
		}

		public static ConstructorConstraintSyntax ConstructorConstraint(SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken)
		{
#if DEBUG
			if (newKeyword == null)
				throw new ArgumentNullException(nameof(newKeyword));
			switch (newKeyword.Kind)
			{
				case SyntaxKind.NewKeyword:
					break;
				default:
					throw new ArgumentException(nameof(newKeyword));
			}
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
#endif
			var result = new ConstructorConstraintSyntax(SyntaxKind.ConstructorConstraint, newKeyword, openParenToken, closeParenToken);
			return result;
		}

		public static ClassOrStructConstraintSyntax ClassOrStructConstraint(SyntaxKind kind, SyntaxToken classOrStructKeyword, SyntaxToken questionToken)
		{
			switch (kind)
			{
				case SyntaxKind.ClassConstraint:
				case SyntaxKind.StructConstraint:
					break;
				default:
					throw new ArgumentException(nameof(kind));
			}
#if DEBUG
			if (classOrStructKeyword == null)
				throw new ArgumentNullException(nameof(classOrStructKeyword));
			switch (classOrStructKeyword.Kind)
			{
				case SyntaxKind.ClassKeyword:
				case SyntaxKind.StructKeyword:
					break;
				default:
					throw new ArgumentException(nameof(classOrStructKeyword));
			}
			if (questionToken != null)
			{
				switch (questionToken.Kind)
				{
					case SyntaxKind.QuestionToken:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(questionToken));
				}
			}
#endif

			var result = new ClassOrStructConstraintSyntax(kind, classOrStructKeyword, questionToken);

			return result;
		}

		public static TypeConstraintSyntax TypeConstraint(TypeSyntax type)
		{
#if DEBUG
			if (type == null)
				throw new ArgumentNullException(nameof(type));
#endif
			var result = new TypeConstraintSyntax(SyntaxKind.TypeConstraint, type);
			return result;
		}

		public static FieldDeclarationSyntax FieldDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (declaration == null)
				throw new ArgumentNullException(nameof(declaration));
			if (semicolonToken == null)
				throw new ArgumentNullException(nameof(semicolonToken));
			switch (semicolonToken.Kind)
			{
				case SyntaxKind.SemicolonToken:
					break;
				default:
					throw new ArgumentException(nameof(semicolonToken));
			}
#endif

			return new FieldDeclarationSyntax(SyntaxKind.FieldDeclaration, attributeLists.Node, modifiers.Node, declaration, semicolonToken);
		}

		public static EventFieldDeclarationSyntax EventFieldDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (eventKeyword == null)
				throw new ArgumentNullException(nameof(eventKeyword));
			switch (eventKeyword.Kind)
			{
				case SyntaxKind.EventKeyword:
					break;
				default:
					throw new ArgumentException(nameof(eventKeyword));
			}
			if (declaration == null)
				throw new ArgumentNullException(nameof(declaration));
			if (semicolonToken == null)
				throw new ArgumentNullException(nameof(semicolonToken));
			switch (semicolonToken.Kind)
			{
				case SyntaxKind.SemicolonToken:
					break;
				default:
					throw new ArgumentException(nameof(semicolonToken));
			}
#endif

			return new EventFieldDeclarationSyntax(SyntaxKind.EventFieldDeclaration, attributeLists.Node, modifiers.Node, eventKeyword, declaration, semicolonToken);
		}

		public static ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier(NameSyntax name, SyntaxToken dotToken)
		{
#if DEBUG
			if (name == null)
				throw new ArgumentNullException(nameof(name));
			if (dotToken == null)
				throw new ArgumentNullException(nameof(dotToken));
			switch (dotToken.Kind)
			{
				case SyntaxKind.DotToken:
					break;
				default:
					throw new ArgumentException(nameof(dotToken));
			}
#endif
			var result = new ExplicitInterfaceSpecifierSyntax(SyntaxKind.ExplicitInterfaceSpecifier, name, dotToken);
			return result;
		}

		public static MethodDeclarationSyntax MethodDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (returnType == null)
				throw new ArgumentNullException(nameof(returnType));
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
			if (parameterList == null)
				throw new ArgumentNullException(nameof(parameterList));
			if (semicolonToken != null)
			{
				switch (semicolonToken.Kind)
				{
					case SyntaxKind.SemicolonToken:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(semicolonToken));
				}
			}
#endif

			return new MethodDeclarationSyntax(SyntaxKind.MethodDeclaration, attributeLists.Node, modifiers.Node, returnType, explicitInterfaceSpecifier, identifier, typeParameterList, parameterList, constraintClauses.Node, body, expressionBody, semicolonToken);
		}

		public static OperatorDeclarationSyntax OperatorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (returnType == null)
				throw new ArgumentNullException(nameof(returnType));
			if (operatorKeyword == null)
				throw new ArgumentNullException(nameof(operatorKeyword));
			switch (operatorKeyword.Kind)
			{
				case SyntaxKind.OperatorKeyword:
					break;
				default:
					throw new ArgumentException(nameof(operatorKeyword));
			}
			if (operatorToken == null)
				throw new ArgumentNullException(nameof(operatorToken));
			switch (operatorToken.Kind)
			{
				case SyntaxKind.PlusToken:
				case SyntaxKind.MinusToken:
				case SyntaxKind.ExclamationToken:
				case SyntaxKind.TildeToken:
				case SyntaxKind.PlusPlusToken:
				case SyntaxKind.MinusMinusToken:
				case SyntaxKind.AsteriskToken:
				case SyntaxKind.SlashToken:
				case SyntaxKind.PercentToken:
				case SyntaxKind.LessThanLessThanToken:
				case SyntaxKind.GreaterThanGreaterThanToken:
				case SyntaxKind.BarToken:
				case SyntaxKind.AmpersandToken:
				case SyntaxKind.CaretToken:
				case SyntaxKind.EqualsEqualsToken:
				case SyntaxKind.ExclamationEqualsToken:
				case SyntaxKind.LessThanToken:
				case SyntaxKind.LessThanEqualsToken:
				case SyntaxKind.GreaterThanToken:
				case SyntaxKind.GreaterThanEqualsToken:
				case SyntaxKind.FalseKeyword:
				case SyntaxKind.TrueKeyword:
				case SyntaxKind.IsKeyword:
					break;
				default:
					throw new ArgumentException(nameof(operatorToken));
			}
			if (parameterList == null)
				throw new ArgumentNullException(nameof(parameterList));
			if (semicolonToken != null)
			{
				switch (semicolonToken.Kind)
				{
					case SyntaxKind.SemicolonToken:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(semicolonToken));
				}
			}
#endif

			return new OperatorDeclarationSyntax(SyntaxKind.OperatorDeclaration, attributeLists.Node, modifiers.Node, returnType, operatorKeyword, operatorToken, parameterList, body, expressionBody, semicolonToken);
		}

		public static ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (implicitOrExplicitKeyword == null)
				throw new ArgumentNullException(nameof(implicitOrExplicitKeyword));
			switch (implicitOrExplicitKeyword.Kind)
			{
				case SyntaxKind.ImplicitKeyword:
				case SyntaxKind.ExplicitKeyword:
					break;
				default:
					throw new ArgumentException(nameof(implicitOrExplicitKeyword));
			}
			if (operatorKeyword == null)
				throw new ArgumentNullException(nameof(operatorKeyword));
			switch (operatorKeyword.Kind)
			{
				case SyntaxKind.OperatorKeyword:
					break;
				default:
					throw new ArgumentException(nameof(operatorKeyword));
			}
			if (type == null)
				throw new ArgumentNullException(nameof(type));
			if (parameterList == null)
				throw new ArgumentNullException(nameof(parameterList));
			if (semicolonToken != null)
			{
				switch (semicolonToken.Kind)
				{
					case SyntaxKind.SemicolonToken:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(semicolonToken));
				}
			}
#endif

			return new ConversionOperatorDeclarationSyntax(SyntaxKind.ConversionOperatorDeclaration, attributeLists.Node, modifiers.Node, implicitOrExplicitKeyword, operatorKeyword, type, parameterList, body, expressionBody, semicolonToken);
		}

		public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
			if (parameterList == null)
				throw new ArgumentNullException(nameof(parameterList));
			if (semicolonToken != null)
			{
				switch (semicolonToken.Kind)
				{
					case SyntaxKind.SemicolonToken:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(semicolonToken));
				}
			}
#endif

			return new ConstructorDeclarationSyntax(SyntaxKind.ConstructorDeclaration, attributeLists.Node, modifiers.Node, identifier, parameterList, initializer, body, expressionBody, semicolonToken);
		}

		public static ConstructorInitializerSyntax ConstructorInitializer(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList)
		{
			switch (kind)
			{
				case SyntaxKind.BaseConstructorInitializer:
				case SyntaxKind.ThisConstructorInitializer:
					break;
				default:
					throw new ArgumentException(nameof(kind));
			}
#if DEBUG
			if (colonToken == null)
				throw new ArgumentNullException(nameof(colonToken));
			switch (colonToken.Kind)
			{
				case SyntaxKind.ColonToken:
					break;
				default:
					throw new ArgumentException(nameof(colonToken));
			}
			if (thisOrBaseKeyword == null)
				throw new ArgumentNullException(nameof(thisOrBaseKeyword));
			switch (thisOrBaseKeyword.Kind)
			{
				case SyntaxKind.BaseKeyword:
				case SyntaxKind.ThisKeyword:
					break;
				default:
					throw new ArgumentException(nameof(thisOrBaseKeyword));
			}
			if (argumentList == null)
				throw new ArgumentNullException(nameof(argumentList));
#endif

			var result = new ConstructorInitializerSyntax(kind, colonToken, thisOrBaseKeyword, argumentList);

			return result;
		}

		public static DestructorDeclarationSyntax DestructorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (tildeToken == null)
				throw new ArgumentNullException(nameof(tildeToken));
			switch (tildeToken.Kind)
			{
				case SyntaxKind.TildeToken:
					break;
				default:
					throw new ArgumentException(nameof(tildeToken));
			}
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
			if (parameterList == null)
				throw new ArgumentNullException(nameof(parameterList));
			if (semicolonToken != null)
			{
				switch (semicolonToken.Kind)
				{
					case SyntaxKind.SemicolonToken:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(semicolonToken));
				}
			}
#endif

			return new DestructorDeclarationSyntax(SyntaxKind.DestructorDeclaration, attributeLists.Node, modifiers.Node, tildeToken, identifier, parameterList, body, expressionBody, semicolonToken);
		}

		public static PropertyDeclarationSyntax PropertyDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (type == null)
				throw new ArgumentNullException(nameof(type));
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
			if (semicolonToken != null)
			{
				switch (semicolonToken.Kind)
				{
					case SyntaxKind.SemicolonToken:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(semicolonToken));
				}
			}
#endif

			return new PropertyDeclarationSyntax(SyntaxKind.PropertyDeclaration, attributeLists.Node, modifiers.Node, type, explicitInterfaceSpecifier, identifier, accessorList, expressionBody, initializer, semicolonToken);
		}

		public static ArrowExpressionClauseSyntax ArrowExpressionClause(SyntaxToken arrowToken, ExpressionSyntax expression)
		{
#if DEBUG
			if (arrowToken == null)
				throw new ArgumentNullException(nameof(arrowToken));
			switch (arrowToken.Kind)
			{
				case SyntaxKind.EqualsGreaterThanToken:
					break;
				default:
					throw new ArgumentException(nameof(arrowToken));
			}
			if (expression == null)
				throw new ArgumentNullException(nameof(expression));
#endif
			var result = new ArrowExpressionClauseSyntax(SyntaxKind.ArrowExpressionClause, arrowToken, expression);
			return result;
		}

		public static EventDeclarationSyntax EventDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList)
		{
#if DEBUG
			if (eventKeyword == null)
				throw new ArgumentNullException(nameof(eventKeyword));
			switch (eventKeyword.Kind)
			{
				case SyntaxKind.EventKeyword:
					break;
				default:
					throw new ArgumentException(nameof(eventKeyword));
			}
			if (type == null)
				throw new ArgumentNullException(nameof(type));
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
			if (accessorList == null)
				throw new ArgumentNullException(nameof(accessorList));
#endif

			return new EventDeclarationSyntax(SyntaxKind.EventDeclaration, attributeLists.Node, modifiers.Node, eventKeyword, type, explicitInterfaceSpecifier, identifier, accessorList);
		}

		public static IndexerDeclarationSyntax IndexerDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
		{
#if DEBUG
			if (type == null)
				throw new ArgumentNullException(nameof(type));
			if (thisKeyword == null)
				throw new ArgumentNullException(nameof(thisKeyword));
			switch (thisKeyword.Kind)
			{
				case SyntaxKind.ThisKeyword:
					break;
				default:
					throw new ArgumentException(nameof(thisKeyword));
			}
			if (parameterList == null)
				throw new ArgumentNullException(nameof(parameterList));
			if (semicolonToken != null)
			{
				switch (semicolonToken.Kind)
				{
					case SyntaxKind.SemicolonToken:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(semicolonToken));
				}
			}
#endif

			return new IndexerDeclarationSyntax(SyntaxKind.IndexerDeclaration, attributeLists.Node, modifiers.Node, type, explicitInterfaceSpecifier, thisKeyword, parameterList, accessorList, expressionBody, semicolonToken);
		}

		public static AccessorListSyntax AccessorList(SyntaxToken openBraceToken, SyntaxList<AccessorDeclarationSyntax> accessors, SyntaxToken closeBraceToken)
		{
#if DEBUG
			if (openBraceToken == null)
				throw new ArgumentNullException(nameof(openBraceToken));
			switch (openBraceToken.Kind)
			{
				case SyntaxKind.OpenBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(openBraceToken));
			}
			if (closeBraceToken == null)
				throw new ArgumentNullException(nameof(closeBraceToken));
			switch (closeBraceToken.Kind)
			{
				case SyntaxKind.CloseBraceToken:
					break;
				default:
					throw new ArgumentException(nameof(closeBraceToken));
			}
#endif

			var result = new AccessorListSyntax(SyntaxKind.AccessorList, openBraceToken, accessors.Node, closeBraceToken);
			return result;
		}

		public static AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
		{
			switch (kind)
			{
				case SyntaxKind.GetAccessorDeclaration:
				case SyntaxKind.SetAccessorDeclaration:
				case SyntaxKind.AddAccessorDeclaration:
				case SyntaxKind.RemoveAccessorDeclaration:
				case SyntaxKind.UnknownAccessorDeclaration:
					break;
				default:
					throw new ArgumentException(nameof(kind));
			}
#if DEBUG
			if (keyword == null)
				throw new ArgumentNullException(nameof(keyword));
			switch (keyword.Kind)
			{
				case SyntaxKind.GetKeyword:
				case SyntaxKind.SetKeyword:
				case SyntaxKind.AddKeyword:
				case SyntaxKind.RemoveKeyword:
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(keyword));
			}
			if (semicolonToken != null)
			{
				switch (semicolonToken.Kind)
				{
					case SyntaxKind.SemicolonToken:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(semicolonToken));
				}
			}
#endif

			return new AccessorDeclarationSyntax(kind, attributeLists.Node, modifiers.Node, keyword, body, expressionBody, semicolonToken);
		}

		public static ParameterListSyntax ParameterList(SyntaxToken openParenToken, SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeParenToken)
		{
#if DEBUG
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
#endif

			var result = new ParameterListSyntax(SyntaxKind.ParameterList, openParenToken, parameters.Node, closeParenToken);
			return result;
		}

		public static BracketedParameterListSyntax BracketedParameterList(SyntaxToken openBracketToken, SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeBracketToken)
		{
#if DEBUG
			if (openBracketToken == null)
				throw new ArgumentNullException(nameof(openBracketToken));
			switch (openBracketToken.Kind)
			{
				case SyntaxKind.OpenBracketToken:
					break;
				default:
					throw new ArgumentException(nameof(openBracketToken));
			}
			if (closeBracketToken == null)
				throw new ArgumentNullException(nameof(closeBracketToken));
			switch (closeBracketToken.Kind)
			{
				case SyntaxKind.CloseBracketToken:
					break;
				default:
					throw new ArgumentException(nameof(closeBracketToken));
			}
#endif

			var result = new BracketedParameterListSyntax(SyntaxKind.BracketedParameterList, openBracketToken, parameters.Node, closeBracketToken);
			return result;
		}

		public static ParameterSyntax Parameter(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax @default)
		{
#if DEBUG
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			switch (identifier.Kind)
			{
				case SyntaxKind.IdentifierToken:
				case SyntaxKind.ArgListKeyword:
					break;
				default:
					throw new ArgumentException(nameof(identifier));
			}
#endif

			return new ParameterSyntax(SyntaxKind.Parameter, attributeLists.Node, modifiers.Node, type, identifier, @default);
		}

		public static IncompleteMemberSyntax IncompleteMember(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, TypeSyntax type)
		{
#if DEBUG
#endif

			return new IncompleteMemberSyntax(SyntaxKind.IncompleteMember, attributeLists.Node, modifiers.Node, type);
		}

		public static SkippedTokensTriviaSyntax SkippedTokensTrivia(SyntaxList<SyntaxToken> tokens)
		{
#if DEBUG
#endif

			return new SkippedTokensTriviaSyntax(SyntaxKind.SkippedTokensTrivia, tokens.Node);
		}

		public static TypeCrefSyntax TypeCref(TypeSyntax type)
		{
#if DEBUG
			if (type == null)
				throw new ArgumentNullException(nameof(type));
#endif

			var result = new TypeCrefSyntax(SyntaxKind.TypeCref, type);
			return result;
		}

		public static QualifiedCrefSyntax QualifiedCref(TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member)
		{
#if DEBUG
			if (container == null)
				throw new ArgumentNullException(nameof(container));
			if (dotToken == null)
				throw new ArgumentNullException(nameof(dotToken));
			switch (dotToken.Kind)
			{
				case SyntaxKind.DotToken:
					break;
				default:
					throw new ArgumentException(nameof(dotToken));
			}
			if (member == null)
				throw new ArgumentNullException(nameof(member));
#endif
			var result = new QualifiedCrefSyntax(SyntaxKind.QualifiedCref, container, dotToken, member);
			return result;
		}

		public static NameMemberCrefSyntax NameMemberCref(TypeSyntax name, CrefParameterListSyntax parameters)
		{
#if DEBUG
			if (name == null)
				throw new ArgumentNullException(nameof(name));
#endif
			var result = new NameMemberCrefSyntax(SyntaxKind.NameMemberCref, name, parameters);
			return result;
		}

		public static IndexerMemberCrefSyntax IndexerMemberCref(SyntaxToken thisKeyword, CrefBracketedParameterListSyntax parameters)
		{
#if DEBUG
			if (thisKeyword == null)
				throw new ArgumentNullException(nameof(thisKeyword));
			switch (thisKeyword.Kind)
			{
				case SyntaxKind.ThisKeyword:
					break;
				default:
					throw new ArgumentException(nameof(thisKeyword));
			}
#endif
			var result = new IndexerMemberCrefSyntax(SyntaxKind.IndexerMemberCref, thisKeyword, parameters);
			return result;
		}

		public static OperatorMemberCrefSyntax OperatorMemberCref(SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax parameters)
		{
#if DEBUG
			if (operatorKeyword == null)
				throw new ArgumentNullException(nameof(operatorKeyword));
			switch (operatorKeyword.Kind)
			{
				case SyntaxKind.OperatorKeyword:
					break;
				default:
					throw new ArgumentException(nameof(operatorKeyword));
			}
			if (operatorToken == null)
				throw new ArgumentNullException(nameof(operatorToken));
			switch (operatorToken.Kind)
			{
				case SyntaxKind.PlusToken:
				case SyntaxKind.MinusToken:
				case SyntaxKind.ExclamationToken:
				case SyntaxKind.TildeToken:
				case SyntaxKind.PlusPlusToken:
				case SyntaxKind.MinusMinusToken:
				case SyntaxKind.AsteriskToken:
				case SyntaxKind.SlashToken:
				case SyntaxKind.PercentToken:
				case SyntaxKind.LessThanLessThanToken:
				case SyntaxKind.GreaterThanGreaterThanToken:
				case SyntaxKind.BarToken:
				case SyntaxKind.AmpersandToken:
				case SyntaxKind.CaretToken:
				case SyntaxKind.EqualsEqualsToken:
				case SyntaxKind.ExclamationEqualsToken:
				case SyntaxKind.LessThanToken:
				case SyntaxKind.LessThanEqualsToken:
				case SyntaxKind.GreaterThanToken:
				case SyntaxKind.GreaterThanEqualsToken:
				case SyntaxKind.FalseKeyword:
				case SyntaxKind.TrueKeyword:
					break;
				default:
					throw new ArgumentException(nameof(operatorToken));
			}
#endif
			var result = new OperatorMemberCrefSyntax(SyntaxKind.OperatorMemberCref, operatorKeyword, operatorToken, parameters);
			return result;
		}

		public static ConversionOperatorMemberCrefSyntax ConversionOperatorMemberCref(SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax parameters)
		{
#if DEBUG
			if (implicitOrExplicitKeyword == null)
				throw new ArgumentNullException(nameof(implicitOrExplicitKeyword));
			switch (implicitOrExplicitKeyword.Kind)
			{
				case SyntaxKind.ImplicitKeyword:
				case SyntaxKind.ExplicitKeyword:
					break;
				default:
					throw new ArgumentException(nameof(implicitOrExplicitKeyword));
			}
			if (operatorKeyword == null)
				throw new ArgumentNullException(nameof(operatorKeyword));
			switch (operatorKeyword.Kind)
			{
				case SyntaxKind.OperatorKeyword:
					break;
				default:
					throw new ArgumentException(nameof(operatorKeyword));
			}
			if (type == null)
				throw new ArgumentNullException(nameof(type));
#endif

			return new ConversionOperatorMemberCrefSyntax(SyntaxKind.ConversionOperatorMemberCref, implicitOrExplicitKeyword, operatorKeyword, type, parameters);
		}

		public static CrefParameterListSyntax CrefParameterList(SyntaxToken openParenToken, SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeParenToken)
		{
#if DEBUG
			if (openParenToken == null)
				throw new ArgumentNullException(nameof(openParenToken));
			switch (openParenToken.Kind)
			{
				case SyntaxKind.OpenParenToken:
					break;
				default:
					throw new ArgumentException(nameof(openParenToken));
			}
			if (closeParenToken == null)
				throw new ArgumentNullException(nameof(closeParenToken));
			switch (closeParenToken.Kind)
			{
				case SyntaxKind.CloseParenToken:
					break;
				default:
					throw new ArgumentException(nameof(closeParenToken));
			}
#endif
			var result = new CrefParameterListSyntax(SyntaxKind.CrefParameterList, openParenToken, parameters.Node, closeParenToken);
			return result;
		}

		public static CrefBracketedParameterListSyntax CrefBracketedParameterList(SyntaxToken openBracketToken, SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeBracketToken)
		{
#if DEBUG
			if (openBracketToken == null)
				throw new ArgumentNullException(nameof(openBracketToken));
			switch (openBracketToken.Kind)
			{
				case SyntaxKind.OpenBracketToken:
					break;
				default:
					throw new ArgumentException(nameof(openBracketToken));
			}
			if (closeBracketToken == null)
				throw new ArgumentNullException(nameof(closeBracketToken));
			switch (closeBracketToken.Kind)
			{
				case SyntaxKind.CloseBracketToken:
					break;
				default:
					throw new ArgumentException(nameof(closeBracketToken));
			}
#endif
			var result = new CrefBracketedParameterListSyntax(SyntaxKind.CrefBracketedParameterList, openBracketToken, parameters.Node, closeBracketToken);
			return result;
		}

		public static CrefParameterSyntax CrefParameter(SyntaxToken refKindKeyword, TypeSyntax type)
		{
#if DEBUG
			if (refKindKeyword != null)
			{
				switch (refKindKeyword.Kind)
				{
					case SyntaxKind.RefKeyword:
					case SyntaxKind.OutKeyword:
					case SyntaxKind.InKeyword:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(refKindKeyword));
				}
			}
			if (type == null)
				throw new ArgumentNullException(nameof(type));
#endif
			var result = new CrefParameterSyntax(SyntaxKind.CrefParameter, refKindKeyword, type);
			return result;
		}

		public static IfDirectiveTriviaSyntax IfDirectiveTrivia(SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
		{
#if DEBUG
			if (hashToken == null)
				throw new ArgumentNullException(nameof(hashToken));
			switch (hashToken.Kind)
			{
				case SyntaxKind.HashToken:
					break;
				default:
					throw new ArgumentException(nameof(hashToken));
			}
			if (ifKeyword == null)
				throw new ArgumentNullException(nameof(ifKeyword));
			switch (ifKeyword.Kind)
			{
				case SyntaxKind.IfKeyword:
					break;
				default:
					throw new ArgumentException(nameof(ifKeyword));
			}
			if (condition == null)
				throw new ArgumentNullException(nameof(condition));
			if (endOfDirectiveToken == null)
				throw new ArgumentNullException(nameof(endOfDirectiveToken));
			switch (endOfDirectiveToken.Kind)
			{
				case SyntaxKind.EndOfDirectiveToken:
					break;
				default:
					throw new ArgumentException(nameof(endOfDirectiveToken));
			}
#endif

			return new IfDirectiveTriviaSyntax(SyntaxKind.IfDirectiveTrivia, hashToken, ifKeyword, condition, endOfDirectiveToken, isActive, branchTaken, conditionValue);
		}

		public static ElifDirectiveTriviaSyntax ElifDirectiveTrivia(SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
		{
#if DEBUG
			if (hashToken == null)
				throw new ArgumentNullException(nameof(hashToken));
			switch (hashToken.Kind)
			{
				case SyntaxKind.HashToken:
					break;
				default:
					throw new ArgumentException(nameof(hashToken));
			}
			if (elifKeyword == null)
				throw new ArgumentNullException(nameof(elifKeyword));
			switch (elifKeyword.Kind)
			{
				case SyntaxKind.ElifKeyword:
					break;
				default:
					throw new ArgumentException(nameof(elifKeyword));
			}
			if (condition == null)
				throw new ArgumentNullException(nameof(condition));
			if (endOfDirectiveToken == null)
				throw new ArgumentNullException(nameof(endOfDirectiveToken));
			switch (endOfDirectiveToken.Kind)
			{
				case SyntaxKind.EndOfDirectiveToken:
					break;
				default:
					throw new ArgumentException(nameof(endOfDirectiveToken));
			}
#endif

			return new ElifDirectiveTriviaSyntax(SyntaxKind.ElifDirectiveTrivia, hashToken, elifKeyword, condition, endOfDirectiveToken, isActive, branchTaken, conditionValue);
		}

		public static ElseDirectiveTriviaSyntax ElseDirectiveTrivia(SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken)
		{
#if DEBUG
			if (hashToken == null)
				throw new ArgumentNullException(nameof(hashToken));
			switch (hashToken.Kind)
			{
				case SyntaxKind.HashToken:
					break;
				default:
					throw new ArgumentException(nameof(hashToken));
			}
			if (elseKeyword == null)
				throw new ArgumentNullException(nameof(elseKeyword));
			switch (elseKeyword.Kind)
			{
				case SyntaxKind.ElseKeyword:
					break;
				default:
					throw new ArgumentException(nameof(elseKeyword));
			}
			if (endOfDirectiveToken == null)
				throw new ArgumentNullException(nameof(endOfDirectiveToken));
			switch (endOfDirectiveToken.Kind)
			{
				case SyntaxKind.EndOfDirectiveToken:
					break;
				default:
					throw new ArgumentException(nameof(endOfDirectiveToken));
			}
#endif

			return new ElseDirectiveTriviaSyntax(SyntaxKind.ElseDirectiveTrivia, hashToken, elseKeyword, endOfDirectiveToken, isActive, branchTaken);
		}

		public static EndIfDirectiveTriviaSyntax EndIfDirectiveTrivia(SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
		{
#if DEBUG
			if (hashToken == null)
				throw new ArgumentNullException(nameof(hashToken));
			switch (hashToken.Kind)
			{
				case SyntaxKind.HashToken:
					break;
				default:
					throw new ArgumentException(nameof(hashToken));
			}
			if (endIfKeyword == null)
				throw new ArgumentNullException(nameof(endIfKeyword));
			switch (endIfKeyword.Kind)
			{
				case SyntaxKind.EndIfKeyword:
					break;
				default:
					throw new ArgumentException(nameof(endIfKeyword));
			}
			if (endOfDirectiveToken == null)
				throw new ArgumentNullException(nameof(endOfDirectiveToken));
			switch (endOfDirectiveToken.Kind)
			{
				case SyntaxKind.EndOfDirectiveToken:
					break;
				default:
					throw new ArgumentException(nameof(endOfDirectiveToken));
			}
#endif

			return new EndIfDirectiveTriviaSyntax(SyntaxKind.EndIfDirectiveTrivia, hashToken, endIfKeyword, endOfDirectiveToken, isActive);
		}

		public static RegionDirectiveTriviaSyntax RegionDirectiveTrivia(SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
		{
#if DEBUG
			if (hashToken == null)
				throw new ArgumentNullException(nameof(hashToken));
			switch (hashToken.Kind)
			{
				case SyntaxKind.HashToken:
					break;
				default:
					throw new ArgumentException(nameof(hashToken));
			}
			if (regionKeyword == null)
				throw new ArgumentNullException(nameof(regionKeyword));
			switch (regionKeyword.Kind)
			{
				case SyntaxKind.RegionKeyword:
					break;
				default:
					throw new ArgumentException(nameof(regionKeyword));
			}
			if (endOfDirectiveToken == null)
				throw new ArgumentNullException(nameof(endOfDirectiveToken));
			switch (endOfDirectiveToken.Kind)
			{
				case SyntaxKind.EndOfDirectiveToken:
					break;
				default:
					throw new ArgumentException(nameof(endOfDirectiveToken));
			}
#endif

			return new RegionDirectiveTriviaSyntax(SyntaxKind.RegionDirectiveTrivia, hashToken, regionKeyword, endOfDirectiveToken, isActive);
		}

		public static EndRegionDirectiveTriviaSyntax EndRegionDirectiveTrivia(SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
		{
#if DEBUG
			if (hashToken == null)
				throw new ArgumentNullException(nameof(hashToken));
			switch (hashToken.Kind)
			{
				case SyntaxKind.HashToken:
					break;
				default:
					throw new ArgumentException(nameof(hashToken));
			}
			if (endRegionKeyword == null)
				throw new ArgumentNullException(nameof(endRegionKeyword));
			switch (endRegionKeyword.Kind)
			{
				case SyntaxKind.EndRegionKeyword:
					break;
				default:
					throw new ArgumentException(nameof(endRegionKeyword));
			}
			if (endOfDirectiveToken == null)
				throw new ArgumentNullException(nameof(endOfDirectiveToken));
			switch (endOfDirectiveToken.Kind)
			{
				case SyntaxKind.EndOfDirectiveToken:
					break;
				default:
					throw new ArgumentException(nameof(endOfDirectiveToken));
			}
#endif

			return new EndRegionDirectiveTriviaSyntax(SyntaxKind.EndRegionDirectiveTrivia, hashToken, endRegionKeyword, endOfDirectiveToken, isActive);
		}

		public static ErrorDirectiveTriviaSyntax ErrorDirectiveTrivia(SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
		{
#if DEBUG
			if (hashToken == null)
				throw new ArgumentNullException(nameof(hashToken));
			switch (hashToken.Kind)
			{
				case SyntaxKind.HashToken:
					break;
				default:
					throw new ArgumentException(nameof(hashToken));
			}
			if (errorKeyword == null)
				throw new ArgumentNullException(nameof(errorKeyword));
			switch (errorKeyword.Kind)
			{
				case SyntaxKind.ErrorKeyword:
					break;
				default:
					throw new ArgumentException(nameof(errorKeyword));
			}
			if (endOfDirectiveToken == null)
				throw new ArgumentNullException(nameof(endOfDirectiveToken));
			switch (endOfDirectiveToken.Kind)
			{
				case SyntaxKind.EndOfDirectiveToken:
					break;
				default:
					throw new ArgumentException(nameof(endOfDirectiveToken));
			}
#endif

			return new ErrorDirectiveTriviaSyntax(SyntaxKind.ErrorDirectiveTrivia, hashToken, errorKeyword, endOfDirectiveToken, isActive);
		}

		public static WarningDirectiveTriviaSyntax WarningDirectiveTrivia(SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
		{
#if DEBUG
			if (hashToken == null)
				throw new ArgumentNullException(nameof(hashToken));
			switch (hashToken.Kind)
			{
				case SyntaxKind.HashToken:
					break;
				default:
					throw new ArgumentException(nameof(hashToken));
			}
			if (warningKeyword == null)
				throw new ArgumentNullException(nameof(warningKeyword));
			switch (warningKeyword.Kind)
			{
				case SyntaxKind.WarningKeyword:
					break;
				default:
					throw new ArgumentException(nameof(warningKeyword));
			}
			if (endOfDirectiveToken == null)
				throw new ArgumentNullException(nameof(endOfDirectiveToken));
			switch (endOfDirectiveToken.Kind)
			{
				case SyntaxKind.EndOfDirectiveToken:
					break;
				default:
					throw new ArgumentException(nameof(endOfDirectiveToken));
			}
#endif

			return new WarningDirectiveTriviaSyntax(SyntaxKind.WarningDirectiveTrivia, hashToken, warningKeyword, endOfDirectiveToken, isActive);
		}

		public static BadDirectiveTriviaSyntax BadDirectiveTrivia(SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive)
		{
#if DEBUG
			if (hashToken == null)
				throw new ArgumentNullException(nameof(hashToken));
			switch (hashToken.Kind)
			{
				case SyntaxKind.HashToken:
					break;
				default:
					throw new ArgumentException(nameof(hashToken));
			}
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));
			if (endOfDirectiveToken == null)
				throw new ArgumentNullException(nameof(endOfDirectiveToken));
			switch (endOfDirectiveToken.Kind)
			{
				case SyntaxKind.EndOfDirectiveToken:
					break;
				default:
					throw new ArgumentException(nameof(endOfDirectiveToken));
			}
#endif

			return new BadDirectiveTriviaSyntax(SyntaxKind.BadDirectiveTrivia, hashToken, identifier, endOfDirectiveToken, isActive);
		}

		public static DefineDirectiveTriviaSyntax DefineDirectiveTrivia(SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
		{
#if DEBUG
			if (hashToken == null)
				throw new ArgumentNullException(nameof(hashToken));
			switch (hashToken.Kind)
			{
				case SyntaxKind.HashToken:
					break;
				default:
					throw new ArgumentException(nameof(hashToken));
			}
			if (defineKeyword == null)
				throw new ArgumentNullException(nameof(defineKeyword));
			switch (defineKeyword.Kind)
			{
				case SyntaxKind.DefineKeyword:
					break;
				default:
					throw new ArgumentException(nameof(defineKeyword));
			}
			if (name == null)
				throw new ArgumentNullException(nameof(name));
			switch (name.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(name));
			}
			if (endOfDirectiveToken == null)
				throw new ArgumentNullException(nameof(endOfDirectiveToken));
			switch (endOfDirectiveToken.Kind)
			{
				case SyntaxKind.EndOfDirectiveToken:
					break;
				default:
					throw new ArgumentException(nameof(endOfDirectiveToken));
			}
#endif

			return new DefineDirectiveTriviaSyntax(SyntaxKind.DefineDirectiveTrivia, hashToken, defineKeyword, name, endOfDirectiveToken, isActive);
		}

		public static UndefDirectiveTriviaSyntax UndefDirectiveTrivia(SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
		{
#if DEBUG
			if (hashToken == null)
				throw new ArgumentNullException(nameof(hashToken));
			switch (hashToken.Kind)
			{
				case SyntaxKind.HashToken:
					break;
				default:
					throw new ArgumentException(nameof(hashToken));
			}
			if (undefKeyword == null)
				throw new ArgumentNullException(nameof(undefKeyword));
			switch (undefKeyword.Kind)
			{
				case SyntaxKind.UndefKeyword:
					break;
				default:
					throw new ArgumentException(nameof(undefKeyword));
			}
			if (name == null)
				throw new ArgumentNullException(nameof(name));
			switch (name.Kind)
			{
				case SyntaxKind.IdentifierToken:
					break;
				default:
					throw new ArgumentException(nameof(name));
			}
			if (endOfDirectiveToken == null)
				throw new ArgumentNullException(nameof(endOfDirectiveToken));
			switch (endOfDirectiveToken.Kind)
			{
				case SyntaxKind.EndOfDirectiveToken:
					break;
				default:
					throw new ArgumentException(nameof(endOfDirectiveToken));
			}
#endif

			return new UndefDirectiveTriviaSyntax(SyntaxKind.UndefDirectiveTrivia, hashToken, undefKeyword, name, endOfDirectiveToken, isActive);
		}

		public static LineDirectiveTriviaSyntax LineDirectiveTrivia(SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
		{
#if DEBUG
			if (hashToken == null)
				throw new ArgumentNullException(nameof(hashToken));
			switch (hashToken.Kind)
			{
				case SyntaxKind.HashToken:
					break;
				default:
					throw new ArgumentException(nameof(hashToken));
			}
			if (lineKeyword == null)
				throw new ArgumentNullException(nameof(lineKeyword));
			switch (lineKeyword.Kind)
			{
				case SyntaxKind.LineKeyword:
					break;
				default:
					throw new ArgumentException(nameof(lineKeyword));
			}
			if (line == null)
				throw new ArgumentNullException(nameof(line));
			switch (line.Kind)
			{
				case SyntaxKind.NumericLiteralToken:
				case SyntaxKind.DefaultKeyword:
				case SyntaxKind.HiddenKeyword:
					break;
				default:
					throw new ArgumentException(nameof(line));
			}
			if (file != null)
			{
				switch (file.Kind)
				{
					case SyntaxKind.StringLiteralToken:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(file));
				}
			}
			if (endOfDirectiveToken == null)
				throw new ArgumentNullException(nameof(endOfDirectiveToken));
			switch (endOfDirectiveToken.Kind)
			{
				case SyntaxKind.EndOfDirectiveToken:
					break;
				default:
					throw new ArgumentException(nameof(endOfDirectiveToken));
			}
#endif

			return new LineDirectiveTriviaSyntax(SyntaxKind.LineDirectiveTrivia, hashToken, lineKeyword, line, file, endOfDirectiveToken, isActive);
		}

		public static PragmaWarningDirectiveTriviaSyntax PragmaWarningDirectiveTrivia(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, SyntaxToken nullableKeyword, SyntaxList<ExpressionSyntax> errorCodes, SyntaxToken endOfDirectiveToken, bool isActive)
		{
#if DEBUG
			if (hashToken == null)
				throw new ArgumentNullException(nameof(hashToken));
			switch (hashToken.Kind)
			{
				case SyntaxKind.HashToken:
					break;
				default:
					throw new ArgumentException(nameof(hashToken));
			}
			if (pragmaKeyword == null)
				throw new ArgumentNullException(nameof(pragmaKeyword));
			switch (pragmaKeyword.Kind)
			{
				case SyntaxKind.PragmaKeyword:
					break;
				default:
					throw new ArgumentException(nameof(pragmaKeyword));
			}
			if (warningKeyword == null)
				throw new ArgumentNullException(nameof(warningKeyword));
			switch (warningKeyword.Kind)
			{
				case SyntaxKind.WarningKeyword:
					break;
				default:
					throw new ArgumentException(nameof(warningKeyword));
			}
			if (disableOrRestoreKeyword == null)
				throw new ArgumentNullException(nameof(disableOrRestoreKeyword));
			switch (disableOrRestoreKeyword.Kind)
			{
				case SyntaxKind.DisableKeyword:
				case SyntaxKind.RestoreKeyword:
				case SyntaxKind.EnableKeyword:
				case SyntaxKind.SafeOnlyKeyword:
					break;
				default:
					throw new ArgumentException(nameof(disableOrRestoreKeyword));
			}
			if (nullableKeyword != null)
			{
				switch (nullableKeyword.Kind)
				{
					case SyntaxKind.NullableKeyword:
					case SyntaxKind.None:
						break;
					default:
						throw new ArgumentException(nameof(nullableKeyword));
				}
			}
			if (endOfDirectiveToken == null)
				throw new ArgumentNullException(nameof(endOfDirectiveToken));
			switch (endOfDirectiveToken.Kind)
			{
				case SyntaxKind.EndOfDirectiveToken:
					break;
				default:
					throw new ArgumentException(nameof(endOfDirectiveToken));
			}
#endif

			return new PragmaWarningDirectiveTriviaSyntax(SyntaxKind.PragmaWarningDirectiveTrivia, hashToken, pragmaKeyword, warningKeyword, disableOrRestoreKeyword, nullableKeyword, errorCodes.Node, endOfDirectiveToken, isActive);
		}

		public static PragmaChecksumDirectiveTriviaSyntax PragmaChecksumDirectiveTrivia(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive)
		{
#if DEBUG
			if (hashToken == null)
				throw new ArgumentNullException(nameof(hashToken));
			switch (hashToken.Kind)
			{
				case SyntaxKind.HashToken:
					break;
				default:
					throw new ArgumentException(nameof(hashToken));
			}
			if (pragmaKeyword == null)
				throw new ArgumentNullException(nameof(pragmaKeyword));
			switch (pragmaKeyword.Kind)
			{
				case SyntaxKind.PragmaKeyword:
					break;
				default:
					throw new ArgumentException(nameof(pragmaKeyword));
			}
			if (checksumKeyword == null)
				throw new ArgumentNullException(nameof(checksumKeyword));
			switch (checksumKeyword.Kind)
			{
				case SyntaxKind.ChecksumKeyword:
					break;
				default:
					throw new ArgumentException(nameof(checksumKeyword));
			}
			if (file == null)
				throw new ArgumentNullException(nameof(file));
			switch (file.Kind)
			{
				case SyntaxKind.StringLiteralToken:
					break;
				default:
					throw new ArgumentException(nameof(file));
			}
			if (guid == null)
				throw new ArgumentNullException(nameof(guid));
			switch (guid.Kind)
			{
				case SyntaxKind.StringLiteralToken:
					break;
				default:
					throw new ArgumentException(nameof(guid));
			}
			if (bytes == null)
				throw new ArgumentNullException(nameof(bytes));
			switch (bytes.Kind)
			{
				case SyntaxKind.StringLiteralToken:
					break;
				default:
					throw new ArgumentException(nameof(bytes));
			}
			if (endOfDirectiveToken == null)
				throw new ArgumentNullException(nameof(endOfDirectiveToken));
			switch (endOfDirectiveToken.Kind)
			{
				case SyntaxKind.EndOfDirectiveToken:
					break;
				default:
					throw new ArgumentException(nameof(endOfDirectiveToken));
			}
#endif

			return new PragmaChecksumDirectiveTriviaSyntax(SyntaxKind.PragmaChecksumDirectiveTrivia, hashToken, pragmaKeyword, checksumKeyword, file, guid, bytes, endOfDirectiveToken, isActive);
		}

		public static ReferenceDirectiveTriviaSyntax ReferenceDirectiveTrivia(SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
		{
#if DEBUG
			if (hashToken == null)
				throw new ArgumentNullException(nameof(hashToken));
			switch (hashToken.Kind)
			{
				case SyntaxKind.HashToken:
					break;
				default:
					throw new ArgumentException(nameof(hashToken));
			}
			if (referenceKeyword == null)
				throw new ArgumentNullException(nameof(referenceKeyword));
			switch (referenceKeyword.Kind)
			{
				case SyntaxKind.ReferenceKeyword:
					break;
				default:
					throw new ArgumentException(nameof(referenceKeyword));
			}
			if (file == null)
				throw new ArgumentNullException(nameof(file));
			switch (file.Kind)
			{
				case SyntaxKind.StringLiteralToken:
					break;
				default:
					throw new ArgumentException(nameof(file));
			}
			if (endOfDirectiveToken == null)
				throw new ArgumentNullException(nameof(endOfDirectiveToken));
			switch (endOfDirectiveToken.Kind)
			{
				case SyntaxKind.EndOfDirectiveToken:
					break;
				default:
					throw new ArgumentException(nameof(endOfDirectiveToken));
			}
#endif

			return new ReferenceDirectiveTriviaSyntax(SyntaxKind.ReferenceDirectiveTrivia, hashToken, referenceKeyword, file, endOfDirectiveToken, isActive);
		}

		public static LoadDirectiveTriviaSyntax LoadDirectiveTrivia(SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
		{
#if DEBUG
			if (hashToken == null)
				throw new ArgumentNullException(nameof(hashToken));
			switch (hashToken.Kind)
			{
				case SyntaxKind.HashToken:
					break;
				default:
					throw new ArgumentException(nameof(hashToken));
			}
			if (loadKeyword == null)
				throw new ArgumentNullException(nameof(loadKeyword));
			switch (loadKeyword.Kind)
			{
				case SyntaxKind.LoadKeyword:
					break;
				default:
					throw new ArgumentException(nameof(loadKeyword));
			}
			if (file == null)
				throw new ArgumentNullException(nameof(file));
			switch (file.Kind)
			{
				case SyntaxKind.StringLiteralToken:
					break;
				default:
					throw new ArgumentException(nameof(file));
			}
			if (endOfDirectiveToken == null)
				throw new ArgumentNullException(nameof(endOfDirectiveToken));
			switch (endOfDirectiveToken.Kind)
			{
				case SyntaxKind.EndOfDirectiveToken:
					break;
				default:
					throw new ArgumentException(nameof(endOfDirectiveToken));
			}
#endif

			return new LoadDirectiveTriviaSyntax(SyntaxKind.LoadDirectiveTrivia, hashToken, loadKeyword, file, endOfDirectiveToken, isActive);
		}

		public static ShebangDirectiveTriviaSyntax ShebangDirectiveTrivia(SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive)
		{
#if DEBUG
			if (hashToken == null)
				throw new ArgumentNullException(nameof(hashToken));
			switch (hashToken.Kind)
			{
				case SyntaxKind.HashToken:
					break;
				default:
					throw new ArgumentException(nameof(hashToken));
			}
			if (exclamationToken == null)
				throw new ArgumentNullException(nameof(exclamationToken));
			switch (exclamationToken.Kind)
			{
				case SyntaxKind.ExclamationToken:
					break;
				default:
					throw new ArgumentException(nameof(exclamationToken));
			}
			if (endOfDirectiveToken == null)
				throw new ArgumentNullException(nameof(endOfDirectiveToken));
			switch (endOfDirectiveToken.Kind)
			{
				case SyntaxKind.EndOfDirectiveToken:
					break;
				default:
					throw new ArgumentException(nameof(endOfDirectiveToken));
			}
#endif

			return new ShebangDirectiveTriviaSyntax(SyntaxKind.ShebangDirectiveTrivia, hashToken, exclamationToken, endOfDirectiveToken, isActive);
		}

		public static NullableDirectiveTriviaSyntax NullableDirectiveTrivia(SyntaxToken hashToken, SyntaxToken nullableKeyword, SyntaxToken settingToken, SyntaxToken endOfDirectiveToken, bool isActive)
		{
#if DEBUG
			if (hashToken == null)
				throw new ArgumentNullException(nameof(hashToken));
			switch (hashToken.Kind)
			{
				case SyntaxKind.HashToken:
					break;
				default:
					throw new ArgumentException(nameof(hashToken));
			}
			if (nullableKeyword == null)
				throw new ArgumentNullException(nameof(nullableKeyword));
			switch (nullableKeyword.Kind)
			{
				case SyntaxKind.NullableKeyword:
					break;
				default:
					throw new ArgumentException(nameof(nullableKeyword));
			}
			if (settingToken == null)
				throw new ArgumentNullException(nameof(settingToken));
			switch (settingToken.Kind)
			{
				case SyntaxKind.EnableKeyword:
				case SyntaxKind.DisableKeyword:
				case SyntaxKind.RestoreKeyword:
				case SyntaxKind.SafeOnlyKeyword:
					break;
				default:
					throw new ArgumentException(nameof(settingToken));
			}
			if (endOfDirectiveToken == null)
				throw new ArgumentNullException(nameof(endOfDirectiveToken));
			switch (endOfDirectiveToken.Kind)
			{
				case SyntaxKind.EndOfDirectiveToken:
					break;
				default:
					throw new ArgumentException(nameof(endOfDirectiveToken));
			}
#endif

			return new NullableDirectiveTriviaSyntax(SyntaxKind.NullableDirectiveTrivia, hashToken, nullableKeyword, settingToken, endOfDirectiveToken, isActive);
		}

		public static IEnumerable<Type> GetNodeTypes()
		{
			return new Type[] {
		   typeof(IdentifierNameSyntax),
		   typeof(QualifiedNameSyntax),
		   typeof(GenericNameSyntax),
		   typeof(TypeArgumentListSyntax),
		   typeof(AliasQualifiedNameSyntax),
		   typeof(PredefinedTypeSyntax),
		   typeof(ArrayTypeSyntax),
		   typeof(ArrayRankSpecifierSyntax),
		   typeof(PointerTypeSyntax),
		   typeof(NullableTypeSyntax),
		   typeof(TupleTypeSyntax),
		   typeof(TupleElementSyntax),
		   typeof(OmittedTypeArgumentSyntax),
		   typeof(RefTypeSyntax),
		   typeof(ParenthesizedExpressionSyntax),
		   typeof(TupleExpressionSyntax),
		   typeof(PrefixUnaryExpressionSyntax),
		   typeof(AwaitExpressionSyntax),
		   typeof(PostfixUnaryExpressionSyntax),
		   typeof(MemberAccessExpressionSyntax),
		   typeof(ConditionalAccessExpressionSyntax),
		   typeof(MemberBindingExpressionSyntax),
		   typeof(ElementBindingExpressionSyntax),
		   typeof(RangeExpressionSyntax),
		   typeof(ImplicitElementAccessSyntax),
		   typeof(BinaryExpressionSyntax),
		   typeof(AssignmentExpressionSyntax),
		   typeof(ConditionalExpressionSyntax),
		   typeof(ThisExpressionSyntax),
		   typeof(BaseExpressionSyntax),
		   typeof(LiteralExpressionSyntax),
		   typeof(MakeRefExpressionSyntax),
		   typeof(RefTypeExpressionSyntax),
		   typeof(RefValueExpressionSyntax),
		   typeof(CheckedExpressionSyntax),
		   typeof(DefaultExpressionSyntax),
		   typeof(TypeOfExpressionSyntax),
		   typeof(SizeOfExpressionSyntax),
		   typeof(InvocationExpressionSyntax),
		   typeof(ElementAccessExpressionSyntax),
		   typeof(ArgumentListSyntax),
		   typeof(BracketedArgumentListSyntax),
		   typeof(ArgumentSyntax),
		   typeof(NameColonSyntax),
		   typeof(DeclarationExpressionSyntax),
		   typeof(CastExpressionSyntax),
		   typeof(AnonymousMethodExpressionSyntax),
		   typeof(SimpleLambdaExpressionSyntax),
		   typeof(RefExpressionSyntax),
		   typeof(ParenthesizedLambdaExpressionSyntax),
		   typeof(InitializerExpressionSyntax),
		   typeof(ObjectCreationExpressionSyntax),
		   typeof(AnonymousObjectMemberDeclaratorSyntax),
		   typeof(AnonymousObjectCreationExpressionSyntax),
		   typeof(ArrayCreationExpressionSyntax),
		   typeof(ImplicitArrayCreationExpressionSyntax),
		   typeof(StackAllocArrayCreationExpressionSyntax),
		   typeof(ImplicitStackAllocArrayCreationExpressionSyntax),
		   typeof(QueryExpressionSyntax),
		   typeof(QueryBodySyntax),
		   typeof(FromClauseSyntax),
		   typeof(LetClauseSyntax),
		   typeof(JoinClauseSyntax),
		   typeof(JoinIntoClauseSyntax),
		   typeof(WhereClauseSyntax),
		   typeof(OrderByClauseSyntax),
		   typeof(OrderingSyntax),
		   typeof(SelectClauseSyntax),
		   typeof(GroupClauseSyntax),
		   typeof(QueryContinuationSyntax),
		   typeof(OmittedArraySizeExpressionSyntax),
		   typeof(InterpolatedStringExpressionSyntax),
		   typeof(IsPatternExpressionSyntax),
		   typeof(ThrowExpressionSyntax),
		   typeof(WhenClauseSyntax),
		   typeof(DiscardPatternSyntax),
		   typeof(DeclarationPatternSyntax),
		   typeof(VarPatternSyntax),
		   typeof(RecursivePatternSyntax),
		   typeof(PositionalPatternClauseSyntax),
		   typeof(PropertyPatternClauseSyntax),
		   typeof(SubpatternSyntax),
		   typeof(ConstantPatternSyntax),
		   typeof(InterpolatedStringTextSyntax),
		   typeof(InterpolationSyntax),
		   typeof(InterpolationAlignmentClauseSyntax),
		   typeof(InterpolationFormatClauseSyntax),
		   typeof(GlobalStatementSyntax),
		   typeof(BlockSyntax),
		   typeof(LocalFunctionStatementSyntax),
		   typeof(LocalDeclarationStatementSyntax),
		   typeof(VariableDeclarationSyntax),
		   typeof(VariableDeclaratorSyntax),
		   typeof(EqualsValueClauseSyntax),
		   typeof(SingleVariableDesignationSyntax),
		   typeof(DiscardDesignationSyntax),
		   typeof(ParenthesizedVariableDesignationSyntax),
		   typeof(ExpressionStatementSyntax),
		   typeof(EmptyStatementSyntax),
		   typeof(LabeledStatementSyntax),
		   typeof(GotoStatementSyntax),
		   typeof(BreakStatementSyntax),
		   typeof(ContinueStatementSyntax),
		   typeof(ReturnStatementSyntax),
		   typeof(ThrowStatementSyntax),
		   typeof(YieldStatementSyntax),
		   typeof(WhileStatementSyntax),
		   typeof(DoStatementSyntax),
		   typeof(ForStatementSyntax),
		   typeof(ForEachStatementSyntax),
		   typeof(ForEachVariableStatementSyntax),
		   typeof(UsingStatementSyntax),
		   typeof(FixedStatementSyntax),
		   typeof(CheckedStatementSyntax),
		   typeof(UnsafeStatementSyntax),
		   typeof(LockStatementSyntax),
		   typeof(IfStatementSyntax),
		   typeof(ElseClauseSyntax),
		   typeof(SwitchStatementSyntax),
		   typeof(SwitchSectionSyntax),
		   typeof(CasePatternSwitchLabelSyntax),
		   typeof(CaseSwitchLabelSyntax),
		   typeof(DefaultSwitchLabelSyntax),
		   typeof(SwitchExpressionSyntax),
		   typeof(SwitchExpressionArmSyntax),
		   typeof(TryStatementSyntax),
		   typeof(CatchClauseSyntax),
		   typeof(CatchDeclarationSyntax),
		   typeof(CatchFilterClauseSyntax),
		   typeof(FinallyClauseSyntax),
		   typeof(CompilationUnitSyntax),
		   typeof(ExternAliasDirectiveSyntax),
		   typeof(UsingDirectiveSyntax),
		   typeof(NamespaceDeclarationSyntax),
		   typeof(AttributeListSyntax),
		   typeof(AttributeTargetSpecifierSyntax),
		   typeof(AttributeSyntax),
		   typeof(AttributeArgumentListSyntax),
		   typeof(AttributeArgumentSyntax),
		   typeof(NameEqualsSyntax),
		   typeof(TypeParameterListSyntax),
		   typeof(TypeParameterSyntax),
		   typeof(ClassDeclarationSyntax),
		   typeof(StructDeclarationSyntax),
		   typeof(InterfaceDeclarationSyntax),
		   typeof(EnumDeclarationSyntax),
		   typeof(DelegateDeclarationSyntax),
		   typeof(EnumMemberDeclarationSyntax),
		   typeof(BaseListSyntax),
		   typeof(SimpleBaseTypeSyntax),
		   typeof(TypeParameterConstraintClauseSyntax),
		   typeof(ConstructorConstraintSyntax),
		   typeof(ClassOrStructConstraintSyntax),
		   typeof(TypeConstraintSyntax),
		   typeof(FieldDeclarationSyntax),
		   typeof(EventFieldDeclarationSyntax),
		   typeof(ExplicitInterfaceSpecifierSyntax),
		   typeof(MethodDeclarationSyntax),
		   typeof(OperatorDeclarationSyntax),
		   typeof(ConversionOperatorDeclarationSyntax),
		   typeof(ConstructorDeclarationSyntax),
		   typeof(ConstructorInitializerSyntax),
		   typeof(DestructorDeclarationSyntax),
		   typeof(PropertyDeclarationSyntax),
		   typeof(ArrowExpressionClauseSyntax),
		   typeof(EventDeclarationSyntax),
		   typeof(IndexerDeclarationSyntax),
		   typeof(AccessorListSyntax),
		   typeof(AccessorDeclarationSyntax),
		   typeof(ParameterListSyntax),
		   typeof(BracketedParameterListSyntax),
		   typeof(ParameterSyntax),
		   typeof(IncompleteMemberSyntax),
		   typeof(SkippedTokensTriviaSyntax),
		   typeof(TypeCrefSyntax),
		   typeof(QualifiedCrefSyntax),
		   typeof(NameMemberCrefSyntax),
		   typeof(IndexerMemberCrefSyntax),
		   typeof(OperatorMemberCrefSyntax),
		   typeof(ConversionOperatorMemberCrefSyntax),
		   typeof(CrefParameterListSyntax),
		   typeof(CrefBracketedParameterListSyntax),
		   typeof(CrefParameterSyntax),
		   typeof(IfDirectiveTriviaSyntax),
		   typeof(ElifDirectiveTriviaSyntax),
		   typeof(ElseDirectiveTriviaSyntax),
		   typeof(EndIfDirectiveTriviaSyntax),
		   typeof(RegionDirectiveTriviaSyntax),
		   typeof(EndRegionDirectiveTriviaSyntax),
		   typeof(ErrorDirectiveTriviaSyntax),
		   typeof(WarningDirectiveTriviaSyntax),
		   typeof(BadDirectiveTriviaSyntax),
		   typeof(DefineDirectiveTriviaSyntax),
		   typeof(UndefDirectiveTriviaSyntax),
		   typeof(LineDirectiveTriviaSyntax),
		   typeof(PragmaWarningDirectiveTriviaSyntax),
		   typeof(PragmaChecksumDirectiveTriviaSyntax),
		   typeof(ReferenceDirectiveTriviaSyntax),
		   typeof(LoadDirectiveTriviaSyntax),
		   typeof(ShebangDirectiveTriviaSyntax),
		   typeof(NullableDirectiveTriviaSyntax)
		};
		}
	}
}
